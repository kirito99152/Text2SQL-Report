// src/services/selfCheckService.js

const aiService = require('./aiService');
const prompts = require('../prompts');
const promptsRetry = require('../prompts_retry');

class SelfCheckService {

    /**
     * Verifies and corrects the generated SQL based on the plan and schema.
     * @param {string|Object} plan - The query plan
     * @param {string} schemaContext - The schema context
     * @param {string} generatedSql - The SQL generated by the previous step
     * @returns {string} - The verified (and potentially corrected) SQL
     */
    async verifyAndCorrectSql(plan, schemaContext, generatedSql) {
        const planString = typeof plan === 'string' ? plan : JSON.stringify(plan, null, 2);

        // --- Attempt 1: Original prompt ---
        try {
            let prompt = prompts.SQL_SELF_CHECK_PROMPT;
            prompt = prompt.replace('{{schema_context}}', schemaContext);
            prompt = prompt.replace('{{query_plan}}', planString);
            prompt = prompt.replace('{{generated_sql}}', generatedSql);

            const messages = [
                { role: 'system', content: 'You are a strict SQL validator. Output VALID or the corrected SQL only.' },
                { role: 'user', content: prompt }
            ];

            console.log("[SelfCheckService] Verifying SQL...");
            const response = await aiService.generateJson(messages, true);
            let cleaned = this.cleanResponse(response);

            if (cleaned.trim().toUpperCase() === 'VALID') {
                console.log("[SelfCheckService] SQL verified as VALID.");
                return generatedSql;
            } else {
                console.log("[SelfCheckService] SQL corrected by model.");
                return cleaned;
            }

        } catch (error) {
            console.warn("[SelfCheckService] Original prompt failed, retrying with compact prompt...", error.message);
        }

        // --- Attempt 2: Retry with compact prompt ---
        try {
            let prompt = promptsRetry.SQL_SELF_CHECK_PROMPT;
            prompt = prompt.replace('{{schema_context}}', schemaContext);
            prompt = prompt.replace('{{query_plan}}', planString);
            prompt = prompt.replace('{{generated_sql}}', generatedSql);

            const messages = [
                { role: 'system', content: 'You are a strict SQL validator. Be concise. Output VALID or corrected SQL only.' },
                { role: 'user', content: prompt }
            ];

            console.log("[SelfCheckService] RETRY: Verifying SQL with compact prompt...");
            const response = await aiService.generateJson(messages, true);
            let cleaned = this.cleanResponse(response);

            if (cleaned.trim().toUpperCase() === 'VALID') {
                console.log("[SelfCheckService] RETRY: SQL verified as VALID.");
                return generatedSql;
            } else {
                console.log("[SelfCheckService] RETRY: SQL corrected by model.");
                return cleaned;
            }

        } catch (retryError) {
            console.error("[SelfCheckService] Retry also failed:", retryError.message);
            // Fallback: return the original SQL if both attempts fail
            return generatedSql;
        }
    }

    cleanResponse(text) {
        // Remove <think> blocks if present
        let cleaned = text.replace(/<think>[\s\S]*?<\/think>/g, '').trim();

        // 1. If the model says "VALID" (case-insensitive) as a standalone word, return "VALID"
        if (/\bVALID\b/i.test(cleaned)) {
            return "VALID";
        }

        // 2. Remove markdown code blocks
        cleaned = cleaned.replace(/```sql/gi, '').replace(/```/g, '').trim();

        // 3. User request: Extract from "SELECT" (case-insensitive) to the nearest ";"
        // Use regex: /SELECT[\s\S]*?;/i
        // [\s\S]*? is non-greedy match of any character including newlines.
        const match = cleaned.match(/SELECT[\s\S]*?;/i);

        if (match) {
            return match[0].replace(/\s+/g, ' ').trim();
        }

        // Fallback: return the cleaned text if no SELECT...; pattern found
        return cleaned.replace(/\s+/g, ' ').trim();
    }
}

module.exports = new SelfCheckService();
