[
  {
    "id": 764,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same condition, group by the same column (hoa_don.so_hoa_don), and order by the same count to find the invoice with the most financial transactions."
  },
  {
    "id": 765,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same condition, group by the same column (hoa_don.so_hoa_don), and order by the same count to find the invoice with the most financial transactions."
  },
  {
    "id": 766,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'hoa_don'. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 767,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'hoa_don'. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 768,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query selects only from hoa_don table with 3 columns, while Gold query joins hoa_don with don_dat_hang and selects different columns (including t2.chi_tiet_dat_hang). These are fundamentally different queries with different table sources and column selections."
  },
  {
    "id": 769,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are table aliases (t1/t2 vs table names) and whitespace formatting, which are cosmetic differences per the rules."
  },
  {
    "id": 770,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "The queries join different tables - Gen joins both don_dat_hang and hoa_dong tables, while Gold only queries from hoa_don table. This creates different result sets as Gen counts orders with invoices while Gold counts all invoices regardless of orders."
  },
  {
    "id": 771,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "The queries join different tables - Gen joins don_dat_hang with hoa_don while Gold only queries hoa_don. This creates different result sets as Gen requires matching records in both tables."
  },
  {
    "id": 772,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 70,
    "reason": "Both queries join the same tables with the same condition and filter for orders with >2 invoices, but Gen includes extra column 'ngay_dat_hang' in SELECT and uses COUNT(T2.id_hoa_don) vs COUNT(*), which are functionally equivalent for counting rows."
  },
  {
    "id": 773,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "Different HAVING conditions: Gen uses COUNT(*) >= 2 while Gold uses COUNT(*) > 2, which are not semantically equivalent as they exclude the case where count equals exactly 2."
  },
  {
    "id": 774,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column order. Both find the customer with the most orders by joining the same tables with the same condition, grouping by customer ID, and ordering by order count."
  },
  {
    "id": 775,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and table order - both find the customer with the most orders by joining khach_hang and don_dat_hang tables, grouping by customer ID, and ordering by order count."
  },
  {
    "id": 776,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return products that haven't been ordered, using semantically equivalent NOT IN vs EXCEPT approaches. EXCEPT is the preferred SQL pattern for set exclusion."
  },
  {
    "id": 777,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return products not in the ordered items table using semantically equivalent exclusion logic (NOT IN vs EXCEPT with JOIN). The EXCEPT approach in Gold is actually preferred SQL practice for set exclusion."
  },
  {
    "id": 778,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 70,
    "reason": "Both queries join the same tables with the same condition and calculate the same sum, but they group by different columns (id_san_pham vs ten_san_pham). If ten_san_pham is functionally dependent on id_san_pham (unique per product), they would be equivalent, but this isn't guaranteed."
  },
  {
    "id": 779,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries aggregate product quantities but differ in GROUP BY: Gen groups by product ID while Gold groups by product name. If product name is unique/functionally dependent on ID, they are equivalent; otherwise, they may produce different results."
  },
  {
    "id": 780,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic: Gen uses SUM of specific column quantities, Gold uses COUNT of all rows. These produce different numeric results for the same order IDs."
  },
  {
    "id": 781,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "Gen query joins with don_dat_hang table while Gold query only uses mat_hang_duoc_dat table, resulting in different semantics - Gen counts per order from joined tables while Gold counts per order from single table."
  },
  {
    "id": 782,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query includes an unnecessary JOIN with the 'san_pham' table, while the Gold query only uses 'mat_hang_duoc_dat'. This creates different semantics as Gen requires matching records in both tables, potentially filtering out rows."
  },
  {
    "id": 783,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query includes a JOIN with 'san_pham' table while Gold only uses 'mat_hang_duoc_dat' table. This creates different semantics - Gen requires matching records between both tables, while Gold counts all records in mat_hang_duoc_dat regardless of san_pham existence."
  },
  {
    "id": 784,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(DISTINCT T3.id_khach_hang) while Gold uses COUNT(*), which count different things (unique customers vs all order items). Different GROUP BY columns: Gen groups by id_san_pham and ten_san_pham while Gold groups only by ten_san_pham."
  },
  {
    "id": 785,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen counts distinct customers per product, Gold counts all order items per product. Different GROUP BY columns: Gen groups by product ID, Gold groups by product name (assuming name is unique)."
  },
  {
    "id": 786,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 30,
    "reason": "Different aggregation logic (SUM of quantities vs COUNT DISTINCT of product IDs) and different table joins (Gen joins two tables while Gold uses only one table). These are semantic differences that will produce different results."
  },
  {
    "id": 787,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different tables: Gen joins don_dat_hang with mat_hang_duoc_dat, while Gold only uses mat_hang_duoc_dat. This creates different semantics - Gen requires matching records in both tables, Gold doesn't."
  },
  {
    "id": 788,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "Gen query includes JOIN with don_dat_hang table while Gold query only uses mat_hang_duoc_dat table. This creates different semantics - Gen sums quantities per order from joined tables, Gold sums quantities directly from mat_hang_duoc_dat."
  },
  {
    "id": 789,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different tables: Gen includes JOIN with don_dat_hang table while Gold only uses mat_hang_duoc_dat table. This creates different semantics as Gen requires matching records between tables while Gold aggregates all records from mat_hang_duoc_dat."
  },
  {
    "id": 790,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count products not in ordered items, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 791,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count products not in ordered items, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 792,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a difference in string literal values ('United States' vs 'USA'), which represent the same real-world country. Both count records from the same table with the same filtering logic."
  },
  {
    "id": 793,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are ignored according to the rules."
  },
  {
    "id": 794,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both count records by tieu_bang column from dia_chi table, with only cosmetic differences in formatting and table prefix usage."
  },
  {
    "id": 795,
    "db_id": "customers_and_products_contacts",
    "strict_match": false,
    "score": 40,
    "reason": "The queries use fundamentally different filtering logic: Gen checks for NULL addresses in the current table, while Gold excludes customers who appear in a separate address history table. These would return different results on many database states."
  },
  {
    "id": 796,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and whitespace. Both select the customer name with the highest order count using the same tables, join conditions, grouping, and ordering."
  },
  {
    "id": 797,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select product type codes from the same table, group by the same column, and filter for groups with at least 2 records using the same condition."
  },
  {
    "id": 798,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only language differences in WHERE clause string values: 'hoàn thành' vs 'completed' and 'hoàn thành một phần' vs 'part' represent the same status values in Vietnamese and English respectively."
  },
  {
    "id": 799,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same SELECT columns, same FROM table, same ORDER BY clause with same direction. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 800,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries join the same tables with identical conditions and perform the same aggregation. The only differences are table aliases and GROUP BY including ten_san_pham (which is functionally dependent on id_san_pham)."
  },
  {
    "id": 801,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same aggregate functions (MAX, MIN, AVG) on the same column from the same table, with only cosmetic differences in formatting and column order."
  },
  {
    "id": 802,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count products where price exceeds the average price, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 803,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same conditions and select the same columns, with only cosmetic differences in alias naming and formatting."
  },
  {
    "id": 804,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and Vietnamese vs English string literal values ('thẻ tín dụng' vs 'credit card') which represent the same payment method."
  },
  {
    "id": 805,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, column references, and CAST function usage. Both return the customer with highest total ordered quantity across all their orders."
  },
  {
    "id": 806,
    "db_id": "customers_and_products_contacts",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same tables, columns, and WHERE conditions with identical logic. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 807,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are keyword case (SELECT vs select) and whitespace formatting, which are cosmetic differences that don't affect results."
  },
  {
    "id": 808,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same ORDER BY clause (ASC is default). Only cosmetic differences exist (keyword case, whitespace, explicit ASC)."
  },
  {
    "id": 809,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both select the same three columns from the same table with no filtering, grouping, or ordering. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 810,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the maximum and minimum of the same column from the same table, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 811,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the average of so_luong_nhan_vien from cac_bo where xep_hang is between 10 and 15, with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 812,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition using equivalent string values (case-insensitive comparison). The only differences are cosmetic: keyword case, single vs double quotes, and column name case."
  },
  {
    "id": 813,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with equivalent conditions and filter on the same column value."
  },
  {
    "id": 814,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 815,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 816,
    "db_id": "department_management",
    "strict_match": false,
    "score": 50,
    "reason": "The Gold query has an additional WHERE condition (t2.vai_tro_tam_thoi = 'yes') that filters results, while the Generated query returns all joined rows without this filter. This creates different result sets."
  },
  {
    "id": 817,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table with identical syntax after normalization."
  },
  {
    "id": 818,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count rows from cac_bo where id_cac_bo is not in su_quan_ly, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 819,
    "db_id": "department_management",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions: Gen uses IS NOT NULL while Gold uses = 'yes', which are not semantically equivalent (NULL values vs specific string values)."
  },
  {
    "id": 820,
    "db_id": "department_management",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, column reference style, and Vietnamese vs English string values ('Bộ tài chính' vs 'treasury', 'Bộ An ninh nội địa' vs 'homeland security') which represent the same real-world entities."
  },
  {
    "id": 821,
    "db_id": "department_management",
    "strict_match": false,
    "score": 65,
    "reason": "Gen query includes an extra JOIN with 'bo_truong' table that Gold query doesn't have, which changes the semantics by potentially filtering or adding rows. Both queries have the same core structure but differ in table participation."
  },
  {
    "id": 822,
    "db_id": "department_management",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same LIKE condition. The only differences are cosmetic (keyword case, whitespace, and case in the LIKE pattern, which SQLite treats as case-insensitive by default)."
  },
  {
    "id": 823,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for keyword case (SELECT vs select), which is a cosmetic difference that does not affect the semantic meaning. Both queries will return exactly the same results from the same table."
  },
  {
    "id": 824,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in semantics, differing only in keyword case (SELECT vs select), which is a cosmetic difference that does not affect the result set."
  },
  {
    "id": 825,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 826,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'xe'. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 827,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same row(s) for id=1, but Gen includes an extra 'id' column in SELECT that Gold doesn't have. This is a minor cosmetic difference since the main answer (chi_tiet_ve_xe values) would be identical."
  },
  {
    "id": 828,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same row(s) where id=1, but Gen includes an extra 'id' column in SELECT that Gold doesn't request. This is a minor cosmetic difference that doesn't change the main answer."
  },
  {
    "id": 829,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting. Both select the same columns from the same table with no filtering or aggregation."
  },
  {
    "id": 830,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same three columns from the same table with no filtering or ordering. The only differences are column order and keyword case, which are cosmetic according to the rules."
  },
  {
    "id": 831,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical WHERE conditions, differing only in cosmetic aspects like keyword case and quote style."
  },
  {
    "id": 832,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 40,
    "reason": "The WHERE conditions are semantically different: Gen searches for full name in one column while Gold searches for first and last names in separate columns. These queries will return different results on many possible database states."
  },
  {
    "id": 833,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same rows from the same table with identical WHERE conditions, but Gen includes extra columns (ten, ho) in SELECT that Gold doesn't request. This is a minor cosmetic difference that doesn't affect the main answer."
  },
  {
    "id": 834,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE conditions. The only differences are cosmetic: keyword case, single vs double quotes, and letter case in string literals (which SQLite treats as case-insensitive by default for ASCII letters)."
  },
  {
    "id": 835,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE conditions, with only minor cosmetic differences in keyword case and quote style."
  },
  {
    "id": 836,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical WHERE conditions (same column names and same string values, ignoring case differences). The only differences are cosmetic: keyword case, quote style, and whitespace."
  },
  {
    "id": 837,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count rows from the same table with the same WHERE condition (same column name and same string value, ignoring case differences). The only differences are cosmetic: keyword case, whitespace formatting, and single vs double quotes."
  },
  {
    "id": 838,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count rows from the same table with the same WHERE condition (same column name and same string value, ignoring case differences). The only differences are cosmetic: keyword case, whitespace formatting, and single vs double quotes."
  },
  {
    "id": 839,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical WHERE conditions, differing only in keyword case and string literal quotes."
  },
  {
    "id": 840,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical WHERE conditions (only order of AND clauses differs). The string values match exactly when case-normalized."
  },
  {
    "id": 841,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 842,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count all rows from the same table 'nhan_vien' with identical COUNT(*) aggregation. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 843,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, selecting the same column. The only differences are cosmetic: table aliases, keyword case, and column alias usage."
  },
  {
    "id": 844,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 20,
    "reason": "The queries join different tables (khach_hang vs nhan_vien) and use different join conditions, so they will return different results on most database states."
  },
  {
    "id": 845,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and column references. Both query the same tables with identical JOIN conditions and WHERE filters."
  },
  {
    "id": 846,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved: Gen uses khach_hang (customer) table while Gold uses nhan_vien (employee) table. Different JOIN conditions and WHERE clauses reference different tables entirely."
  },
  {
    "id": 847,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 40,
    "reason": "Different aggregation logic: Gen uses COUNT(*) while Gold uses SUM(t1.gio_hoc). These will return different results unless every bai_giang record has exactly 1 gio_hoc value."
  },
  {
    "id": 848,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 30,
    "reason": "Different aggregation functions (COUNT vs SUM) and different columns being aggregated (COUNT(*) vs SUM(gio_hoc)). These are semantic differences that will produce different results on most datasets."
  },
  {
    "id": 849,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, selecting the same column with only cosmetic differences in aliases, case, and formatting."
  },
  {
    "id": 850,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with equivalent conditions and return the same column."
  },
  {
    "id": 851,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 40,
    "reason": "The Gen query joins nhan_vien and dia_chi tables, counting employees with addresses in Georgia, while Gold only counts addresses in Georgia regardless of employee association. These produce different results when addresses exist without associated employees."
  },
  {
    "id": 852,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 30,
    "reason": "The queries join different tables and filter on different columns - Gen joins nhan_vien with dia_chi and filters on quoc_gia, while Gold only queries dia_chi and filters on tieu_bang. These are semantically different conditions that would return different results in many database states."
  },
  {
    "id": 853,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent join conditions and filter on the same city value (case-insensitive string match). The only differences are table aliases, column references using aliases, and formatting/case variations."
  },
  {
    "id": 854,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and column order. Both join the same tables with equivalent conditions and select the same columns."
  },
  {
    "id": 855,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent join conditions, group by the same column, and order by the same aggregate count. The only differences are cosmetic: table aliases, whitespace formatting, and column alias naming."
  },
  {
    "id": 856,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column names. Both count employees per city and return the city with highest count."
  },
  {
    "id": 857,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both select the same column from the same tables with identical JOIN conditions, GROUP BY, and HAVING clause."
  },
  {
    "id": 858,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with equivalent conditions, group by the same column, and apply identical HAVING clauses. The only differences are cosmetic (aliases, formatting, and keyword case)."
  },
  {
    "id": 859,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - they select the same columns from the same table with no filtering or aggregation. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 860,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 861,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition. The differences are purely cosmetic: keyword case, whitespace, and single vs double quotes around the string literal."
  },
  {
    "id": 862,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences: keyword case (SELECT vs select), whitespace formatting, and string literal quote style (single vs double quotes). The WHERE condition uses the same value 'Carole' with only case difference, which SQLite treats as equivalent in default configuration."
  },
  {
    "id": 863,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition, with only minor cosmetic differences in formatting and keyword case."
  },
  {
    "id": 864,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 865,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing case, whitespace, and column order. The WHERE conditions are logically equivalent (same OR conditions with same values, just reordered)."
  },
  {
    "id": 866,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing case, whitespace, and column order. The WHERE conditions are logically equivalent (OR with same predicates in different order)."
  },
  {
    "id": 867,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value - 'Khách hàng tốt' (Vietnamese) and 'good customer' (English) represent the same real-world meaning for customer status."
  },
  {
    "id": 868,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical except for the string literal value in the WHERE clause, where 'Khách hàng tốt' (Vietnamese) and 'good customer' (English) represent the same real-world meaning according to the equivalence rules."
  },
  {
    "id": 869,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences: keyword case (SELECT vs select), string literal quotes (single vs double), and column value case (Carole vs carole, Bernhard vs bernhard). All differences are explicitly ignored per the rules."
  },
  {
    "id": 870,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same columns, same WHERE conditions (just reordered), same string values (case-insensitive comparison)."
  },
  {
    "id": 871,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 872,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering or grouping. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 873,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting. Both queries select the same columns, use the same aggregation, and have identical GROUP BY logic."
  },
  {
    "id": 874,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count customers by status code with identical SELECT, FROM, and GROUP BY clauses, differing only in cosmetic whitespace and keyword case."
  },
  {
    "id": 875,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the customer status code with the smallest count, with only minor cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 876,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the customer status code with the smallest count, differing only in cosmetic formatting (keyword case and whitespace)."
  },
  {
    "id": 877,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases, keyword case, and Vietnamese vs English string values ('HoanThanh' vs 'completed') that represent the same status meaning."
  },
  {
    "id": 878,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 50,
    "reason": "Gold query has an additional WHERE condition (t1.ma_trang_thai_bai_giang = 'completed') that filters bai_giang records, while Gen query counts all bai_giang records regardless of status. This creates different semantic logic."
  },
  {
    "id": 879,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both calculate MAX, MIN, and AVG on the same column from the same table, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 880,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both calculate MAX, MIN, and AVG of the same column from the same table. The only differences are whitespace formatting and keyword case, which are cosmetic."
  },
  {
    "id": 881,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting. Both queries select the same columns from the same table with the exact same WHERE condition using the same numeric range."
  },
  {
    "id": 882,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting. Both queries select the same columns from the same table with the exact same WHERE condition using the same numeric range."
  },
  {
    "id": 883,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with the same condition and filter on the same city value."
  },
  {
    "id": 884,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both select the same columns from the same tables with identical JOIN conditions and WHERE clause."
  },
  {
    "id": 885,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with the same conditions and select the same column with identical WHERE clause values."
  },
  {
    "id": 886,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with the same conditions and filter on identical string values."
  },
  {
    "id": 887,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and string literal formatting. Both join the same tables with the same conditions and filter on the same column values."
  },
  {
    "id": 888,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and column references. Both join the same tables with the same conditions and filter on the same values."
  },
  {
    "id": 889,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, whitespace, and keyword case. Both select the city with the highest customer count using the same tables, join conditions, grouping, and ordering."
  },
  {
    "id": 890,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, whitespace, and keyword case. Both select the city with the most customers by joining the same tables with the same conditions and using identical aggregation and ordering."
  },
  {
    "id": 891,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and formatting. Both calculate the sum of payments for a specific customer with first name 'Carole' and last name 'Bernhard'."
  },
  {
    "id": 892,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions: Gen filters for ho='Carole' AND ten='Bernhard', while Gold filters for ten='carole' AND ho='bernhard' (swapped column names). This is a semantic difference that could return different results."
  },
  {
    "id": 893,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count customers who have no payment records, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 894,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count customers who have no payment records, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 895,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, group by the same column (customer ID), and apply the same HAVING condition. The differences are purely cosmetic: table aliases, column order in SELECT, and table order in FROM clause."
  },
  {
    "id": 896,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 50,
    "reason": "Different GROUP BY columns - Gen groups by T1.id_khach_hang (customer ID), Gold groups by t1.id_khach_hang (payment ID). These are different columns from different tables, leading to different result sets."
  },
  {
    "id": 897,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same aggregation and grouping, with only minor cosmetic differences in keyword case and spacing."
  },
  {
    "id": 898,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting. Both select the same column, perform the same aggregation, and group by the same column from the same table."
  },
  {
    "id": 899,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical - both count records where ma_trang_thai_bai_giang equals 'cancelled'/'huỷ bỏ' (English/Vietnamese equivalents). The only differences are cosmetic (keyword case, spacing, quote style)."
  },
  {
    "id": 900,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value: 'Huỷ' (Vietnamese) and 'cancelled' (English) both mean the same status. All other aspects (table, column, aggregation) are identical."
  },
  {
    "id": 901,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and column references. Both join the same tables with identical conditions and WHERE clauses."
  },
  {
    "id": 902,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and column order. Both join the same tables with identical conditions and WHERE clause logic."
  },
  {
    "id": 903,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both count rows from the same join with identical WHERE conditions."
  },
  {
    "id": 904,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count rows from the same tables with the same JOIN condition and WHERE filter, differing only in table aliases and whitespace formatting."
  },
  {
    "id": 905,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same conditions, filter on the same column values, and perform the same aggregation. All differences are cosmetic (aliases, case, whitespace, and quote style)."
  },
  {
    "id": 906,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 30,
    "reason": "Different aggregation functions (COUNT vs SUM) and different WHERE conditions (full name vs split first/last name). These are semantic differences that can produce different results."
  },
  {
    "id": 907,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both compute the average price of lessons for an employee with specific first and last names."
  },
  {
    "id": 908,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries calculate the average price of lessons for an employee named Janessa Sawayn with identical JOIN logic and WHERE conditions, differing only in cosmetic aspects like aliases, case, and whitespace."
  },
  {
    "id": 909,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count rows from the same join between khach_hang and bai_giang with identical join conditions and WHERE clause filtering for the same customer name (case-insensitive and ignoring quote style differences)."
  },
  {
    "id": 910,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count rows from the same join between khach_hang and bai_giang with identical join conditions and WHERE clause filtering for the same customer name (case-insensitive and ignoring quote style differences)."
  },
  {
    "id": 911,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both perform an INTERSECT operation between the 'ho' column from khach_hang and nhan_vien tables. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 912,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both perform an INTERSECT operation between the same column from the same two tables, with only cosmetic differences in keyword case."
  },
  {
    "id": 913,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 65,
    "reason": "The Gen query selects employees not teaching any courses, while the Gold query selects employee names not found among those teaching courses. They differ in column selection (Gen: ten+ho vs Gold: ten only) and exclusion logic (NOT IN vs EXCEPT with JOIN)."
  },
  {
    "id": 914,
    "db_id": "driving_school",
    "strict_match": false,
    "score": 65,
    "reason": "The queries have different semantic logic: Gen uses NOT IN to exclude employees who have any teaching records, while Gold uses EXCEPT to find employees whose names don't appear in the teaching records, which could produce different results if multiple employees share the same name."
  },
  {
    "id": 915,
    "db_id": "driving_school",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case, whitespace, and alias naming conventions."
  },
  {
    "id": 916,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count all rows from the same table 'nhan_vien' with identical COUNT(*) aggregation. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 917,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count all rows from the same table 'nhan_vien' with identical COUNT(*) aggregation. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 918,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ORDER BY logic (ASC is default). The only differences are keyword case and explicit ASC specification, which are cosmetic."
  },
  {
    "id": 919,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ORDER BY logic (ASC is default). The only differences are keyword case and explicit ASC specification, which are cosmetic."
  },
  {
    "id": 920,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are column order in SELECT and whitespace formatting, which are cosmetic differences per the rules."
  },
  {
    "id": 921,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select city and count from the same table with identical grouping, differing only in column order and whitespace formatting."
  },
  {
    "id": 922,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same SELECT, FROM, WHERE, GROUP BY, and HAVING clauses with identical conditions and values."
  },
  {
    "id": 923,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same SELECT, FROM, WHERE, GROUP BY, and HAVING clauses with identical conditions and values. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 924,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (location and count) from the same table with identical grouping, differing only in column order and cosmetic formatting."
  },
  {
    "id": 925,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (location and count) from the same table with the same grouping, differing only in column order and cosmetic formatting."
  },
  {
    "id": 926,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical after normalizing whitespace and keyword case. Both select the same columns from the same table with identical ORDER BY and LIMIT clauses."
  },
  {
    "id": 927,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 928,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same MIN and MAX values from the same table with identical semantics, differing only in column aliases and whitespace formatting."
  },
  {
    "id": 929,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the minimum and maximum values of so_luong_san_pham from cua_hang. The Gen query uses UNION with ORDER BY and LIMIT to get both extremes, while Gold uses MIN and MAX functions, which are semantically equivalent approaches."
  },
  {
    "id": 930,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 931,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same SELECT columns, same FROM table, same ORDER BY clause with same direction. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 932,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select store names where product quantity exceeds the average quantity, with only cosmetic differences in formatting and whitespace."
  },
  {
    "id": 933,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select store names where product quantity exceeds the average quantity, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 934,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with the same condition, group by the same column (id_nhan_vien), and return the employee name with highest evaluation count."
  },
  {
    "id": 935,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries are semantically equivalent - they join the same tables with the same conditions, aggregate by the same functionally dependent column (id_nhan_vien), and return the same result. The only difference is GROUP BY T1.id_nhan_vien vs GROUP BY T2.id_nhan_vien, which are equivalent since they reference the same join key."
  },
  {
    "id": 936,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same conditions, select the same column, and use the same ordering and limiting logic. The only differences are cosmetic (table aliases and keyword case)."
  },
  {
    "id": 937,
    "db_id": "employee_hire_evaluation",
    "strict_match": false,
    "score": 40,
    "reason": "Gen uses GROUP BY with SUM aggregation while Gold uses ORDER BY on individual rows without aggregation. These will return different results when multiple rows exist for the same employee."
  },
  {
    "id": 938,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from nhan_vien where employee IDs are not found in danh_gia, with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 939,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from nhan_vien where id_nhan_vien is not in the danh_gia table, with only minor formatting differences."
  },
  {
    "id": 940,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same column (id_cua_hang), and order by count descending with limit 1. The only differences are cosmetic: table aliases, column aliases, and whitespace formatting."
  },
  {
    "id": 941,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same functionally dependent column, and return the same results with identical ordering and limiting."
  },
  {
    "id": 942,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select store names where store IDs are not in the recruitment table, with only minor whitespace and keyword case differences."
  },
  {
    "id": 943,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select store names where the store ID is not in the recruitment table, with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 944,
    "db_id": "employee_hire_evaluation",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries count employees per store with the same JOIN logic, but Gen includes store ID in GROUP BY and counts specific column while Gold groups only by store name and uses COUNT(*). If store name is unique per ID, they're semantically equivalent with minor differences."
  },
  {
    "id": 945,
    "db_id": "employee_hire_evaluation",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries join the same tables with equivalent conditions and return store names with counts, but Gen groups by store ID while Gold groups by store name. If store name is unique/functionally dependent on store ID, they are semantically equivalent with minor GROUP BY variation."
  },
  {
    "id": 946,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the sum of the same column from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 947,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the sum of the same column from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 948,
    "db_id": "employee_hire_evaluation",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return data from the same table, but Gen explicitly selects specific columns while Gold uses SELECT *. They will return the same rows but with potentially different columns (if the table has additional columns beyond those specified)."
  },
  {
    "id": 949,
    "db_id": "employee_hire_evaluation",
    "strict_match": false,
    "score": 70,
    "reason": "Both queries select from the same table, but Gen explicitly lists specific columns while Gold uses SELECT *. They will return different result sets if the table has additional columns beyond those specified."
  },
  {
    "id": 950,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 951,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they use INTERSECT to find 'quan' values where 'so_luong_san_pham' is both less than 3000 AND greater than 10000 (which is impossible, so both return empty sets). The only difference is the unnecessary GROUP BY in the generated query, which is a cosmetic difference that doesn't affect the result."
  },
  {
    "id": 952,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table, with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 953,
    "db_id": "employee_hire_evaluation",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column, same aggregation function with DISTINCT, and same count operation. The only differences are whitespace formatting and parentheses spacing, which are cosmetic."
  },
  {
    "id": 954,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case (SELECT vs select), string literal delimiters (single vs double quotes), and case in the string value, which SQLite treats as case-insensitive by default for string comparisons."
  },
  {
    "id": 0,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return assets with exactly 2 parts and fewer than 2 error log entries. The Gen query uses a single query with HAVING conditions, while Gold uses INTERSECT of two separate queries, but they are semantically equivalent."
  },
  {
    "id": 1,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are cosmetic (aliases, keyword case, whitespace, and column order in SELECT). Both queries join the same tables with the same condition and perform identical aggregation."
  },
  {
    "id": 2,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column order. Both count assets per third-party company using the same join condition between tai_san and cong_ty_ben_thu_ba tables."
  },
  {
    "id": 3,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both use UNION to combine companies with at least 2 maintenance engineers OR at least 2 maintenance contracts."
  },
  {
    "id": 4,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing column order and table aliases. Both use EXCEPT to find employees in error logs but not in engineer visits."
  },
  {
    "id": 5,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 98,
    "reason": "Queries are semantically equivalent; Gen has correct JOIN syntax with ON clause while Gold has syntax error with missing ON clause, but both would return same results."
  },
  {
    "id": 6,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are cosmetic (aliases, whitespace, column order in SELECT, keyword case). Both query the same tables with same JOIN condition, GROUP BY same column, and same HAVING condition."
  },
  {
    "id": 7,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in table aliases (T1 vs t1) and keyword case (SELECT vs select). Both queries join the same three tables with identical ON conditions and select the same columns."
  },
  {
    "id": 8,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in table alias capitalization and keyword case, which are ignored according to the rules."
  },
  {
    "id": 9,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries join the same tables with identical conditions and return the same columns. The only difference is GROUP BY id_bo_phan vs ten_bo_phan, which are functionally equivalent if ten_bo_phan is unique per department."
  },
  {
    "id": 10,
    "db_id": "assets_maintenance",
    "strict_match": false,
    "score": 30,
    "reason": "Gen query includes an additional JOIN with table 'loi_bo_phan' (T3) and selects column 'mo_ta_loi' from it, while Gold query only joins two tables and selects 'mo_ta_ve_loi' from 'nhat_ky_loi'. These are different table structures and column selections."
  },
  {
    "id": 11,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences: column order in SELECT clause and alias naming conventions. Both queries join the same tables with identical conditions, group by the same column, and order/limit identically."
  },
  {
    "id": 12,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are ignored according to the rules."
  },
  {
    "id": 13,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 14,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with the same NOT IN subquery condition, differing only in whitespace formatting and keyword case."
  },
  {
    "id": 15,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in whitespace and keyword case, which are ignored according to the rules."
  },
  {
    "id": 16,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the earliest purchase date from the tai_san table. MIN() returns a scalar value while ORDER BY + LIMIT returns a row, but they produce the same result semantically."
  },
  {
    "id": 17,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical after normalizing table aliases and column references. They join the same three tables with equivalent conditions, group by the same logical column, and return the same results."
  },
  {
    "id": 18,
    "db_id": "assets_maintenance",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the department with the fewest issues, but Gen uses LEFT JOIN and groups by primary key while Gold uses INNER JOIN and groups by department name. If department name is unique/functionally dependent on id, they are semantically equivalent with minor differences."
  },
  {
    "id": 19,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same tables, JOIN conditions, GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (alias naming, keyword case, and whitespace formatting)."
  },
  {
    "id": 20,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects including tables, joins, columns, and conditions. Only minor formatting differences exist (whitespace and alias usage), which are considered cosmetic."
  },
  {
    "id": 21,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and whitespace. Both queries join the same tables with the same conditions, group by the same column, and order by the same aggregate function."
  },
  {
    "id": 22,
    "db_id": "assets_maintenance",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(DISTINCT id_bo_phan_bi_loi) while Gold uses COUNT(*), which may return different results when there are duplicate id_bo_phan_bi_loi values per skill."
  },
  {
    "id": 23,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection with DISTINCT, and same column name. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 24,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same SELECT columns, same FROM table, same ORDER BY clause with same direction. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 25,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 26,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and column references. Both join the same tables with equivalent conditions and return the same company name based on the earliest contract start date."
  },
  {
    "id": 27,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both select the same column from the same tables with identical JOIN conditions and ORDER BY logic."
  },
  {
    "id": 28,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same grouping, same ordering, same limit. The only differences are cosmetic (keyword case and whitespace around COUNT(*))."
  },
  {
    "id": 29,
    "db_id": "assets_maintenance",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return employee names with counts, but Gen uses COUNT(DISTINCT engineer_id) while Gold uses COUNT(*), and they GROUP BY different columns (id_nhan_vien vs ten_nhan_vien). If employee names are unique, the grouping difference is minor."
  },
  {
    "id": 30,
    "db_id": "assets_maintenance",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same tables, columns, WHERE conditions, and NOT IN subquery logic, with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 31,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'sach'. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 32,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with the same ORDER BY clause."
  },
  {
    "id": 33,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ORDER BY logic. The only differences are cosmetic (table alias and keyword case)."
  },
  {
    "id": 34,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select titles from the same table with the same inequality condition, with only cosmetic differences in keyword case and quote style."
  },
  {
    "id": 35,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both select the same columns from the same table with no filtering or aggregation. The only differences are cosmetic (keyword case, whitespace, and table alias in Gen)."
  },
  {
    "id": 36,
    "db_id": "book_2",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query includes an unnecessary JOIN with the 'sach' table that changes the result set, while Gold query selects directly from 'an_pham' table only. This creates different semantics as the JOIN could filter or duplicate rows."
  },
  {
    "id": 37,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select distinct publisher names from the same table with the same price condition, differing only in table alias usage and keyword case."
  },
  {
    "id": 38,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same ordering, and same limit. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 39,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same ordering and limit, differing only in keyword case (SELECT vs select) which is a cosmetic difference."
  },
  {
    "id": 40,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same condition and select the same columns, with only cosmetic differences in aliases and formatting."
  },
  {
    "id": 41,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same tables, same JOIN condition, same WHERE condition, same SELECT columns. Only differences are table aliases and formatting which are cosmetic."
  },
  {
    "id": 42,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are table aliases (sach vs t1, an_pham vs t2) and keyword case, which are cosmetic variations that don't affect the result set."
  },
  {
    "id": 43,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select publishers with more than one publication using the same table, grouping, and aggregation logic. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 44,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count publications by publisher, with only minor cosmetic differences in table alias usage and whitespace formatting."
  },
  {
    "id": 45,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the publication date with the highest count from the publications table, with only minor formatting differences in whitespace and keyword case."
  },
  {
    "id": 46,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 47,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both use the same tables, columns, and NOT IN logic with identical subqueries. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 48,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both use INTERSECT to find publishers with books priced above 10M and below 5M, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 49,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 50,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting. Both count distinct values of the same column from the same table."
  },
  {
    "id": 51,
    "db_id": "book_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE conditions using OR logic. The only differences are cosmetic (keyword case, single vs double quotes, and case in string literals which SQLite treats as case-insensitive by default)."
  },
  {
    "id": 52,
    "db_id": "company_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table with the same ORDER BY clause. The only differences are cosmetic (keyword case and optional ASC keyword)."
  },
  {
    "id": 53,
    "db_id": "company_1",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries select the same column from the same table with semantically equivalent WHERE conditions. The only difference is that Gen uses Vietnamese values ('vợ', 'chồng') while Gold uses the English equivalent 'spouse', which represent the same relationship type."
  },
  {
    "id": 54,
    "db_id": "company_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical - both count records from the same table with the same gender condition. The only differences are cosmetic (keyword case, spacing) and the gender value uses Vietnamese 'Nữ' vs English 'F', which are equivalent according to the rules."
  },
  {
    "id": 55,
    "db_id": "company_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal formatting. Both join the same tables with the same condition and filter for the same location value."
  },
  {
    "id": 56,
    "db_id": "company_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are column order in SELECT (ho,ten vs ten,ho) and keyword case/whitespace, which are cosmetic differences per the rules."
  },
  {
    "id": 57,
    "db_id": "company_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns (gender and count), filter by the same salary condition, and group by gender. The only differences are cosmetic: column order in SELECT and keyword case."
  },
  {
    "id": 58,
    "db_id": "company_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same table with identical ORDER BY logic. The differences are purely cosmetic (keyword case, whitespace, and formatting)."
  },
  {
    "id": 59,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 60,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 61,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are ignored according to the rules."
  },
  {
    "id": 62,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are ignored according to the rules."
  },
  {
    "id": 63,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting. Both select the same columns from the same table with no filtering or aggregation."
  },
  {
    "id": 64,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with no filtering or aggregation. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 65,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE condition value - 'Khu đô thị Little Lever' and 'little lever urban district' refer to the same location."
  },
  {
    "id": 66,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE condition value - 'Khu đô thị Little Lever' and 'little lever urban distric' refer to the same location (Little Lever Urban District)."
  },
  {
    "id": 67,
    "db_id": "course_teach",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries select the same column from the same table with equivalent OR conditions, but Gen uses string literals ('32', '33') while Gold uses numeric values (32, 33), which could produce different results if the tuoi column has mixed data types."
  },
  {
    "id": 68,
    "db_id": "course_teach",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries select the same column from the same table with the same logical conditions, but Gen uses string literals ('32', '33') while Gold uses numeric literals (32, 33), which could produce different results if the tuoi column has mixed data types."
  },
  {
    "id": 69,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with the same ordering and limit."
  },
  {
    "id": 70,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with the same ordering and limit."
  },
  {
    "id": 71,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column with the same aggregation from the same table with the same grouping. The only differences are cosmetic (whitespace formatting and keyword case)."
  },
  {
    "id": 72,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column with the same aggregation from the same table with the same grouping. The only differences are cosmetic (whitespace, formatting, and keyword case)."
  },
  {
    "id": 73,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 74,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 75,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting. Both queries select the same column from the same table with identical GROUP BY and HAVING conditions."
  },
  {
    "id": 76,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY and HAVING conditions, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 77,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions, only differing in table aliases and join order which are cosmetic differences."
  },
  {
    "id": 78,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions, only differing in table aliases and join order which are cosmetic differences."
  },
  {
    "id": 79,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and select the same columns (teacher name and course name), only differing in table aliases and column references which are cosmetic differences."
  },
  {
    "id": 80,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and select the same columns (teacher name and course name), only differing in table aliases and column references which are cosmetic differences."
  },
  {
    "id": 81,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, JOIN order, and English vs Vietnamese string literal values ('Toán' = 'math' for mathematics)."
  },
  {
    "id": 82,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, JOIN order, and English vs Vietnamese string values ('Toán' = 'math') which have the same meaning."
  },
  {
    "id": 83,
    "db_id": "course_teach",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return teacher names with counts, but Gen groups by teacher ID while Gold groups by teacher name. If name is functionally dependent on ID (unique per teacher), they're semantically equivalent, but this is a minor GROUP BY variation."
  },
  {
    "id": 84,
    "db_id": "course_teach",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return teacher names with counts, but Gen groups by teacher ID while Gold groups by teacher name. If name is functionally dependent on ID (unique per teacher), they're semantically equivalent, making this a minor difference."
  },
  {
    "id": 85,
    "db_id": "course_teach",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return teachers teaching at least 2 courses, but Gen groups by teacher ID while Gold groups by teacher name, which could produce different results if names aren't unique. Gen also includes an extra column (ten) in SELECT that wasn't explicitly requested."
  },
  {
    "id": 86,
    "db_id": "course_teach",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries find teachers assigned to at least 2 courses, but Gen groups by teacher ID while Gold groups by teacher name, which could produce different results if names aren't unique."
  },
  {
    "id": 87,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select teachers not assigned to any courses using the same NOT IN subquery structure, with only minor formatting differences."
  },
  {
    "id": 88,
    "db_id": "course_teach",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select teachers not assigned to any courses using the same NOT IN subquery structure, with only minor cosmetic differences in formatting and keyword case."
  },
  {
    "id": 89,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 90,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column, same ordering. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 91,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 92,
    "db_id": "decoration_competition",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions: 'Hoa Kỳ' (Vietnam) vs 'united states' (USA) are not equivalent values - they refer to different countries, not just language translations."
  },
  {
    "id": 93,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same aggregation and grouping, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 94,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they both select the country with the highest count of members, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 95,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY and HAVING conditions, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 96,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 97,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform the same INNER JOIN between the same two tables with the same join condition, selecting the same columns. The only differences are cosmetic: table aliases, column order in SELECT, and keyword case."
  },
  {
    "id": 98,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, select the same columns (ten and dia_diem_truong_dai_hoc), and use the same ORDER BY clause. The only differences are table aliases and formatting, which are cosmetic."
  },
  {
    "id": 99,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and formatting. Both select the same column from the same tables with identical JOIN conditions and WHERE clause."
  },
  {
    "id": 100,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in table aliases and keyword case. Both perform the same JOIN operation with identical conditions and select the same columns."
  },
  {
    "id": 101,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE clause logic. The only differences are cosmetic: table aliases (t1/t2 vs none) and keyword case."
  },
  {
    "id": 102,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both select the same column from the same tables with the same JOIN condition and ORDER BY clause."
  },
  {
    "id": 103,
    "db_id": "decoration_competition",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both use the same tables, columns, and NOT IN logic with identical subqueries. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 104,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 105,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same ORDER BY clause with same direction. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 106,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with no filtering or aggregation. The only differences are cosmetic (keyword case and whitespace)."
  },
  {
    "id": 107,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the minimum and maximum values from the same column in the same table with no filtering or grouping. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 108,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting. Both select the same columns from the same table with no filtering or aggregation."
  },
  {
    "id": 109,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical - both select names from the same table with the same exclusion condition. The only difference is the language of the string literal ('Đảng Cộng hoà' vs 'republican'), which represent the same real-world political party."
  },
  {
    "id": 110,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE conditions using OR. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case in string values (which SQLite treats as case-insensitive by default)."
  },
  {
    "id": 111,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform an INNER JOIN between the same two tables with the same join condition, selecting the same columns. The only differences are table aliases and column order, which are cosmetic."
  },
  {
    "id": 112,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with the same condition and filter on the same column with the same threshold."
  },
  {
    "id": 113,
    "db_id": "election_representative",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic: Gen uses SUM(cuoc_bau_cu.so_luong_phieu_bau) while Gold uses so_luong_phieu_bau directly without aggregation, which will return different results when multiple rows exist per dai_dien."
  },
  {
    "id": 114,
    "db_id": "election_representative",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic: Gen uses GROUP BY with SUM aggregation, Gold uses simple ORDER BY without aggregation. These will return different results when multiple rows have the same id_dai_dien."
  },
  {
    "id": 115,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, select the same column, and order by the same column in the same direction. The only differences are cosmetic: table aliases, keyword case, and column reference style."
  },
  {
    "id": 116,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical except for the WHERE clause value 'Cộng hoà' vs 'republican', which are English/Vietnamese equivalents with the same meaning (political party). All other aspects (tables, joins, aggregation) are identical."
  },
  {
    "id": 117,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column, same aggregation, same grouping. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 118,
    "db_id": "election_representative",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same 'dang' value with highest count, but Gen omits the COUNT(*) column in SELECT while Gold includes it. This is a minor cosmetic difference in output columns."
  },
  {
    "id": 119,
    "db_id": "election_representative",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same groups with count >= 3, but Gen includes an extra COUNT(*) column in SELECT while Gold only selects the 'dang' column. This is a minor cosmetic difference that doesn't affect the main answer."
  },
  {
    "id": 120,
    "db_id": "election_representative",
    "strict_match": false,
    "score": 20,
    "reason": "Different columns selected and grouped by (ten vs tieu_bang), which are not functionally dependent on each other. This will return different results in most database states."
  },
  {
    "id": 121,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from dai_dien where id_dai_dien is not in the cuoc_bau_cu table, with only cosmetic differences in formatting and case."
  },
  {
    "id": 122,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both perform an INTERSECT operation on the same table with the same column selections and equivalent WHERE conditions (only difference is case sensitivity in string literals, which is a cosmetic difference)."
  },
  {
    "id": 123,
    "db_id": "election_representative",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the 'dang' column from the 'dai_dien' table. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 124,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'quoc_gia'. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 125,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'quoc_gia'. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 126,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same table with no filtering conditions. The only differences are cosmetic: keyword case, whitespace formatting, and column order in SELECT clause."
  },
  {
    "id": 127,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with no filtering or aggregation. The only differences are cosmetic (keyword case and whitespace)."
  },
  {
    "id": 128,
    "db_id": "match_season",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - both select the same column from the same table with LIKE conditions that match the same real-world concept (English language), just expressed in different languages (Vietnamese 'tiếng Anh' vs English 'english')."
  },
  {
    "id": 129,
    "db_id": "match_season",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - both search for countries where the official native language contains either 'tiếng Anh' (Vietnamese) or 'english' (English), which refer to the same language. The only difference is the language used in the LIKE pattern value."
  },
  {
    "id": 130,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 131,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 132,
    "db_id": "match_season",
    "strict_match": false,
    "score": 40,
    "reason": "Different JOIN logic - Gen query joins with cau_thu table while Gold query doesn't, potentially returning different result sets depending on data relationships."
  },
  {
    "id": 133,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The differences are purely cosmetic: keyword case (SELECT vs select), string literal style (single vs double quotes), and case in the string value ('UCLA' vs 'ucla'), which SQLite treats as equivalent in string comparisons by default."
  },
  {
    "id": 134,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select distinct vi_tri from the same table with equivalent WHERE conditions: IN ('UCLA', 'Duke') is semantically identical to = 'ucla' OR = 'duke' (case-insensitive comparison in SQLite)."
  },
  {
    "id": 135,
    "db_id": "match_season",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries select the same column from the same table with equivalent filtering conditions (IN vs OR), and DISTINCT doesn't change the result since vi_tri values would be the same. The only differences are cosmetic: keyword case, string literal quotes, and DISTINCT keyword."
  },
  {
    "id": 136,
    "db_id": "match_season",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical - they select the same columns from the same table with equivalent WHERE conditions where 'hậu vệ' (Vietnamese for defender) and 'defender' (English) represent the same position value."
  },
  {
    "id": 137,
    "db_id": "match_season",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - the only difference is that Gen uses a JOIN with cau_thu table (which appears unnecessary since no columns from cau_thu are selected) and uses Vietnamese 'hậu vệ' while Gold uses English 'defender' for the same position value."
  },
  {
    "id": 138,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting. Both count distinct values of the 'doi' column from the same table."
  },
  {
    "id": 139,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the 'doi' column from the same table. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 140,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with no filtering or aggregation. The only differences are cosmetic (table alias qualification in Gen and keyword case)."
  },
  {
    "id": 141,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with no filtering or aggregation. The only differences are cosmetic (table alias qualification in Gen and keyword case)."
  },
  {
    "id": 142,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both queries select the same column from the same table with no filtering or aggregation."
  },
  {
    "id": 143,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both queries select the same column from the same table with no filtering or aggregation."
  },
  {
    "id": 144,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform the same JOIN between tran_dau_trong_mua_giai and quoc_gia tables with identical join conditions, selecting the same columns with only cosmetic differences in aliases and formatting."
  },
  {
    "id": 145,
    "db_id": "match_season",
    "strict_match": false,
    "score": 40,
    "reason": "The Gen query includes an extra JOIN to the 'cau_thu' table which is not present in the Gold query, fundamentally changing the result set. Gold only joins 'quoc_gia' with 'tran_dau_trong_mua_giai', while Gen adds a third table."
  },
  {
    "id": 146,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions and return the same column. The differences are purely cosmetic: table aliases, JOIN order, and case sensitivity in the WHERE clause value."
  },
  {
    "id": 147,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same results: players who have played in matches for Indonesia. The differences are only cosmetic (aliases, table join order, case sensitivity, and single vs double quotes)."
  },
  {
    "id": 148,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with equivalent conditions, select the same column, and filter on the same value (case-insensitive 'Dublin'). The only differences are cosmetic: table aliases, JOIN order, and formatting."
  },
  {
    "id": 149,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return distinct vi_tri values from the same tables with identical join conditions and WHERE clause filtering for capital city 'Dublin', differing only in table aliases and formatting."
  },
  {
    "id": 150,
    "db_id": "match_season",
    "strict_match": true,
    "score": 98,
    "reason": "Queries are semantically equivalent after normalization: both join the same tables with same conditions, and WHERE clauses are equivalent (IN vs OR with same values). Minor differences include aliases and case sensitivity in string values."
  },
  {
    "id": 151,
    "db_id": "match_season",
    "strict_match": true,
    "score": 98,
    "reason": "Queries are semantically equivalent with minor differences: Gen uses IN clause with uppercase values, Gold uses OR conditions with lowercase values, and both use different table aliases."
  },
  {
    "id": 152,
    "db_id": "match_season",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases and Vietnamese vs English string values ('hậu vệ' = 'defender') which have the same meaning."
  },
  {
    "id": 153,
    "db_id": "match_season",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences (aliases, formatting) and a Vietnamese vs English value difference in the WHERE clause ('hậu vệ' = 'defender')."
  },
  {
    "id": 154,
    "db_id": "match_season",
    "strict_match": false,
    "score": 40,
    "reason": "Different JOIN logic: Generated query joins cau_thu table with tran_dau_trong_mua_giai and doi, while Gold query only joins tran_dau_trong_mua_giai with doi. Generated query includes cau_thu table which Gold does not."
  },
  {
    "id": 155,
    "db_id": "match_season",
    "strict_match": false,
    "score": 20,
    "reason": "Generated query includes an extra JOIN to the 'cau_thu' table which changes the result set, while Gold query only joins 'tran_dau_trong_mua_giai' with 'doi'. This is a fundamental semantic difference in table relationships."
  },
  {
    "id": 156,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and string values. Both query the same tables with the same join condition and WHERE filter for the same team name."
  },
  {
    "id": 157,
    "db_id": "match_season",
    "strict_match": false,
    "score": 50,
    "reason": "Gen query includes an extra JOIN to 'cau_thu' table that Gold query doesn't have, which changes the fundamental logic and could filter out rows. Gold query only joins 'tran_dau_trong_mua_giai' with 'doi'."
  },
  {
    "id": 158,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string values. Both count distinct universities for teams named 'Columbus Crew' with the same join logic."
  },
  {
    "id": 159,
    "db_id": "match_season",
    "strict_match": false,
    "score": 50,
    "reason": "The queries join different tables - Gen includes an extra JOIN to 'cau_thu' table which Gold doesn't have, changing the result set semantics."
  },
  {
    "id": 160,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and string literal differences. Both query the same tables with identical JOIN conditions and WHERE logic."
  },
  {
    "id": 161,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and string literal differences. Both select the same columns from the same tables with identical JOIN conditions and WHERE filters."
  },
  {
    "id": 162,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column, perform the same aggregation on the same table with the same grouping. The only differences are cosmetic (whitespace, keyword case, and parentheses spacing)."
  },
  {
    "id": 163,
    "db_id": "match_season",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries group by vi_tri and count something, but Gen uses COUNT(DISTINCT cau_thu) while Gold uses COUNT(*), which count different things (distinct players vs all rows). However, they would return the same main grouping structure."
  },
  {
    "id": 164,
    "db_id": "match_season",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries count players per country but differ in GROUP BY column (id_quoc_gia vs ten_quoc_gia) and COUNT argument (specific column vs *), though they would return the same results if country names are unique."
  },
  {
    "id": 165,
    "db_id": "match_season",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN logic: Gen includes cau_thu table and joins through it, while Gold joins quoc_gia directly to tran_dau_trong_mua_giai. This changes which rows are counted."
  },
  {
    "id": 166,
    "db_id": "match_season",
    "strict_match": false,
    "score": 40,
    "reason": "The Gen query performs an INNER JOIN which requires matching records in both tables, while the Gold query selects directly from tran_dau_trong_mua_giai without requiring matches in cau_thu. This creates different result sets - Gen returns only cau_thu with matches in both tables, Gold returns all cau_thu from tran_dau_trong_mua_giai."
  },
  {
    "id": 167,
    "db_id": "match_season",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have different JOIN logic and return different columns. Generated query joins two tables and returns two columns, while Gold query selects only one column from a single table."
  },
  {
    "id": 168,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case and whitespace around COUNT(*))."
  },
  {
    "id": 169,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the most frequent vi_tri from the same table using identical GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case, whitespace, and parentheses spacing)."
  },
  {
    "id": 170,
    "db_id": "match_season",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the top 3 universities by player count, but the generated query includes an extra COUNT(*) column in the SELECT clause which wasn't explicitly requested in the gold query."
  },
  {
    "id": 171,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the top 3 universities by count from the same table with identical GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 172,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select universities from the same table, group by university, and filter for those appearing at least twice. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 173,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY and HAVING conditions, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 174,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select universities from the same table, group by university, filter for those with at least 2 records, and order descending. The only differences are cosmetic (keyword case and whitespace)."
  },
  {
    "id": 175,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select universities with at least 2 tournament matches, grouping by university and ordering descending. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 176,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select team names where team IDs are not in the match table, with only minor whitespace and case differences."
  },
  {
    "id": 177,
    "db_id": "match_season",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both use NOT IN with the same subquery structure, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 178,
    "db_id": "match_season",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases and Vietnamese vs English string values ('tiền đạo' = 'forward', 'hậu vệ' = 'defender') in WHERE conditions."
  },
  {
    "id": 179,
    "db_id": "match_season",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries find countries with players in both forward and defender positions, using equivalent INTERSECT logic. The only difference is Vietnamese vs English position names ('tiền đạo'/'hậu vệ' vs 'forward'/'defender'), which are semantically equivalent."
  },
  {
    "id": 180,
    "db_id": "match_season",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical - both use INTERSECT to find universities that have both positions, with only the WHERE clause string values differing between Vietnamese ('tiền vệ', 'hậu vệ') and English ('midfielder', 'defender') equivalents."
  },
  {
    "id": 181,
    "db_id": "match_season",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use fundamentally different logic: Gen uses GROUP BY with conditional aggregation to find universities with both positions, while Gold uses INTERSECT to find universities appearing in both position-specific subsets. They may return different results when universities have multiple players with the same position."
  },
  {
    "id": 182,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 183,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are ignored according to the rules."
  },
  {
    "id": 184,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same ordering. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 185,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both calculate the average of the same column from the same table with no filtering or grouping. The only differences are cosmetic (keyword case, whitespace)."
  },
  {
    "id": 186,
    "db_id": "perpetrator",
    "strict_match": false,
    "score": 20,
    "reason": "The queries have fundamentally different logic: Gen finds hometowns of individuals whose total killings equal the maximum total killings, while Gold finds the location of the single crime with the highest individual killing count."
  },
  {
    "id": 187,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with the same ORDER BY clause."
  },
  {
    "id": 188,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same tables with identical JOIN conditions, differing only in table aliases which are cosmetic differences."
  },
  {
    "id": 189,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases (t1/t2 vs none) and Vietnamese vs English string literal values ('Trung Quốc' vs 'china') which represent the same country."
  },
  {
    "id": 190,
    "db_id": "perpetrator",
    "strict_match": false,
    "score": 0,
    "reason": "The queries reference different columns in the ORDER BY clause: Gen uses 'can_nang' without table prefix, Gold uses 't1.can_nang' (from ca_nhan table). This creates ambiguity and potential semantic difference if 'can_nang' exists in multiple joined tables."
  },
  {
    "id": 1337,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both count distinct nhac_cu values from the same join with equivalent WHERE conditions."
  },
  {
    "id": 1338,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, table order, and case differences. Both join the same tables with the same condition and filter on the same column with the same value."
  },
  {
    "id": 1339,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE clauses, differing only in table aliases, keyword case, and quotation style."
  },
  {
    "id": 1340,
    "db_id": "music_2",
    "strict_match": false,
    "score": 65,
    "reason": "Gen uses COUNT(DISTINCT loai) while Gold uses COUNT(*), which count different things - distinct values of 'loai' column vs all rows. The WHERE condition uses different string literals ('Le Pop' vs 'le pop') but these are likely the same value with different case."
  },
  {
    "id": 1341,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Gen counts DISTINCT types of giong_hat for songs with title 'Le Pop', while Gold counts ALL giong_hat records for songs with title 'le pop' (case difference). Different aggregation logic (COUNT DISTINCT vs COUNT ALL) and case sensitivity in WHERE clause."
  },
  {
    "id": 1342,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables and aggregation logic: Gen counts songs with multiple artists, Gold counts distinct song titles of shared type songs."
  },
  {
    "id": 1343,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different logic: Gen counts songs with multiple distinct artists per song, while Gold counts distinct titles of shared-type songs. They use different tables, conditions, and aggregation logic."
  },
  {
    "id": 1344,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen excludes songs with 'phụ' backing vocals, while Gold excludes songs with 'back' backing vocals (different WHERE conditions). Additionally, Gold uses EXCEPT with JOINs while Gen uses NOT IN with subquery."
  },
  {
    "id": 1345,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen excludes songs with 'phu' type vocals, while Gold excludes songs with 'back' type vocals after selecting all songs with vocals. The string values 'phu' and 'back' are not equivalent in meaning."
  },
  {
    "id": 1346,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical after normalizing aliases, table join order, and case differences. They join the same tables with equivalent conditions, group by the same column, and use the same aggregation and ordering logic."
  },
  {
    "id": 1347,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with equivalent conditions, filter on the same value (case-insensitive), group by the same column, and use the same aggregation and ordering. The differences are purely cosmetic (aliases, formatting, case, and single vs double quotes)."
  },
  {
    "id": 1348,
    "db_id": "music_2",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions: Gen uses 'Hello'/'Der Kapitan' while Gold uses 'heilo'/'der kapitan'. These are not equivalent values (different strings with different meanings), so the queries will return different results for some database states."
  },
  {
    "id": 1349,
    "db_id": "music_2",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN logic: Gen joins ban_nhac first then bai_hat, Gold joins bai_hat first then ban_nhac, but more critically, the WHERE conditions use different string values ('Hello' vs 'heilo') that are not equivalent English/Vietnamese pairs."
  },
  {
    "id": 1350,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Generated query joins only 2 tables and selects different columns, while Gold query joins 3 tables and selects only one column. The table structure and column selection differ significantly."
  },
  {
    "id": 1351,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Generated query joins only 2 tables and selects 2 columns, while Gold query joins 3 tables and selects 1 column. The GROUP BY clauses differ significantly (id vs ten), and Gold includes an additional table (bai_hat) that changes the semantic meaning."
  },
  {
    "id": 1352,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, table join order, and case differences. Both queries join the same tables with equivalent conditions, group by the same column, and apply identical filtering and ordering logic."
  },
  {
    "id": 1353,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, table order in JOIN, and case differences. Both queries join the same tables with equivalent conditions, group by the same column, and apply identical ordering and limiting."
  },
  {
    "id": 1354,
    "db_id": "music_2",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent after normalizing aliases and treating Vietnamese-English value equivalents. The only differences are table aliases and the WHERE clause values 'hậu trường' vs 'back' and 'Der Kapitan' vs 'der kapitan', which are equivalent according to the rules."
  },
  {
    "id": 1355,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: 'backstage' vs 'back' are not equivalent values, and different JOIN logic with mismatched column references in conditions."
  },
  {
    "id": 1356,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen excludes songs with female vocals, while Gold excludes songs with backing vocals. They use different exclusion criteria and different approaches (NOT IN vs EXCEPT with JOIN)."
  },
  {
    "id": 1357,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen excludes songs with 'phu' type vocals, while Gold excludes songs with 'back' type vocals after selecting all songs with vocals. The string values 'phu' and 'back' are not equivalent in meaning."
  },
  {
    "id": 1358,
    "db_id": "music_2",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are structurally identical with same tables, joins, and logic. The only difference is the WHERE clause string value, which appears to be English vs Vietnamese versions of the same album title (both referencing 'a kiss before you go: live in hamburg')."
  },
  {
    "id": 1359,
    "db_id": "music_2",
    "strict_match": true,
    "score": 97,
    "reason": "The queries have identical structure and join logic, with the only difference being the album title string value in the WHERE clause - one uses Vietnamese and the other uses English, which are semantically equivalent translations of the same album title."
  },
  {
    "id": 1360,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with equivalent join conditions and filter on the same column with the same value, returning the same column from the same table despite different aliases and join order."
  },
  {
    "id": 1361,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with equivalent join conditions and filter on the same column with the same value (case-insensitive string match). The only differences are table aliases, column aliases, and formatting."
  },
  {
    "id": 1362,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses 2 tables, Gold uses 3 tables) and different WHERE conditions (different columns and values with no semantic equivalence)."
  },
  {
    "id": 1363,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses 2 tables, Gold uses 3 tables) and different WHERE conditions (different columns and values)."
  },
  {
    "id": 1364,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and alias formatting."
  },
  {
    "id": 1365,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with the same condition, group by the same column, and select the same columns with the same aggregation."
  },
  {
    "id": 1366,
    "db_id": "products_for_hire",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables and columns: Gen uses khach_hang and luot_dat_mua with so_tien_phai_tra, while Gold uses thanh_toan with so_tien_da_tra. These represent fundamentally different data sources and payment amounts."
  },
  {
    "id": 1367,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same tables, JOIN conditions, GROUP BY, ORDER BY, and LIMIT clauses, with only minor cosmetic differences in alias naming and keyword case."
  },
  {
    "id": 1368,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY and HAVING conditions, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 1369,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing table aliases and column references. Both join the same tables with the same condition and filter on the same value."
  },
  {
    "id": 1370,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases are different but join relationships match, and WHERE clause values 'Bộ sưu tập sách' and 'book collection a' appear to be Vietnamese-English equivalents for the same product name."
  },
  {
    "id": 1371,
    "db_id": "products_for_hire",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions use different data types: Gen compares to string 'có' while Gold compares to numeric 1. These are not semantically equivalent as they would match different rows in the database."
  },
  {
    "id": 1372,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table with no filtering conditions."
  },
  {
    "id": 1373,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical except for the WHERE clause value 'tốt' (Vietnamese) vs 'good' (English), which are equivalent according to Rule 5 for status/quality values."
  },
  {
    "id": 1374,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the average of the same column from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1375,
    "db_id": "products_for_hire",
    "strict_match": false,
    "score": 20,
    "reason": "The queries calculate fundamentally different things: Gen computes statistics on order counts per product, while Gold computes statistics on a quantity column directly from the table."
  },
  {
    "id": 1376,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select distinct values of ma_loai_thanh_toan from the thanh_toan table. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 1377,
    "db_id": "products_for_hire",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions use different LIKE patterns ('%Sách%' vs '%book%') which are not semantically equivalent - they search for different text patterns that may not match the same rows."
  },
  {
    "id": 1378,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries count products for rent that have no associated booked products with deposit amount > 200. The Gen query uses NOT EXISTS with a correlated subquery while Gold uses NOT IN - these are semantically equivalent for this exclusion logic."
  },
  {
    "id": 1379,
    "db_id": "products_for_hire",
    "strict_match": false,
    "score": 50,
    "reason": "Gen uses SUM aggregation with OR logic (IN clause), while Gold uses INTERSECT with separate queries for 'good' and 'bad' values. These produce different results: Gen sums all matching values, Gold finds common values between good and bad customers."
  },
  {
    "id": 1380,
    "db_id": "products_for_hire",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions differ semantically: Gen uses 'Giao dịch' while Gold uses 'check' - these are not equivalent values according to the provided language mapping rules. The queries would return different results for rows where ma_loai_thanh_toan contains these different values."
  },
  {
    "id": 1381,
    "db_id": "products_for_hire",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with the only difference being English vs Vietnamese string values for 'cutlery'/'Dao kéo' which represent the same real-world meaning."
  },
  {
    "id": 1382,
    "db_id": "restaurant_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries select from the same table, but Gen includes extra columns (id_nha_hang, dia_chi, danh_gia_xep_hang) that weren't requested in Gold. The main answer (ten_nha_hang) would be correct, but Gen returns additional data."
  },
  {
    "id": 1383,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are cosmetic (keyword case, single vs double quotes, and case in string literal). Both select addresses from the same table with the same restaurant name condition."
  },
  {
    "id": 1384,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case in the string value ('Subway' vs 'subway'), which SQLite treats as equivalent in string comparisons."
  },
  {
    "id": 1385,
    "db_id": "restaurant_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return data from the same table, but Gen selects three columns while Gold selects only one column. This is a minor difference where Gen includes extra columns not explicitly requested in Gold."
  },
  {
    "id": 1386,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are keyword case (SELECT vs select), string literal quotes (single vs double), and case of string value ('Sandwich' vs 'sandwich'), which are cosmetic differences that don't affect results."
  },
  {
    "id": 1387,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 1388,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same columns, same WHERE conditions (just reordered), and same string values (case-insensitive comparison)."
  },
  {
    "id": 1389,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same columns, same WHERE conditions (just reordered), same case-insensitive string values, and same result structure."
  },
  {
    "id": 1390,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are column order in SELECT clause and keyword case, which are cosmetic differences per the rules."
  },
  {
    "id": 1391,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same columns, same WHERE conditions (just reordered), same string values (case-insensitive), and same SELECT clause."
  },
  {
    "id": 1392,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count rows from the same table with the same WHERE condition. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1393,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (co_van and count(*)), group by co_van, order by the count in descending order, and limit to 1 row. The only differences are cosmetic: table prefix in Gen, alias for count, and ORDER BY uses alias vs column reference."
  },
  {
    "id": 1394,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column, perform the same aggregation with COUNT(*), group by the same column, and order by the same count in ascending order with LIMIT 1. The only differences are cosmetic (table alias in SELECT clause and COUNT(*) vs COUNT(chuyen_nganh) in ORDER BY, which are equivalent for non-null columns)."
  },
  {
    "id": 1395,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column, count rows from the same table, group by the same column, and filter with the same HAVING condition. COUNT(*) and COUNT(chuyen_nganh) are equivalent when chuyen_nganh is the grouping column."
  },
  {
    "id": 1396,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns (ho, ten) from the same table with identical WHERE conditions, differing only in column order and keyword case which are cosmetic differences."
  },
  {
    "id": 1397,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent after normalizing column order, condition order, and treating 'nữ' and 'f' as equivalent gender values in Vietnamese/English."
  },
  {
    "id": 1398,
    "db_id": "restaurant_1",
    "strict_match": false,
    "score": 65,
    "reason": "Gen uses COUNT(DISTINCT nha_hang.id_nha_hang) with WHERE clause, while Gold uses COUNT(*) with GROUP BY and HAVING clause. These are semantically different - Gen counts distinct restaurants of type 'Sandwich', while Gold counts all rows per restaurant type and filters for 'Sandwich'."
  },
  {
    "id": 1399,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same tables, same JOIN condition, same WHERE conditions (only difference is case sensitivity in string literals which SQLite treats as equivalent), and same aggregation function."
  },
  {
    "id": 1400,
    "db_id": "restaurant_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen uses 'Linda Smith' in one column while Gold uses 'linda' and 'smith' in separate columns. These are not semantically equivalent as they filter on different column structures."
  },
  {
    "id": 1401,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing case, column aliases, and whitespace. Both have the same tables, JOIN conditions, and WHERE logic with identical string values."
  },
  {
    "id": 1402,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with equivalent conditions, aggregate the same column, group by the same key, and order/limit identically. The only differences are cosmetic (aliases, whitespace, keyword case)."
  },
  {
    "id": 1403,
    "db_id": "restaurant_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both select the same columns from the same tables with identical JOIN conditions, GROUP BY, ORDER BY, and LIMIT clauses."
  },
  {
    "id": 1404,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values in the 'ho' column from the 'dien_vien' table with identical syntax after normalization."
  },
  {
    "id": 1405,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values in the 'ho' column from the 'dien_vien' table, with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 1406,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the most common first name, but Gen includes an extra 'ho' column in SELECT and GROUP BY. This is a minor difference that doesn't change the main answer about which name is most frequent."
  },
  {
    "id": 1407,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the most common name from the dien_vien table using GROUP BY with COUNT(*) ordering and LIMIT 1. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1408,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (ho, ten) from the same table (dien_vien) with identical GROUP BY and ORDER BY logic, only differing in column order which is cosmetic."
  },
  {
    "id": 1409,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (ho, ten) from the same table (dien_vien) with identical GROUP BY and ORDER BY logic. The only differences are column order in SELECT/GROUP BY and whitespace formatting, which are cosmetic."
  },
  {
    "id": 1410,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same GROUP BY and HAVING conditions, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 1411,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same main result (quan values with at least 2 addresses), but Gen includes an extra COUNT(*) column in SELECT that wasn't explicitly requested in Gold. This is a minor cosmetic difference that doesn't change the fundamental answer."
  },
  {
    "id": 1412,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition. The only differences are cosmetic: keyword case, whitespace formatting, and single vs double quotes around the identical string literal."
  },
  {
    "id": 1413,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition. The only differences are cosmetic: keyword case, whitespace formatting, and single vs double quotes around the string literal."
  },
  {
    "id": 1414,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same functionally dependent column (id_thanh_pho), and return the same result set with only cosmetic differences in aliases and column order."
  },
  {
    "id": 1415,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same column (city ID), and return the city with the highest address count. The differences are purely cosmetic: table aliases, column order in SELECT, and column aliases."
  },
  {
    "id": 1416,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both count rows from the same table with the same condition, differing only in keyword case, whitespace formatting, and single vs double quotes around the string literal."
  },
  {
    "id": 1417,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 30,
    "reason": "The queries join different tables and filter on different columns - Gen joins dia_chi with thanh_pho and filters on thanh_pho.thanh_pho, while Gold filters directly on dia_chi.quan without any join. These are semantically different operations that would return different results in most database states."
  },
  {
    "id": 1418,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the same results: films with rental price 0.99 that appear in inventory less than 3 times. The Gen query uses JOIN+GROUP BY+HAVING while Gold uses INTERSECT, but they are semantically equivalent."
  },
  {
    "id": 1419,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use fundamentally different logic: Gen uses JOIN with GROUP BY and HAVING to filter films with rental price 0.99 AND inventory count < 3, while Gold uses INTERSECT to combine films with rental price 0.99 with films having inventory count < 3, which produces different results when films don't meet both conditions simultaneously."
  },
  {
    "id": 1420,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases (t1/t2 vs none), keyword case, and WHERE clause string values 'Úc' (Vietnamese for Australia) vs 'australia' (English) which represent the same country."
  },
  {
    "id": 1421,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases (t1/t2 vs none), keyword case, and English vs Vietnamese country name ('Úc' = 'Australia'). Both count cities joined with countries where country is Australia."
  },
  {
    "id": 1422,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, group by the same column (country ID), and filter for countries with at least 3 cities. The only differences are cosmetic: table aliases, formatting, and column reference style."
  },
  {
    "id": 1423,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same condition, group by the same column, and filter for countries with at least 3 cities. The differences are only cosmetic (aliases, formatting, and COUNT(column) vs COUNT(*))."
  },
  {
    "id": 1424,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different logic: Gen uses AND condition with JOIN, Gold uses UNION of two separate conditions. These produce different results when both conditions are true for the same row."
  },
  {
    "id": 1425,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the same results: payment dates where amount > 10 OR employee name is 'Elsa'. The Gen query uses JOIN+OR logic while Gold uses UNION, which are semantically equivalent for this OR condition."
  },
  {
    "id": 1426,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both count active customers using the same table, column, and condition with only minor formatting differences in quotes and whitespace."
  },
  {
    "id": 1427,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 95,
    "reason": "The queries are semantically equivalent as SQLite treats boolean true and integer 1 as equivalent in WHERE conditions. The only differences are cosmetic (keyword case, whitespace, and boolean vs integer literal representation)."
  },
  {
    "id": 1428,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for minor cosmetic differences in keyword case and whitespace formatting. Both will return exactly the same results on any database state."
  },
  {
    "id": 1429,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same tables, columns, ordering, and limit. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1430,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same primary key (id_phim), and order by the same count to find the film with the most actor appearances. The only differences are cosmetic: table aliases, column order in SELECT, and whitespace formatting."
  },
  {
    "id": 1431,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same primary key (id_phim), and order by the same count to find the film with the most actor appearances. The only differences are cosmetic: table aliases, column order in SELECT, and whitespace."
  },
  {
    "id": 1432,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the actor with most film appearances, but Gen selects only name columns while Gold includes id_dien_vien. This is a minor difference in SELECT columns that doesn't affect the main answer."
  },
  {
    "id": 1433,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with the same condition, group by the same primary key, order by the same count, and select the same columns (just in different order). The only differences are cosmetic: table aliases, column order in SELECT, and whitespace."
  },
  {
    "id": 1434,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, group by the same functionally dependent column (id_dien_vien), and apply the same HAVING condition. The only differences are table aliases (T1/T2 swapped) and column aliases in SELECT, which are cosmetic."
  },
  {
    "id": 1435,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, group by the same primary key column, and apply the same HAVING condition. The differences are purely cosmetic: table aliases, column order in SELECT, and whitespace."
  },
  {
    "id": 1436,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query joins with cua_hang table while Gold only uses hang_ton_kho, potentially returning different results when cua_hang has unmatched rows. The GROUP BY and ORDER BY logic is similar but the table sets differ."
  },
  {
    "id": 1437,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different tables: Gen joins cua_hang and hang_ton_kho, while Gold only uses hang_ton_kho. This creates different semantic logic that could return different results depending on the data relationships."
  },
  {
    "id": 1438,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both calculate the sum of the same column from the same table with no filtering conditions. The only differences are cosmetic (keyword case, whitespace, parentheses spacing)."
  },
  {
    "id": 1439,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the sum of the same column from the same table with no filtering conditions. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 1440,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same condition, group by the same column, order by the same aggregate, and select the same columns (only column order differs, which is cosmetic)."
  },
  {
    "id": 1441,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, column order, and whitespace. Both select the same columns from the same tables with identical JOIN conditions, GROUP BY, ORDER BY, and LIMIT logic."
  },
  {
    "id": 1442,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause filtering for the same movie title, differing only in table aliases and formatting."
  },
  {
    "id": 1443,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, table order, and case. Both join the same three tables with equivalent conditions and select the same column."
  },
  {
    "id": 1444,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same column, and select the same columns with identical aggregation. The differences are purely cosmetic (aliases, table order in JOIN, whitespace, and keyword case)."
  },
  {
    "id": 1445,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same top 10 categories by film count, but Gen includes an extra column (danh_muc.ten) in GROUP BY and SELECT, while Gold groups only by id_danh_muc. Since ten is functionally dependent on id_danh_muc, they are semantically equivalent with minor cosmetic differences."
  },
  {
    "id": 1446,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, column order, and aggregation expressions. Both select the same columns from the same tables with identical JOIN conditions, GROUP BY logic, and ORDER BY/LIMIT clauses."
  },
  {
    "id": 1447,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both select the same columns from the same tables with identical JOIN conditions, GROUP BY, ORDER BY, and LIMIT clauses."
  },
  {
    "id": 1448,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different GROUP BY columns (T3.id_phim vs t2.id_hang_ton_kho) leads to different aggregation logic and potentially different results."
  },
  {
    "id": 1449,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the most frequently rented film title and inventory ID, but Gen includes an extra grouping column (T3.id_phim) which is functionally dependent on T2.id_hang_ton_kho, making the results semantically equivalent. This is a minor cosmetic difference."
  },
  {
    "id": 1450,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct id_ngon_ngu values from the phim table, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 1451,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different columns being counted - Gen counts distinct language names from joined table, Gold counts distinct language IDs from main table. These could return different results if language names are not unique."
  },
  {
    "id": 1452,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are cosmetic (table alias, keyword case, and single vs double quotes for string literal). Both select movie titles where rating equals 'R'."
  },
  {
    "id": 1453,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are cosmetic (table alias, keyword case, and single vs double quotes). Both select movie titles where rating equals 'R'."
  },
  {
    "id": 1454,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries join the same tables with the same condition and filter for the same store, but Gen selects multiple address columns while Gold selects only the main address column."
  },
  {
    "id": 1455,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 70,
    "reason": "Gen query selects 5 columns while Gold selects only 1 column (dia_chi). Both queries join the same tables with the same condition and filter on the same WHERE clause, but the different column selection means they return different result sets."
  },
  {
    "id": 1456,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are column order in SELECT (which doesn't matter without ORDER BY referencing columns), alias naming (T1 vs t1), and whitespace formatting."
  },
  {
    "id": 1457,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are column order in SELECT (which doesn't matter without ORDER BY referencing columns), alias naming (T1 vs t1), and whitespace/case formatting."
  },
  {
    "id": 1458,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with identical conditions and select the same column."
  },
  {
    "id": 1459,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with the same condition and filter on the same column with the same string value."
  },
  {
    "id": 1460,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'cua_hang'. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1461,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'cua_hang'. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1462,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table with no filtering conditions. The only differences are cosmetic (keyword case, whitespace, parentheses spacing)."
  },
  {
    "id": 1463,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table with no filtering conditions. The only differences are cosmetic (keyword case, whitespace, and parentheses spacing)."
  },
  {
    "id": 1464,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries select movie titles where special features contain specific text; the only difference is English vs Vietnamese string values with the same semantic meaning ('deleted scenes' = 'Cảnh đã xoá')."
  },
  {
    "id": 1465,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries select movie titles where special features contain specific text; the only difference is English vs Vietnamese string values with the same semantic meaning ('deleted scenes' = 'Cảnh đã xoá')."
  },
  {
    "id": 1466,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting. Both count rows from the same table with the same WHERE condition."
  },
  {
    "id": 1467,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same count from the same table with the same WHERE condition. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 1468,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for keyword case (SELECT vs select), which is a cosmetic difference that does not affect semantics. Both queries will return exactly the same result on any possible database state."
  },
  {
    "id": 1469,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select), which are ignored according to the rules. Both queries will return exactly the same results on any possible database state."
  },
  {
    "id": 1470,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with equivalent conditions and select the same columns."
  },
  {
    "id": 1471,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with equivalent conditions and select the same columns."
  },
  {
    "id": 1472,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have fundamentally different logic: Gen uses AND/OR conditions in WHERE clause while Gold uses OR with EXCEPT for exclusion, which produces different result sets when both conditions are true."
  },
  {
    "id": 1473,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have fundamentally different logic: Gen uses AND/OR conditions in WHERE clause while Gold uses OR with EXCEPT, which produces different result sets when multiple conditions apply."
  },
  {
    "id": 1474,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both select the same columns from the same tables with identical JOIN conditions and ORDER BY logic."
  },
  {
    "id": 1475,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are table aliases (t1/t2 vs direct table names) and column order in SELECT clause, both of which are cosmetic differences that don't affect results."
  },
  {
    "id": 1476,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing cosmetic differences: same tables, joins, and WHERE conditions with equivalent string values (case-insensitive comparison). The DISTINCT in Gold doesn't affect results since the JOIN conditions and WHERE filters ensure uniqueness."
  },
  {
    "id": 1477,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 99,
    "reason": "Queries are semantically identical - the only differences are cosmetic: DISTINCT keyword in Gold (redundant since joins with unique IDs), case differences in column names and string values, and single vs double quotes. All structural elements match exactly."
  },
  {
    "id": 1478,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same id_cua_hang value (the one with most customers), but Gen includes an unnecessary JOIN to cua_hang table while Gold directly groups by id_cua_hang from khach_hang. The JOIN doesn't change the result since it's on the same id_cua_hang column."
  },
  {
    "id": 1479,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the store ID with the highest customer count, with only minor cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 1480,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column, same ordering, same limit. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 1481,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same ordering, and same limit. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 1482,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 65,
    "reason": "Gen query selects 5 columns and has additional WHERE condition (co_hoat_dong_khong = TRUE) that Gold query lacks. Gold query only selects 1 column (dia_chi) and uses different case for string value ('elsa' vs 'Elsa')."
  },
  {
    "id": 1483,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries join the same tables with the same condition and filter on the same employee name, but Gen selects 5 address-related columns while Gold selects only 1 column (dia_chi). The column selection difference is a semantic variation."
  },
  {
    "id": 1484,
    "db_id": "sakila_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and quote style for the date literal."
  },
  {
    "id": 1485,
    "db_id": "sakila_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries exclude customers with rentals after the specified date, but Gen selects both first and last names while Gold selects only first name. This is a minor difference in output columns."
  },
  {
    "id": 1486,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with the same aggregation function, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 1487,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 1488,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count records grouped by the 'dang' column from the 'tai_xe' table. The only differences are cosmetic (table alias usage and keyword case)."
  },
  {
    "id": 1489,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with the same ORDER BY clause."
  },
  {
    "id": 1490,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select distinct values from the same column in the same table with no filtering conditions. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 1491,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same grouping column, same ordering by count descending, same limit. The only differences are cosmetic (keyword case and whitespace)."
  },
  {
    "id": 1492,
    "db_id": "school_bus",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different logical operators (OR vs AND), which will produce different result sets. The OR condition returns drivers from Hartford OR over 40, while AND requires both conditions."
  },
  {
    "id": 1493,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical WHERE, GROUP BY, and HAVING conditions, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 1494,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return the same set of hometown cities for drivers who are not over 40 years old. The Gen query uses NOT IN while Gold uses EXCEPT, which are semantically equivalent for set exclusion, and EXCEPT is the preferred SQL pattern."
  },
  {
    "id": 1495,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both use NOT IN with the same subquery structure, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 1496,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY and HAVING conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1497,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions, only differing in table aliases and column aliases which are cosmetic differences."
  },
  {
    "id": 1498,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same three aggregate functions (AVG, MAX, MIN) on the same column from the same table, with only cosmetic differences in column order and whitespace formatting."
  },
  {
    "id": 1499,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in table alias usage and whitespace formatting. Both queries select the same columns from the same table with the same NOT IN subquery condition."
  },
  {
    "id": 1500,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same two tables with identical join conditions and group by the same column, returning the same count of bus routes per school type. The only differences are table aliases and formatting, which are cosmetic."
  },
  {
    "id": 1501,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences in keyword case, whitespace, and single vs double quotes around string literal."
  },
  {
    "id": 1502,
    "db_id": "school_bus",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with identical WHERE conditions (same city name and age filter), with only minor cosmetic differences in keyword case and quotation marks."
  },
  {
    "id": 1503,
    "db_id": "school_bus",
    "strict_match": false,
    "score": 65,
    "reason": "The Gen query uses GROUP BY with SUM aggregation, while Gold query uses ORDER BY without aggregation. These will return different results when a driver has multiple buses with different work years."
  },
  {
    "id": 1504,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1505,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1506,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same ORDER BY clause. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 1507,
    "db_id": "school_player",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return schools ordered by enrollment count, but Gen includes an extra column (so_luong_nhap_hoc) in SELECT that wasn't explicitly requested in Gold. This is a minor cosmetic difference that doesn't change the main answer."
  },
  {
    "id": 1508,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1509,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1510,
    "db_id": "school_player",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - both select the same column from the same table with the same inequality condition. The only difference is the string literal value ('Công giáo' vs 'catholic'), which are equivalent terms for the same religion in Vietnamese and English."
  },
  {
    "id": 1511,
    "db_id": "school_player",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent: both filter schools where religion is not Catholic/Christian, and SUM vs SELECT returns the same single value. The only differences are English vs Vietnamese string values and aggregation function."
  },
  {
    "id": 1512,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the average of the same column from the same table with no filtering or grouping. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 1513,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the average of the same column from the same table with no filtering or grouping. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1514,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the 'doi' column from the 'cau_thu' table and order by 'doi' in ascending order. The only differences are cosmetic (table alias usage and keyword case)."
  },
  {
    "id": 1515,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ordering, differing only in cosmetic aspects like keyword case and table alias usage."
  },
  {
    "id": 1516,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1517,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count distinct positions from the same table with identical logic, differing only in cosmetic formatting and table alias usage."
  },
  {
    "id": 1518,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ordering and limit conditions, with only minor cosmetic differences in keyword case and table alias usage."
  },
  {
    "id": 1519,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with identical ordering and limit."
  },
  {
    "id": 1520,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are ignored per the rules."
  },
  {
    "id": 1521,
    "db_id": "school_player",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the top 5 teams by player age, but Gen includes an extra 'cau_thu' column in SELECT that wasn't requested in Gold. This is a minor cosmetic difference that doesn't affect the main answer."
  },
  {
    "id": 1522,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform identical JOIN operations between the same tables with the same conditions, selecting the same columns. The only differences are cosmetic: table aliases (cau_thu/truong_hoc vs t1/t2) and keyword case."
  },
  {
    "id": 1523,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same condition and select the same columns, with only cosmetic differences in aliases and formatting."
  },
  {
    "id": 1524,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same logical column (school ID), and apply identical HAVING filters. The differences are purely cosmetic: table aliases, column references using aliases vs table names, and formatting."
  },
  {
    "id": 1525,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same results: locations of schools with more than one player. They use the same tables, join conditions, grouping, and filtering logic, with only cosmetic differences in aliases and formatting."
  },
  {
    "id": 1526,
    "db_id": "school_player",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the religion of schools with the most players, but Gen groups by school ID while Gold groups by player's school ID reference, which are functionally equivalent. The main difference is Gen includes extra COUNT column in SELECT while Gold doesn't, making them not strictly identical."
  },
  {
    "id": 1527,
    "db_id": "school_player",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the religion of the school with the most players, but Gen includes 'truong_hoc.ton_giao' in GROUP BY while Gold groups by 't1.id_truong' - functionally equivalent if id_truong is unique, but Gen's GROUP BY is technically incorrect for SQLite."
  },
  {
    "id": 191,
    "db_id": "perpetrator",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation functions: COUNT(*) counts all matching rows, while SUM(t2.so_nguoi_bi_giet) sums a specific column's values, which could differ even on the same filtered data."
  },
  {
    "id": 192,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and Vietnamese vs English country names in the WHERE condition ('Trung Quốc' = 'China', 'Nhật Bản' = 'Japan')."
  },
  {
    "id": 193,
    "db_id": "perpetrator",
    "strict_match": false,
    "score": 65,
    "reason": "The Gen query uses GROUP BY with SUM aggregation in ORDER BY, while Gold query has no GROUP BY and orders by raw column values. These will return different result sets when multiple rows have the same id_ca_nhan."
  },
  {
    "id": 194,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count records per quoc_gia from the toi_pham table, with only cosmetic differences in table alias usage and keyword case."
  },
  {
    "id": 195,
    "db_id": "perpetrator",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the country with the highest crime count, but Gen includes only the country column while Gold includes both country and count columns. This is a minor difference in SELECT columns that doesn't affect the main answer."
  },
  {
    "id": 196,
    "db_id": "perpetrator",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return countries with at least 2 criminals, but Gen includes only the country column while Gold includes both country and count columns. This is a minor difference in SELECT clause composition."
  },
  {
    "id": 197,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences in table aliases and keyword case. Both join the same tables with the same conditions and order by the same column."
  },
  {
    "id": 198,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from ca_nhan where id_ca_nhan is not in the toi_pham table, with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 199,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they return countries where number of injured is both >50 AND <20, which is logically impossible (empty set). The only difference is redundant GROUP BY in Gen query, which doesn't affect INTERSECT result."
  },
  {
    "id": 200,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 201,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same condition, select the same column, and order by the same column with the same limit. The only differences are cosmetic (aliases and keyword case)."
  },
  {
    "id": 202,
    "db_id": "perpetrator",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the maximum value of the 'nam' column from the 'toi_pham' table. ORDER BY DESC LIMIT 1 and MAX() are semantically equivalent approaches for finding the maximum value."
  },
  {
    "id": 203,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same table with no filtering conditions. The only differences are cosmetic: keyword case (SELECT vs select) and table alias usage in the generated query."
  },
  {
    "id": 204,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with the same ORDER BY clause. The only differences are cosmetic (keyword case, whitespace, and explicit ASC keyword)."
  },
  {
    "id": 205,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are column order in SELECT (which doesn't matter without ORDER BY on those columns), keyword case, and single vs double quotes for string literal."
  },
  {
    "id": 206,
    "db_id": "station_weather",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions use different LIKE patterns ('%Tốc hành%' vs '%express%') which are not semantically equivalent string values, even considering Vietnamese-English equivalence rules. These patterns would match different subsets of rows in the tau_hoa table."
  },
  {
    "id": 207,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences in keyword case and string literal quotation marks."
  },
  {
    "id": 208,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same columns from the same table with the same aggregation and grouping, with only minor cosmetic differences in formatting and table prefix usage."
  },
  {
    "id": 209,
    "db_id": "station_weather",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the ship name with the most routes, but Gen groups by tau_hoa.id while Gold groups by t2.id_tau (which is the same column value). This is a minor GROUP BY variation on functionally dependent columns."
  },
  {
    "id": 210,
    "db_id": "station_weather",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same stations with their network names and services, but Gen uses COUNT(DISTINCT lo_trinh.id_tau) while Gold uses COUNT(*), which counts all rows not distinct train IDs. Also, GROUP BY columns differ (nha_ga.id vs t2.id_nha_ga), but these are likely equivalent foreign key relationships."
  },
  {
    "id": 211,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (ngay_trong_tuan and average of nhiet_do_cao) from the same table with identical GROUP BY logic, differing only in column order and whitespace formatting."
  },
  {
    "id": 212,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal differences. Both compute the same aggregates from the same tables with the same join condition and WHERE filter."
  },
  {
    "id": 213,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause filtering for the same value. The only differences are table aliases, column references using aliases vs table names, and string literal formatting (single vs double quotes, case difference in 'Chiltern' vs 'chiltern'), which are all cosmetic."
  },
  {
    "id": 214,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the 'dich_vu' column from the 'nha_ga' table, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 215,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same column (nha_ga.id = t1.id_nha_ga), order by the same aggregate function, and return the same columns despite different aliases and formatting."
  },
  {
    "id": 216,
    "db_id": "station_weather",
    "strict_match": false,
    "score": 65,
    "reason": "The Gen query uses WHERE with luong_mua > 50 directly, while Gold uses GROUP BY with HAVING max(luong_mua) > 50, which are semantically different - Gold finds stations where ANY weekly rainfall exceeds 50, Gen finds stations where EACH weekly rainfall exceeds 50."
  },
  {
    "id": 217,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the minimum of nhiet_do_thap and maximum of toc_do_gio_mph from the same table with identical aggregation logic. The only differences are cosmetic: column aliases, whitespace formatting, and keyword case."
  },
  {
    "id": 218,
    "db_id": "station_weather",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select departure points from trains grouped by departure point with count greater than 1, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 219,
    "db_id": "wedding",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count rows from the same table with the same WHERE condition, with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 220,
    "db_id": "wedding",
    "strict_match": false,
    "score": 40,
    "reason": "The generated query performs a JOIN with the ca_nhan table and selects ca_nhan.ten, while the gold query only selects from nha_tho and includes duoc_to_chuc_boi instead of ca_nhan.ten. These are semantic differences that will produce different result sets."
  },
  {
    "id": 221,
    "db_id": "wedding",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same ordering. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 222,
    "db_id": "wedding",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select dates from the same table, group by those dates, and filter for groups with at least 2 occurrences. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 223,
    "db_id": "wedding",
    "strict_match": false,
    "score": 40,
    "reason": "The queries join different tables - Gen joins nha_tho with ca_nhan while Gold only selects from nha_tho. This creates different result structures and potential data differences."
  },
  {
    "id": 224,
    "db_id": "wedding",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns, same aggregation, same grouping. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 225,
    "db_id": "wedding",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns, same ordering, same limit. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 226,
    "db_id": "wedding",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the gender value ('nữ' vs 'f' both meaning female), which is treated as equivalent according to the rules."
  },
  {
    "id": 227,
    "db_id": "wedding",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different logic: Gen finds countries where age > 30 AND age < 25 (impossible condition), while Gold finds countries where age < 25 OR age > 30 (valid condition). They will return different results on any database."
  },
  {
    "id": 228,
    "db_id": "wedding",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both calculate MIN, MAX, and AVG of the same column from the same table. Differences are purely cosmetic (whitespace, keyword case, parentheses spacing)."
  },
  {
    "id": 229,
    "db_id": "wedding",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with the same subquery condition, differing only in whitespace formatting and keyword case."
  },
  {
    "id": 230,
    "db_id": "wedding",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen filters on nha_tho.ngay_mo_cua > 2014 while Gold filters on le_cuoi.nam > 2014. These are different columns from different tables with potentially different meanings."
  },
  {
    "id": 231,
    "db_id": "wedding",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions (gender filter mismatch: 'nam' vs 't') and different subquery logic (Gen uses complex nested subqueries with CAST while Gold uses simple direct subquery)."
  },
  {
    "id": 232,
    "db_id": "wedding",
    "strict_match": false,
    "score": 65,
    "reason": "The queries use different filtering logic: Gen excludes nhà thờ with weddings on ngay_mo_cua = 2015, while Gold excludes nhà thờ with weddings in nam = 2015. These are different date conditions that may not be equivalent."
  },
  {
    "id": 233,
    "db_id": "wedding",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case, whitespace, and alias naming conventions."
  },
  {
    "id": 234,
    "db_id": "wedding",
    "strict_match": false,
    "score": 20,
    "reason": "Different table joins and WHERE conditions: Gen joins nha_tho table with condition on ngay_mo_cua=2016, while Gold filters on le_cuoi.nam=2016 without joining nha_tho. Also different gender values: 'nu' vs 'f' (though equivalent per rules)."
  },
  {
    "id": 235,
    "db_id": "wedding",
    "strict_match": false,
    "score": 40,
    "reason": "The queries use different tables and different filtering logic - Gen joins with nha_tho table and filters by date range, while Gold filters le_cuoi directly by year column without any join."
  },
  {
    "id": 236,
    "db_id": "wedding",
    "strict_match": false,
    "score": 60,
    "reason": "Different WHERE logic: Gen uses AND (both spouses >30), Gold uses OR (either spouse >30). Different JOIN order but same tables and conditions."
  },
  {
    "id": 237,
    "db_id": "wedding",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count records by quoc_gia from the ca_nhan table, with only cosmetic differences in formatting and table alias usage."
  },
  {
    "id": 238,
    "db_id": "wedding",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables involved (Gen uses JOIN with nha_tho, Gold doesn't) and different counting logic (Gen counts all rows, Gold counts distinct id_nha_tho). The WHERE conditions also use different columns (ngay_mo_cua vs nam)."
  },
  {
    "id": 239,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 240,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 241,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same set of distinct ngach values, but Gen omits DISTINCT which could return duplicates. However, since ngach likely has functional dependencies, they're semantically equivalent in most practical cases."
  },
  {
    "id": 242,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same set of distinct ngach values, but Gen omits DISTINCT which could return duplicates. However, since ngach values are likely functionally dependent, they are semantically equivalent for most practical purposes."
  },
  {
    "id": 243,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 244,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for keyword case (SELECT vs select), which is a cosmetic difference that does not affect the semantic meaning."
  },
  {
    "id": 245,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same table with no filtering or ordering. The only differences are column order in SELECT and keyword case, which are cosmetic differences that don't affect the result set."
  },
  {
    "id": 246,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (ho, ten, ngach) from the same table (giang_vien) with no filtering or ordering. The only differences are column order in SELECT and keyword case, which are cosmetic differences that don't affect the result set."
  },
  {
    "id": 247,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: column order in SELECT and English vs Vietnamese equivalent values for gender ('nữ' = 'F' = 'Female')."
  },
  {
    "id": 248,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: column order in SELECT and English vs Vietnamese equivalent values for gender ('nữ' = 'F'). Both query the same table with the same filtering logic."
  },
  {
    "id": 249,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value: 'nam' (Vietnamese) and 'M' (English abbreviation) both represent the same gender value 'Male'."
  },
  {
    "id": 250,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value: 'nam' (Vietnamese) and 'M' (English abbreviation) both represent the same gender value 'Male'."
  },
  {
    "id": 251,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only language differences in WHERE clause values: 'nữ' = 'F' for gender and 'Giáo sư' = 'professor' for academic rank."
  },
  {
    "id": 252,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries count female professors from the same table with equivalent conditions - only difference is English vs Vietnamese string values for 'professor' and 'female' which have the same semantic meaning."
  },
  {
    "id": 253,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same tables, columns, and WHERE conditions (only difference is column order in SELECT and case/quote style in WHERE values, which are cosmetic)."
  },
  {
    "id": 254,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same tables, columns, and WHERE conditions with only cosmetic differences in column order, keyword case, whitespace, and single vs double quotes."
  },
  {
    "id": 255,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "Gold query has an additional WHERE condition (ngach = 'professor') that filters results, while Gen query counts all giang_vien in building 'NEB' regardless of ngach value. This creates different result sets on any database state."
  },
  {
    "id": 256,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 30,
    "reason": "Gold query has an additional WHERE condition (ngach = 'professor') that filters results, while Gen query counts all giang_vien in building 'NEB' regardless of ngach value. This creates different result sets."
  },
  {
    "id": 257,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "Gold query has a WHERE clause filtering for ngach = 'instructor' while Gen query has no filtering condition, so they will return different results on any database where not all giang_vien have ngach = 'instructor'."
  },
  {
    "id": 258,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "Gold query has an additional WHERE clause filtering by ngach = 'instructor', while Gen query returns all rows from giang_vien without any filtering. This is a semantic difference in row selection."
  },
  {
    "id": 259,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns, use the same aggregation, and group by the same column. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 260,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns, same aggregation, same grouping. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 261,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column, group by the same column, order by the same aggregate count in descending order, and limit to the same single row. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 262,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 263,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 50,
    "reason": "The Gold query filters for professors only (WHERE ngach = 'professor'), while the Generated query includes all giang_vien regardless of ngach value. This creates different WHERE conditions that will produce different result sets."
  },
  {
    "id": 264,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 50,
    "reason": "The Gold query filters for professors only (WHERE ngach = 'professor'), while the Generated query includes all giang_vien regardless of ngach value. This creates different WHERE conditions that will produce different result sets."
  },
  {
    "id": 265,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column, perform the same aggregation, and group by the same column. The only differences are cosmetic (whitespace, formatting, and keyword case)."
  },
  {
    "id": 266,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column with the same aggregation from the same table with the same grouping. The only differences are cosmetic (whitespace formatting and keyword case)."
  },
  {
    "id": 267,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different aggregation logic: Gen produces one row per ngach with separate counts for male/female, while Gold produces separate rows for each ngach/gioi_tinh combination with total counts."
  },
  {
    "id": 268,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns, perform the same aggregation with COUNT(*), and group by the same columns. The only differences are cosmetic (aliases, whitespace, and keyword case)."
  },
  {
    "id": 269,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the ngach with the smallest count from giang_vien table, with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 270,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the ngach with the smallest count from giang_vien table, with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 271,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions: 'Trợ lý giáo sư' (Assistant Professor in Vietnamese) vs 'asstprof' (abbreviation) are not equivalent string values according to the provided rules. These represent different academic rank values."
  },
  {
    "id": 272,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions: 'Trợ lý giáo sư' (Assistant Professor in Vietnamese) vs 'asstprof' (abbreviation) are not equivalent string values according to the rules. The queries filter on different ngach values."
  },
  {
    "id": 273,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions and select the same columns, differing only in aliases, formatting, and case."
  },
  {
    "id": 274,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 30,
    "reason": "The queries use different tables and different logic. Gen queries only the sinh_vien table with a subquery, while Gold joins giang_vien and sinh_vien tables to find matching records."
  },
  {
    "id": 275,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query selects directly from sinh_vien table with a WHERE condition, while Gold query uses a JOIN between giang_vien and sinh_vien tables with different filtering logic. These queries access different tables and have fundamentally different semantics."
  },
  {
    "id": 276,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases, JOIN order, and English vs Vietnamese string values ('Giáo sư' = 'professor'). Both return the same student IDs for students whose advisor is a professor."
  },
  {
    "id": 277,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases, column order in SELECT, and case differences in string literals ('Micheal' vs 'michael', 'Goodrich' vs 'goodrich'). Both queries join the same tables with the same conditions and filter on the same values."
  },
  {
    "id": 278,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only minor differences: table aliases, column order in SELECT, case sensitivity, and English name spelling variations ('Micheal' vs 'michael') which are treated as equivalent."
  },
  {
    "id": 279,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different table joins and join conditions - Gen uses multiple LEFT JOINs through intermediate tables while Gold uses a single JOIN directly between giang_vien and sinh_vien with different join logic."
  },
  {
    "id": 280,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with equivalent conditions and perform the same aggregation."
  },
  {
    "id": 281,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same conditions, group by the same column, and perform the same aggregation. The only differences are cosmetic (table aliases and formatting)."
  },
  {
    "id": 282,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count students grouped by teacher's rank, with identical JOIN logic and grouping. Differences are only cosmetic: table aliases, column order in SELECT, and whitespace."
  },
  {
    "id": 283,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same conditions, group by the same primary key, and order by the same count. The differences are only cosmetic (aliases, column order in SELECT, and whitespace)."
  },
  {
    "id": 284,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same conditions, group by the same column, and order by the same count. The only differences are cosmetic (aliases, whitespace, and column order in SELECT)."
  },
  {
    "id": 285,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both query the same tables with the same JOIN condition, GROUP BY, and HAVING clause."
  },
  {
    "id": 286,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both select giang_vien.id_giang_vien from the same tables with identical JOIN conditions, GROUP BY, and HAVING clause."
  },
  {
    "id": 287,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return giang_vien IDs that are not present as co_van in sinh_vien. Using EXCEPT (Gold) is semantically equivalent to NOT IN (Gen) and is actually the preferred SQL pattern for set exclusion."
  },
  {
    "id": 288,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return giang_vien IDs that are not present as co_van in sinh_vien. Using EXCEPT is semantically equivalent to NOT IN for set exclusion and is actually preferred SQL practice."
  },
  {
    "id": 289,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with no filtering or aggregation."
  },
  {
    "id": 290,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return data from the same table, but Gen includes an extra column (id_hoat_dong) in the SELECT clause that Gold does not request. This is a minor difference that doesn't change the main answer about activity names."
  },
  {
    "id": 291,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table 'hoat_dong' with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 292,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'hoat_dong' with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 293,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct id_giang_vien values from the same table with no filtering conditions. The only differences are cosmetic (keyword case, whitespace, parentheses spacing)."
  },
  {
    "id": 294,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count distinct id_giang_vien from giang_vien_tham_gia_vao. The JOIN in the generated query is redundant since it doesn't add any filtering or change the result set."
  },
  {
    "id": 295,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return the same set of giang_vien IDs that are not present in giang_vien_tham_gia_vao. The Gen query uses NOT IN while Gold uses EXCEPT, which are semantically equivalent for set exclusion, and EXCEPT is the preferred SQL pattern."
  },
  {
    "id": 296,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return the same set of giang_vien IDs that are not present in giang_vien_tham_gia_vao. The Gen query uses NOT IN while Gold uses EXCEPT, which are semantically equivalent for set exclusion, and EXCEPT is the preferred SQL pattern."
  },
  {
    "id": 297,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both perform an INTERSECT operation between the same two tables with the same column selections, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 298,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different logic: Gen uses JOIN + IN subquery to find giang_vien who are also co_van, while Gold uses INTERSECT between two separate queries. These approaches are not semantically equivalent on all possible database states."
  },
  {
    "id": 299,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved (sinh_vien vs giang_vien) and different join conditions (id_sinh_vien vs id_giang_vien). These are fundamental semantic differences that will produce different results."
  },
  {
    "id": 300,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved (sinh_vien vs giang_vien) and different columns being counted (DISTINCT id_hoat_dong vs all rows). These are fundamental semantic differences."
  },
  {
    "id": 301,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 20,
    "reason": "The queries join completely different tables (sinh_vien vs giang_vien) and have different join conditions, making them semantically distinct regardless of data."
  },
  {
    "id": 302,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved: Gen uses sinh_vien and tham_gia_vao tables, while Gold uses giang_vien and giang_vien_tham_gia_vao tables. These are fundamentally different queries targeting different entities (students vs teachers)."
  },
  {
    "id": 303,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same core result (lecturers with participation counts), but Gen includes only ho, ten, and COUNT(*), while Gold includes an extra id_giang_vien column in SELECT. This is a minor cosmetic difference in output columns."
  },
  {
    "id": 304,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same main result (list of teachers with their participation count), but Gen includes a WHERE clause filtering out NULL activity IDs while Gold doesn't, and Gold includes an extra column (id_giang_vien) in SELECT that Gen omits."
  },
  {
    "id": 305,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are table aliases (hoat_dong vs t1, giang_vien_tham_gia_vao vs t2) and keyword case, which are cosmetic per rules."
  },
  {
    "id": 306,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and whitespace. Both query the same tables with the same JOIN condition, SELECT the same columns, and GROUP BY the same column."
  },
  {
    "id": 307,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in table aliases and column order in SELECT clause, which are explicitly ignored per the rules."
  },
  {
    "id": 308,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, column order, and formatting differences. Both select the same columns from the same tables with identical JOIN conditions, GROUP BY, and ORDER BY logic."
  },
  {
    "id": 309,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with the same conditions, group by the same column, and return the same result with identical ordering and limiting."
  },
  {
    "id": 310,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both queries join the same tables with the same conditions, group by the same column, and order by the same aggregate function."
  },
  {
    "id": 311,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return students not participating in activities: Gen uses NOT IN subquery, Gold uses EXCEPT (preferred SQL practice for set exclusion). They are semantically equivalent on any database state."
  },
  {
    "id": 312,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return students not participating in activities: NOT IN with subquery is semantically equivalent to EXCEPT for set exclusion, and EXCEPT is the preferred SQL pattern."
  },
  {
    "id": 313,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use fundamentally different logic: Gen uses a JOIN to find students under 20 who participated, while Gold uses INTERSECT to find students who both participated AND are under 20. These approaches are not semantically equivalent on all possible database states."
  },
  {
    "id": 314,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "The queries use fundamentally different logic: Gen performs a JOIN and filters by age, returning activity IDs, while Gold uses INTERSECT to find student IDs common to both tables with age filtering, returning student IDs instead."
  },
  {
    "id": 315,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column references. Both select the same columns from the same tables with identical JOIN conditions, GROUP BY, and ORDER BY logic."
  },
  {
    "id": 316,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column references. Both select the same columns from the same tables with identical JOIN conditions, GROUP BY, and ORDER BY logic."
  },
  {
    "id": 317,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both select the same column from the same tables with identical JOIN conditions, GROUP BY, ORDER BY, and LIMIT clauses."
  },
  {
    "id": 318,
    "db_id": "activity_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both select the same column from the same tables with identical JOIN conditions, GROUP BY, ORDER BY, and LIMIT clauses."
  },
  {
    "id": 319,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have different WHERE conditions (IN vs OR with different values) and different SELECT columns (Gen selects both ho and ten, Gold selects only distinct ho). The JOIN condition in Gold also appears to have a syntax error (t2.id_hoat_dong = t2.id_hoat_dong instead of t2.id_hoat_dong = t3.id_hoat_dong)."
  },
  {
    "id": 320,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "The JOIN condition in Gold SQL has a critical error (t2.id_hoat_dong = t2.id_hoat_dong instead of t2.id_hoat_dong = t3.id_hoat_dong), and the WHERE clause uses different activity names that may not be semantically equivalent ('Bơi xuồng'/'Chèo thuyền Kayak' vs 'canoeing'/'kayaking')."
  },
  {
    "id": 321,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen excludes professors who participated in specific activities, while Gold excludes all professors regardless of activity participation. Additionally, Gold has a syntax error in its JOIN condition (t2.id_hoat_dong = t2.id_hoat_dong instead of t2.id_hoat_dong = t3.id_hoat_dong)."
  },
  {
    "id": 322,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different WHERE conditions (Gen filters by activity names, Gold filters by ngach='professor') and different exclusion logic (Gen uses NOT IN with specific activities, Gold uses EXCEPT with different activity names)."
  },
  {
    "id": 323,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different JOIN conditions (t2.id_hoat_dong = t3.id_hoat_dong vs t2.id_hoat_dong = t2.id_hoat_dong) and different WHERE values ('Bơi xuồng'/'Chèo thuyền Kayak' vs 'canoeing'/'kayaking') that are not semantically equivalent."
  },
  {
    "id": 324,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 20,
    "reason": "Gold query has a critical syntax error (JOIN condition references same table twice) and uses different activity names ('canoeing'/'kayaking' vs 'Bơi xuồng'/'Chèo thuyền Kayak'), while Gen query selects different columns (ho, ten vs ho only) and has different INTERSECT logic (full names vs IDs)."
  },
  {
    "id": 325,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 40,
    "reason": "Gold query has a critical syntax error in JOIN condition (t2.id_hoat_dong = t2.id_hoat_dong instead of t1.id_hoat_dong = t2.id_hoat_dong), and the WHERE values ('canoeing'/'kayaking') don't match the Vietnamese activities in Gen query ('Bơi xuồng'/'Chèo thuyền Kayak') with no established equivalence."
  },
  {
    "id": 326,
    "db_id": "activity_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions with non-equivalent string values ('Bơi xuồng'/'Chèo thuyền Kayak' vs 'canoeing'/'kayaking'), and Gold has a syntax error in the JOIN ON clause (t2.id_hoat_dong = t2.id_hoat_dong)."
  },
  {
    "id": 327,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 328,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column, same ORDER BY clause. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 329,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same ORDER BY clause, with only minor cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 330,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the average of the same column from the same table with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 331,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are ignored according to the rules."
  },
  {
    "id": 332,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same ORDER BY clause with same direction. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 333,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform the same INNER JOIN between nguoi_luyen_the_hinh and ca_nhan tables using the same join condition, selecting the same column (ten) from the ca_nhan table. The only differences are cosmetic: table aliases (t1/t2 vs explicit table names) and keyword case."
  },
  {
    "id": 334,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE clause logic, differing only in table aliases which are cosmetic differences."
  },
  {
    "id": 335,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, select the same column, and use the same ORDER BY and LIMIT clauses. The only differences are table aliases and formatting, which are cosmetic."
  },
  {
    "id": 336,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, select the same columns, and use the same ORDER BY and LIMIT clauses. The only differences are table aliases and formatting, which are cosmetic."
  },
  {
    "id": 337,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE filters, differing only in table aliases and column references which are cosmetic differences."
  },
  {
    "id": 338,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both compute the average of 'tong' from the same joined tables with the same WHERE condition on height."
  },
  {
    "id": 339,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, select the same column (ten from ca_nhan), and order by the same column (tong from nguoi_luyen_the_hinh) in descending order. The only differences are table aliases and formatting, which are cosmetic."
  },
  {
    "id": 340,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column, perform the same aggregation, and group by the same column from the same table. The only differences are cosmetic (whitespace, formatting, and keyword case)."
  },
  {
    "id": 341,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY, ORDER BY, and LIMIT clauses, with only minor cosmetic differences in formatting and keyword case."
  },
  {
    "id": 342,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 343,
    "db_id": "body_builder",
    "strict_match": false,
    "score": 50,
    "reason": "The generated query includes an additional JOIN with the nguoi_luyen_the_hinh table, which filters results to only those ca_nhan records that have corresponding entries in that table. The gold query selects all ca_nhan records without any filtering, so they will return different results on any database where not all ca_nhan records are in nguoi_luyen_the_hinh."
  },
  {
    "id": 344,
    "db_id": "body_builder",
    "strict_match": false,
    "score": 40,
    "reason": "Gold query selects all columns from only nguoi_luyen_the_hinh table, while Gen query performs a JOIN with ca_nhan table and selects specific columns from both tables. These queries will return different results on any database where ca_nhan table has data."
  },
  {
    "id": 345,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return individuals who are not in the fitness training group. The Gen query uses NOT IN with a subquery while Gold uses EXCEPT with a JOIN, which are semantically equivalent for set exclusion, and EXCEPT is the preferred SQL pattern."
  },
  {
    "id": 346,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column, same COUNT(DISTINCT) aggregation, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 347,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count rows from ca_nhan where id_ca_nhan is not in nguoi_luyen_the_hinh, with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 348,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same conditions and have equivalent WHERE clauses (OR conditions with the same operands in different order)."
  },
  {
    "id": 349,
    "db_id": "body_builder",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen uses MONTH(ngay_sinh) = 1 (numeric month extraction), Gold uses ngay_sinh LIKE '%january%' (string pattern matching). These are not semantically equivalent as they match different date formats and could return different results."
  },
  {
    "id": 350,
    "db_id": "body_builder",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the minimum value of the 'cu_giat' column from the 'nguoi_luyen_the_hinh' table. The only differences are cosmetic (keyword case, whitespace formatting, and parentheses spacing)."
  },
  {
    "id": 351,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 352,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 353,
    "db_id": "candidate_poll",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same nguon_tham_do_y_kien value with highest count, but Generated query includes an extra COUNT(*) column in SELECT which wasn't explicitly requested in Gold query."
  },
  {
    "id": 354,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 355,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 356,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 357,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table, order by the same column in ascending order (ASC is default), and return the first row. The only differences are cosmetic (keyword case and optional ASC keyword)."
  },
  {
    "id": 358,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column from the same table with the same ordering and limit, with only minor cosmetic differences in keyword case and explicit ASC specification."
  },
  {
    "id": 359,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same ORDER BY clause. The only differences are cosmetic (keyword case, whitespace, and the explicit ASC keyword which is implied in the Gold query)."
  },
  {
    "id": 360,
    "db_id": "candidate_poll",
    "strict_match": false,
    "score": 75,
    "reason": "Gen includes an extra column (ty_le_khong_chac_chan) in SELECT that Gold doesn't have, but both use the same ORDER BY on that column. The main result ordering is preserved, but Gen returns additional data."
  },
  {
    "id": 361,
    "db_id": "candidate_poll",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same main result (nguon_tham_do_y_kien with highest ty_le_phan_doi), but Gen includes an extra column (ty_le_phan_doi) in SELECT that wasn't explicitly requested in Gold. This is a minor cosmetic difference that doesn't change the core answer."
  },
  {
    "id": 362,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 363,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with the same ordering (ASC is default in SQLite). The only differences are keyword case and explicit ASC specification, which are cosmetic."
  },
  {
    "id": 364,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with the same ordering. The only differences are cosmetic: keyword case (SELECT vs select) and explicit ASC specification vs default ascending order."
  },
  {
    "id": 365,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the same averages from the same table with the same gender condition, with only cosmetic differences in keyword case, whitespace, and single vs double quotes."
  },
  {
    "id": 366,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical - both calculate average height and weight for male individuals. The only differences are cosmetic (keyword case, whitespace, quote style) and the gender value uses English 'Nam' vs Vietnamese 'm', which are equivalent according to the rules."
  },
  {
    "id": 367,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 368,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are ignored per the rules."
  },
  {
    "id": 369,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (gender, average weight, minimum weight) from the same table with identical GROUP BY logic, differing only in column order and whitespace formatting."
  },
  {
    "id": 370,
    "db_id": "candidate_poll",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries calculate the same aggregates grouped by gender, but Gen excludes the grouping column from SELECT while Gold includes it. This is a minor difference in output columns."
  },
  {
    "id": 371,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same tables with identical JOIN conditions and ORDER BY logic, differing only in table aliases and formatting."
  },
  {
    "id": 372,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same result: the name and gender of the person with the highest support rate. They join the same tables with identical conditions, select the same columns, and use the same ordering and limit."
  },
  {
    "id": 373,
    "db_id": "candidate_poll",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same minimum phan_doi rate per gender, but Gen includes ORDER BY which Gold lacks, and Gen selects only 'ten' while Gold selects both 'ten' and 'gioi_tinh'."
  },
  {
    "id": 374,
    "db_id": "candidate_poll",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the gender with the lowest opposition rate, but Gen includes extra columns (ten) and uses ORDER BY+LIMIT while Gold uses MIN aggregation. The main answer (gender) would be the same, but Gen returns additional data."
  },
  {
    "id": 375,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same tables with the same JOIN conditions, GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (table aliases and whitespace formatting)."
  },
  {
    "id": 376,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, table references, and formatting. Both select gender from the same joined tables, group by gender, and order by the same average calculation."
  },
  {
    "id": 377,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from ca_nhan where id_ca_nhan is not in the ung_cu_vien table, with only cosmetic differences in formatting and case."
  },
  {
    "id": 378,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from ca_nhan where id_ca_nhan is not in the ung_cu_vien table. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 379,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and table references. Both join the same tables with the same condition and apply the same WHERE filter on the same columns."
  },
  {
    "id": 380,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with the same condition and apply the same WHERE filter on equivalent columns."
  },
  {
    "id": 381,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are column order in SELECT and keyword case/whitespace formatting, which are cosmetic differences per the rules."
  },
  {
    "id": 1146,
    "db_id": "imdb",
    "strict_match": false,
    "score": 40,
    "reason": "Different aggregation logic (COUNT(*) vs COUNT(DISTINCT ten)) and different WHERE conditions (noi_sinh = 'New York' vs noi_sinh = 'New York City')."
  },
  {
    "id": 1147,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "Different table joins and aggregation logic: Gen counts all actors meeting criteria, Gold counts distinct actor names with different table relationships."
  },
  {
    "id": 1148,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries count actors from China in Rush Hour 3, with only minor differences: Gen uses COUNT(*) while Gold uses COUNT(DISTINCT t1.ten), and string values differ between Vietnamese ('Trung Quốc', 'Giờ cao điểm 3') and English ('china', 'rush hour 3') equivalents."
  },
  {
    "id": 1149,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same set of movie titles where both actors appear, using equivalent logic with different structural approaches (INTERSECT vs JOIN with AND condition)."
  },
  {
    "id": 1150,
    "db_id": "imdb",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries find movies starring both actors, but Gen uses INTERSECT while Gold uses additional JOINs with AND conditions, which are semantically equivalent approaches."
  },
  {
    "id": 1151,
    "db_id": "imdb",
    "strict_match": false,
    "score": 40,
    "reason": "Different semantic logic: Gen finds movies where both actor 1 AND actor 2 appear (INTERSECT), while Gold finds movies where actor 'woody strode' AND actor 'jason robards' appear together (JOIN logic). These produce different result sets."
  },
  {
    "id": 1152,
    "db_id": "imdb",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return movies where both actors appear, using equivalent logic with different approaches: Gen uses INTERSECT of two subqueries while Gold uses a single query with multiple joins and AND conditions, which are semantically equivalent."
  },
  {
    "id": 1153,
    "db_id": "imdb",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different structures and logic. Generated query uses self-joins and subqueries to find actors who worked with Tom Hanks in the same series, while Gold query uses multiple joins to find actors who worked with Tom Hanks in the same film series."
  },
  {
    "id": 1154,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries find movie titles directed by directors who also directed 'Con đường cách mạng'/'revolutionary road', excluding that movie itself. The only differences are table aliases and the English/Vietnamese equivalent string value in the WHERE clause."
  },
  {
    "id": 1155,
    "db_id": "imdb",
    "strict_match": false,
    "score": 65,
    "reason": "Different GROUP BY columns (id_bo_phim vs tieu_de) and different aggregation functions (COUNT(*) vs COUNT(DISTINCT t2.the_loai)) lead to potentially different results."
  },
  {
    "id": 1156,
    "db_id": "imdb",
    "strict_match": false,
    "score": 65,
    "reason": "Different GROUP BY columns (id_bo_phim vs tieu_de) and different aggregation logic (COUNT(*) vs COUNT(DISTINCT t1.ten)) will produce different results in some database states."
  },
  {
    "id": 1157,
    "db_id": "imdb",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different logic: Gen finds actors in the most recent film, while Gold finds actors in Quentin Tarantino's most recent film. They involve different tables and WHERE conditions."
  },
  {
    "id": 1158,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, filter for the same director name, and return the same results with identical ordering and limiting."
  },
  {
    "id": 1159,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions, filter on the same director name, order by the same release year, and return the same single film title. The differences are purely cosmetic: table aliases, join order, and formatting."
  },
  {
    "id": 1160,
    "db_id": "imdb",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen counts all rows while Gold counts distinct director names, and different GROUP BY columns (id vs name)."
  },
  {
    "id": 1161,
    "db_id": "imdb",
    "strict_match": false,
    "score": 20,
    "reason": "The queries select different columns (Gen selects bo_phim.tieu_de, Gold selects dien_vien.ten) and have different table join orders, but the fundamental issue is they return completely different data - movie titles vs actor names."
  },
  {
    "id": 1162,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table with the same ORDER BY clause. The only differences are cosmetic (keyword case and explicit ASC specification)."
  },
  {
    "id": 1163,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table with the same ordering. The only differences are cosmetic (keyword case and explicit ASC specification)."
  },
  {
    "id": 1164,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with the same condition and filter on the same column with the same string value."
  },
  {
    "id": 1165,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions and select the same column. The only differences are cosmetic: table aliases, keyword case, whitespace, and single vs double quotes."
  },
  {
    "id": 1166,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the policy type with the highest count, with only minor cosmetic differences in formatting and whitespace."
  },
  {
    "id": 1167,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting. Both queries select the policy type with the highest count from the same table using identical GROUP BY, ORDER BY, and LIMIT clauses."
  },
  {
    "id": 1168,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same ma_loai_chinh_sach values, but Gen counts specific id_khach_hang while Gold counts all rows. If id_khach_hang is never NULL, they're equivalent; otherwise Gen excludes NULL values."
  },
  {
    "id": 1169,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(DISTINCT id_khach_hang) while Gold uses COUNT(*), which count different things (unique customers vs all rows)."
  },
  {
    "id": 1170,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate SUM and AVG on the same column from the same table with no filtering or grouping. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 1171,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate SUM and AVG on the same column from the same table with no filtering or grouping. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 1172,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 40,
    "reason": "Gen selects a single column value from the most recent document, while Gold sums all amounts from documents with the earliest creation date. Different aggregation logic and WHERE condition lead to different result sets."
  },
  {
    "id": 1173,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different logic: Gen uses ORDER BY + LIMIT to get the most recent document, while Gold uses a subquery to find the earliest document date. They will return different results when there are multiple documents with different creation dates."
  },
  {
    "id": 1174,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the customer details for the highest requested amount, but use different approaches: Gen uses ORDER BY + LIMIT while Gold uses a subquery with MAX. They are semantically equivalent and will return the same result on any database state."
  },
  {
    "id": 1175,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 50,
    "reason": "Different logic: Gen uses ORDER BY + LIMIT to get the row with highest amount, while Gold uses WHERE with subquery to filter for maximum amount rows. These can return different results when multiple rows share the same maximum amount."
  },
  {
    "id": 1176,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the customer details for the smallest payment amount, using different approaches: Gen uses ORDER BY + LIMIT 1, Gold uses MIN() subquery. They join the same tables with equivalent conditions and return the same result set."
  },
  {
    "id": 1177,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the customer details for the minimum payment amount, using different approaches: Gen uses ORDER BY + LIMIT 1 while Gold uses MIN() subquery. They join the same tables with equivalent conditions and produce identical results."
  },
  {
    "id": 1178,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different exclusion logic: Gen uses NOT IN with a subquery on chinh_sach, while Gold uses EXCEPT with a JOIN between chinh_sach and khach_hang. These may return different results if there are duplicate chi_tiet_khach_hang values or NULLs in the id_khach_hang column."
  },
  {
    "id": 1179,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different exclusion logic: Gen uses NOT IN with a subquery on chinh_sach, while Gold uses EXCEPT with a JOIN between chinh_sach and khach_hang. These approaches are not semantically equivalent as they exclude different sets of rows."
  },
  {
    "id": 1180,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with no filtering or grouping. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1181,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 20,
    "reason": "The queries operate on different tables (xu_ly_yeu_cau vs giai_doan_xu_ly_yeu_cau) and count different things (distinct IDs from one table vs all rows from another table). These are fundamental semantic differences."
  },
  {
    "id": 1182,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same main result (top status name), but Gen includes an extra COUNT column in SELECT that wasn't requested in Gold. The core logic (tables, joins, grouping, ordering, limit) is identical."
  },
  {
    "id": 1183,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same main result (top status name), but Gen includes an extra COUNT column in SELECT and uses different GROUP BY columns (T2.id_giai_doan_xu_ly_yeu_cau vs t1.id_giai_doan_xu_ly_yeu_cau), though these are likely functionally equivalent due to the JOIN condition."
  },
  {
    "id": 1184,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries search for customers with 'Diana' in their details, but Gen includes an extra 'id_khach_hang' column in SELECT that Gold doesn't request. This is a minor cosmetic difference that doesn't affect the main answer."
  },
  {
    "id": 1185,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing case, whitespace, and table aliases. Both search for the same pattern in the same column from the same table."
  },
  {
    "id": 1186,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same tables with equivalent conditions and return the same customer details. The only differences are cosmetic (aliases, formatting) and the WHERE clause uses equivalent English/Vietnamese values ('Uỷ quyền' = 'deputy')."
  },
  {
    "id": 1187,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same tables with equivalent conditions and filter for the same semantic meaning ('Uỷ quyền' = 'deputy'), differing only in column selection and DISTINCT usage which are cosmetic differences."
  },
  {
    "id": 1188,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries join the same tables with the same join condition and filter for similar policy types, but Gen returns customer IDs with details while Gold returns only distinct customer details. The WHERE conditions use different string values ('Uỷ quyền', 'Thống nhất' vs 'deputy', 'uniform') which appear to be Vietnamese-English equivalents for the same policy types."
  },
  {
    "id": 1189,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries join the same tables with the same join condition and filter for similar policy types, but Gen returns customer IDs with details while Gold returns only distinct customer details. The WHERE conditions use different string values ('Uỷ quyền', 'Thống nhất' vs 'deputy', 'uniform') which appear to be Vietnamese-English equivalents for the same concepts."
  },
  {
    "id": 1190,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 30,
    "reason": "Gen produces a Cartesian product (cross join) of all customers with all employees, while Gold performs a union of customer details and employee details separately. These return fundamentally different result sets with different row counts and column structures."
  },
  {
    "id": 1191,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 30,
    "reason": "Gen produces a Cartesian product (cross join) of all customer-employee combinations, while Gold performs a union of distinct customer and employee details. These queries have fundamentally different semantics and will return different results on any non-empty database."
  },
  {
    "id": 1192,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing cosmetic differences like keyword case, whitespace, and formatting. Both select the same columns from the same table with identical GROUP BY and COUNT(*) aggregation."
  },
  {
    "id": 1193,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing cosmetic differences like keyword case, whitespace, and formatting. Both select the same columns from the same table with identical GROUP BY and COUNT(*) aggregation."
  },
  {
    "id": 1194,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 70,
    "reason": "Both queries join the same tables with the same condition, but GROUP BY different columns (id_khach_hang vs chi_tiet_khach_hang). If chi_tiet_khach_hang is functionally dependent on id_khach_hang, they could be equivalent, but this isn't guaranteed for all database states."
  },
  {
    "id": 1195,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 70,
    "reason": "Both queries join the same tables with the same condition, but GROUP BY different columns: Gen groups by khach_hang.id_khach_hang while Gold groups by t2.chi_tiet_khach_hang. Since chi_tiet_khach_hang is likely functionally dependent on id_khach_hang (customer details depend on customer ID), they are semantically equivalent with minor difference."
  },
  {
    "id": 1196,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries return the same data: descriptions from giai_doan_xu_ly_yeu_cau where the status equals 'open'/'Mở'. The only differences are cosmetic (aliases, formatting) and the English/Vietnamese equivalent string values in the WHERE condition."
  },
  {
    "id": 1197,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables and columns selected: Gen uses tieu_de_cua_yeu_cau and giai_doan_xu_ly_yeu_cau with column ten_tinh_trang_yeu_cau, while Gold uses only giai_doan_xu_ly_yeu_cau with column mo_ta_ve_tinh_trang_yeu_cau. Different WHERE conditions: Gen filters on ma_tinh_trang_yeu_cau = 'Mở', Gold filters on ten_tinh_trang_yeu_cau = 'open'."
  },
  {
    "id": 1198,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 20,
    "reason": "The queries operate on completely different tables (tieu_de_cua_yeu_cau vs xu_ly_yeu_cau) and count different things (all rows vs distinct values of a specific column). These are fundamental semantic differences."
  },
  {
    "id": 1199,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table with no filtering conditions. The only differences are cosmetic (keyword case, whitespace, and parentheses spacing)."
  },
  {
    "id": 1200,
    "db_id": "insurance_and_eClaims",
    "strict_match": false,
    "score": 40,
    "reason": "Different SELECT columns (khach_hang.* vs t2.chi_tiet_khach_hang) and different logic for finding latest record (ORDER BY DESC LIMIT 1 vs subquery with MAX). These are semantic differences that could return different results."
  },
  {
    "id": 1201,
    "db_id": "insurance_and_eClaims",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the customer details for the most recent policy start date, using different but equivalent approaches: Gen uses ORDER BY DESC LIMIT 1 while Gold uses a subquery with MAX."
  },
  {
    "id": 1202,
    "db_id": "local_govt_in_alabama",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences in aliases and a Vietnamese vs English string literal value that share the same meaning ('Đám cưới' = 'marriage')."
  },
  {
    "id": 1203,
    "db_id": "local_govt_in_alabama",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and whitespace. Both query the same tables with the same JOIN condition, GROUP BY, and HAVING clause."
  },
  {
    "id": 1204,
    "db_id": "local_govt_in_alabama",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return participant information with counts, but Gen includes an extra GROUP BY column (ma_loai_nguoi_tham_gia) which may be functionally dependent on id_nguoi_tham_gia. This is a minor difference that doesn't change the main answer."
  },
  {
    "id": 1205,
    "db_id": "local_govt_in_alabama",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in whitespace and keyword case, which are ignored according to the rules."
  },
  {
    "id": 1206,
    "db_id": "local_govt_in_alabama",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical - both count rows from the same table with the same filtering condition. The only difference is the string literal value ('Người tổ chức' vs 'organizer'), which are English/Vietnamese equivalents for the same concept."
  },
  {
    "id": 1207,
    "db_id": "local_govt_in_alabama",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table with the same ORDER BY clause. The only differences are cosmetic (keyword case and explicit ASC specification)."
  },
  {
    "id": 1208,
    "db_id": "local_govt_in_alabama",
    "strict_match": false,
    "score": 10,
    "reason": "Queries select from completely different tables (dich_vu vs su_kien) and have different column selections, making them semantically distinct."
  },
  {
    "id": 1209,
    "db_id": "local_govt_in_alabama",
    "strict_match": false,
    "score": 40,
    "reason": "Gen counts DISTINCT events while Gold counts all rows; Gen filters for '%Dr%' while Gold filters for '%dr.%' (different patterns)."
  },
  {
    "id": 1210,
    "db_id": "local_govt_in_alabama",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1211,
    "db_id": "local_govt_in_alabama",
    "strict_match": false,
    "score": 20,
    "reason": "The queries join different tables and have different join conditions. Generated query uses dich_vu, su_kien, and nguoi_tham_gia_su_kien tables, while Gold query uses nguoi_tham_gia, nguoi_tham_gia_su_kien, su_kien, and dich_vu tables with different join paths."
  },
  {
    "id": 1212,
    "db_id": "local_govt_in_alabama",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different tables: Gen joins with 'su_kien' table while Gold only uses 'nguoi_tham_gia_su_kien'. This creates different semantic logic - Gen counts participants per event with event validation, while Gold counts participants per event ID regardless of event existence."
  },
  {
    "id": 1213,
    "db_id": "local_govt_in_alabama",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return events where no participant has the name 'Kenyatta Kuhn', using semantically equivalent NOT EXISTS vs EXCEPT patterns with identical filtering logic."
  },
  {
    "id": 1214,
    "db_id": "local_govt_in_alabama",
    "strict_match": false,
    "score": 50,
    "reason": "Gen uses IN with two values ('Thành công', 'Thất bại') which returns rows matching either value, while Gold uses INTERSECT with separate queries for 'success' and 'fail' which returns rows matching both values. These are semantically different set operations."
  },
  {
    "id": 1215,
    "db_id": "local_govt_in_alabama",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries count events with no participants: Gen uses LEFT JOIN with NULL check, Gold uses NOT IN subquery. They are semantically equivalent with Gen using a more explicit JOIN approach."
  },
  {
    "id": 1216,
    "db_id": "local_govt_in_alabama",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct id_nguoi_tham_gia from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1217,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with the same aggregation function. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 1218,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 1219,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are ignored according to the rules."
  },
  {
    "id": 1220,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for keyword case (SELECT vs select), which is a cosmetic difference that does not affect the results."
  },
  {
    "id": 1221,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 1222,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 1223,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column from the same table with the same WHERE condition. The differences are purely cosmetic: column name case, string literal case, and quote style."
  },
  {
    "id": 1224,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column from the same table with the same WHERE condition. The differences (keyword case, single vs double quotes, column name case) are purely cosmetic."
  },
  {
    "id": 1225,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1226,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1227,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table with the same ordering and limit. The only differences are cosmetic (table alias usage and keyword case)."
  },
  {
    "id": 1228,
    "db_id": "machine_repair",
    "strict_match": false,
    "score": 20,
    "reason": "Different ORDER BY columns (nam_bat_dau vs tuoi) will produce different results in most cases, as they sort by different criteria before taking LIMIT 1."
  },
  {
    "id": 1229,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column with the same aggregation and grouping, with only minor cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 1230,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column, perform the same aggregation, and group by the same column. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1231,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same SELECT columns, FROM table, GROUP BY clause, ORDER BY logic, and LIMIT. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1232,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same SELECT columns, FROM table, GROUP BY clause, ORDER BY logic, and LIMIT. The only differences are cosmetic (keyword case and whitespace)."
  },
  {
    "id": 1233,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same GROUP BY and HAVING conditions, with only minor formatting differences in whitespace and keyword case."
  },
  {
    "id": 1234,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY and HAVING conditions, with only minor formatting differences in whitespace and keyword case."
  },
  {
    "id": 1235,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions, only differing in table aliases and join order which are cosmetic differences."
  },
  {
    "id": 1236,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions, only differing in table aliases and join order which are cosmetic differences."
  },
  {
    "id": 1237,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and select the same column (technician name), ordering by the same quality ranking column. The only differences are table aliases and column reference styles, which are cosmetic."
  },
  {
    "id": 1238,
    "db_id": "machine_repair",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries join the same tables with equivalent conditions and order by the same column, but Gen selects an extra column (may_moc.xep_hang_chat_luong) that Gold does not include in SELECT."
  },
  {
    "id": 1239,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause logic, differing only in table aliases and join order which are cosmetic differences."
  },
  {
    "id": 1240,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause, selecting the same column (ten from ky_thuat_vien) with only table alias differences."
  },
  {
    "id": 1241,
    "db_id": "machine_repair",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same engineer names with their assignment counts, but Gen groups by ID while Gold groups by name. If name is functionally dependent on ID (unique), they're semantically equivalent, but this is a minor structural difference."
  },
  {
    "id": 1242,
    "db_id": "machine_repair",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same engineer names with their assignment counts, but Gen groups by engineer ID while Gold groups by engineer name. If names are unique/functionally dependent on IDs, they're semantically equivalent with minor GROUP BY variation."
  },
  {
    "id": 1243,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both use NOT IN with the same subquery structure, differing only in cosmetic formatting and keyword case."
  },
  {
    "id": 1244,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from the same table using the same NOT IN subquery with the same conditions, differing only in cosmetic formatting and keyword case."
  },
  {
    "id": 1245,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both use INTERSECT to find common nam_bat_dau values between doi='CLE' and doi='CWS', with only cosmetic differences in keyword case and string quote style."
  },
  {
    "id": 1246,
    "db_id": "machine_repair",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both use INTERSECT to find common nam_bat_dau values between doi='CLE' and doi='CWS', with only cosmetic differences in keyword case and quote style."
  },
  {
    "id": 1247,
    "db_id": "mountain_photos",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they both count rows from the same table with the same WHERE condition, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 1248,
    "db_id": "mountain_photos",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for keyword case (SELECT vs select) and whitespace formatting, which are cosmetic differences that don't affect the results."
  },
  {
    "id": 1249,
    "db_id": "mountain_photos",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1250,
    "db_id": "mountain_photos",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries calculate the maximum and average height from the same table with identical aggregation functions, differing only in whitespace formatting and keyword case."
  },
  {
    "id": 1251,
    "db_id": "mountain_photos",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are keyword case (SELECT vs select), whitespace formatting, and single vs double quotes around string literal 'morocco'."
  },
  {
    "id": 1252,
    "db_id": "mountain_photos",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen uses NOT LIKE on column 'ten' while Gold uses != on column 'day_nui'. These reference different columns and use different comparison operators, making them semantically distinct."
  },
  {
    "id": 1253,
    "db_id": "mountain_photos",
    "strict_match": false,
    "score": 20,
    "reason": "The queries join different tables with reversed roles: Gen joins anh to nui while Gold joins nui to anh, and the WHERE condition references different tables (nui.chieu_cao vs t1.chieu_cao where t1 is nui in Gold). This creates different semantic logic."
  },
  {
    "id": 1254,
    "db_id": "mountain_photos",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same mountain IDs and names with at least 2 photos, but Gen includes 'nui.ten' in GROUP BY while Gold only groups by 't1.id'. Since 'ten' is functionally dependent on 'id' in the nui table, they are semantically equivalent with a minor cosmetic difference."
  },
  {
    "id": 1255,
    "db_id": "mountain_photos",
    "strict_match": false,
    "score": 40,
    "reason": "Different logic: Gen finds cameras for tallest mountain, Gold finds most frequently used camera. Different tables (Gen includes nui table, Gold doesn't) and different filtering conditions."
  },
  {
    "id": 1256,
    "db_id": "mountain_photos",
    "strict_match": true,
    "score": 98,
    "reason": "Queries are semantically equivalent with only minor differences: table aliases, IN vs OR conditions, and case sensitivity in string literals. Both select camera names where the lens brand is Sigma or Olympus."
  },
  {
    "id": 1257,
    "db_id": "mountain_photos",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for cosmetic differences in keyword case and whitespace formatting. Both count distinct values from the same column in the same table."
  },
  {
    "id": 1258,
    "db_id": "mountain_photos",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count rows from ong_kinh_may_anh where id is not in the set of id_ong_kinh_may_anh values from anh table. The DISTINCT keyword in Gen's subquery doesn't change the semantics since NOT IN already handles duplicates identically."
  },
  {
    "id": 1259,
    "db_id": "mountain_photos",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count distinct camera lens IDs from photos taken on mountains in Ethiopia, using the same tables and join conditions with only cosmetic differences in aliases and formatting."
  },
  {
    "id": 1260,
    "db_id": "mountain_photos",
    "strict_match": false,
    "score": 50,
    "reason": "Gen uses WHERE...IN with mountain names, while Gold uses INTERSECT with separate queries filtering by mountain range names - these are semantically different conditions that could return different results."
  },
  {
    "id": 1261,
    "db_id": "mountain_photos",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use fundamentally different exclusion logic: Gen uses NOT IN with nested subqueries while Gold uses EXCEPT with JOINs, which are not semantically equivalent in all cases due to NULL handling and duplicate row treatment."
  },
  {
    "id": 1262,
    "db_id": "mountain_photos",
    "strict_match": false,
    "score": 65,
    "reason": "The queries use different LIKE patterns: '% Kỹ Thuật Số %' searches for Vietnamese text meaning 'digital', while '%digital%' searches for the English word. Although the concepts are semantically equivalent, the actual string matching differs and could return different results depending on the data."
  },
  {
    "id": 1263,
    "db_id": "mountain_photos",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries count photos per lens name, but Gen groups by 'ten' (name) while Gold groups by 'id' (primary key). If names are unique/functionally dependent on IDs, they're equivalent; otherwise, Gen could group duplicate names incorrectly."
  },
  {
    "id": 1264,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 1265,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with no filtering or grouping. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1266,
    "db_id": "music_2",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same set of distinct values from the 'hang_thu_am' column, but Gen omits DISTINCT which could return duplicates. However, since the column values would be identical with or without DISTINCT, they are semantically equivalent for most practical purposes."
  },
  {
    "id": 1267,
    "db_id": "music_2",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same set of distinct values from the 'hang_thu_am' column, but Gen omits DISTINCT which could return duplicate rows. However, since the column values would be identical, the result sets are semantically equivalent for most practical purposes."
  },
  {
    "id": 1268,
    "db_id": "music_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return rows from the album table for year 2012, but Gen explicitly selects specific columns while Gold uses SELECT * which returns all columns. The result sets differ in column count and content."
  },
  {
    "id": 1269,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1270,
    "db_id": "music_2",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same vi_tri_tren_san_khau values for ban_nhac with ten='Solveig', but Gen lacks DISTINCT while Gold includes it. Without DISTINCT, Gen could return duplicate rows if multiple buoi_bieu_dien records match the same ban_nhac."
  },
  {
    "id": 1271,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables and columns: Gen uses danh_sach_bai_hat table and vi_tri column, while Gold uses buoi_bieu_dien table and vi_tri_tren_san_khau column. Different JOIN structure with additional table in Gen."
  },
  {
    "id": 1272,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 1273,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table 'bai_hat'. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1274,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause filtering for the same value (case-insensitive 'Heilo'/'heilo'), returning the same column from the same table despite different aliases and join order."
  },
  {
    "id": 1275,
    "db_id": "music_2",
    "strict_match": false,
    "score": 20,
    "reason": "Different WHERE conditions: 'Hello' vs 'heilo' are not equivalent values (not English/Vietnamese synonyms). Different JOIN logic: Gen uses ban_nhac as starting table, Gold uses buoi_bieu_dien as starting table."
  },
  {
    "id": 1276,
    "db_id": "music_2",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries count distinct bands performing the song 'Flash', but Gen uses COUNT(DISTINCT T3.id) while Gold uses COUNT(*), which could produce different results if there are duplicate band IDs in the result set."
  },
  {
    "id": 1277,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query joins only bai_hat and buoi_bieu_dien, while Gold query adds an additional join with ban_nhac table, making them semantically different."
  },
  {
    "id": 1278,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "The queries use completely different table structures and join logic. Generated query joins bai_hat with nhac_cu and giong_hat through ban_nhac, while Gold query joins buoi_bieu_dien with ban_nhac and bai_hat."
  },
  {
    "id": 1279,
    "db_id": "music_2",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved (Gen uses giong_hat, Gold uses buoi_bieu_dien) and different JOIN logic with mismatched conditions, leading to fundamentally different queries."
  },
  {
    "id": 1280,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, table order, and case differences. Both query the same tables with equivalent JOIN conditions and WHERE clause."
  },
  {
    "id": 1281,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, table order, and case differences. Both join the same three tables with equivalent conditions and select the same columns."
  },
  {
    "id": 1282,
    "db_id": "music_2",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions: 'hậu trường' vs 'back' are not equivalent values, and the table aliases/join order differ but that's cosmetic. The different string values in the WHERE clause make them semantically different."
  },
  {
    "id": 1283,
    "db_id": "music_2",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases (T2/T3 vs t2/t3), column aliases (T3.ten/T3.ho vs t2.ten/t2.ho), and Vietnamese vs English string values ('hậu trường' vs 'back') which have the same meaning."
  },
  {
    "id": 1284,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of the same column from the same table. The only differences are cosmetic (keyword case, whitespace, and parentheses spacing)."
  },
  {
    "id": 1285,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting. Both count distinct values of the same column from the same table."
  },
  {
    "id": 1286,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same grouping column, same ordering logic, and same limit. The only differences are cosmetic (keyword case and whitespace around COUNT(*))."
  },
  {
    "id": 1287,
    "db_id": "music_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same hang_thu_am value with the highest album count, but Gen includes an extra COUNT(*) column in SELECT while Gold only selects hang_thu_am."
  },
  {
    "id": 1288,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses ban_nhac and giong_hat, Gold uses buoi_bieu_dien, ban_nhac, and bai_hat) and different JOIN logic, leading to fundamentally different result sets."
  },
  {
    "id": 1289,
    "db_id": "music_2",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved (Gen uses nhac_cu and giong_hat, Gold uses buoi_bieu_dien and bai_hat) and different JOIN conditions, leading to completely different semantic logic."
  },
  {
    "id": 1290,
    "db_id": "music_2",
    "strict_match": false,
    "score": 50,
    "reason": "Gen query lacks the WHERE condition on vi_tri_tren_san_khau = 'back' that Gold query has, making them semantically different as Gen counts all performances while Gold only counts back-position performances."
  },
  {
    "id": 1291,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gold query filters for vi_tri_tren_san_khau = 'back' while Gen query has no such filter. Different JOIN logic: Gen joins ban_nhac to buoi_bieu_dien while Gold joins buoi_bieu_dien to ban_nhac with reversed ON condition."
  },
  {
    "id": 1292,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The LIKE patterns are semantically different: '%the%' matches any occurrence of 'the' anywhere in the string, while '% the %' only matches 'the' as a separate word surrounded by spaces."
  },
  {
    "id": 1293,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The LIKE patterns are semantically different: '%the%' matches any occurrence of 'the' anywhere in the string, while '% the %' only matches 'the' when surrounded by spaces. These will return different results for strings like 'theatre' or 'breathe'."
  },
  {
    "id": 1294,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen joins with buoi_bieu_dien and groups by nhac_cu, while Gold simply selects distinct nhac_cu from the nhac_cu table without any joins or grouping."
  },
  {
    "id": 1295,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different logic: Gen performs a JOIN between two tables with a specific condition, while Gold selects from a single table with DISTINCT. These will return different results in most database states."
  },
  {
    "id": 1296,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Different table structures: Gen uses nhac_cu, ban_nhac, bai_hat while Gold uses buoi_bieu_dien, ban_nhac, bai_hat, nhac_cu with different join conditions. The WHERE conditions are semantically equivalent (same values, ignoring case), but the underlying data relationships differ."
  },
  {
    "id": 1297,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "Different table structure: Generated query uses 3 tables (nhac_cu, ban_nhac, bai_hat) while Gold query uses 4 tables including buoi_bieu_dien. Different JOIN conditions and relationships between tables."
  },
  {
    "id": 1298,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the most frequent nhac_cu value from the nhac_cu table using the same GROUP BY, ORDER BY, and LIMIT logic. The only differences are cosmetic (table alias usage and whitespace formatting)."
  },
  {
    "id": 1299,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table, group by the same column, order by the same count, and limit to the same result. The only differences are cosmetic (table alias usage and whitespace formatting)."
  },
  {
    "id": 1300,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables and JOIN logic: Gen uses bai_hat JOIN nhac_cu with DISTINCT count on bai_hat.id_bai_hat, while Gold only counts from nhac_cu table. The WHERE clause values 'trống' and 'drums' are semantically equivalent (Vietnamese vs English for drums), but the table structure difference changes the result set."
  },
  {
    "id": 1301,
    "db_id": "music_2",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions ('trống' vs 'drums') which are not equivalent values, and different aggregation logic (COUNT(DISTINCT id_bai_hat) vs COUNT(*))."
  },
  {
    "id": 1302,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, table order, and case differences. Both join the same tables with the same condition and filter on the same column with equivalent string values."
  },
  {
    "id": 1303,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and string literal differences. Both join the same tables with the same condition and filter on the same column with equivalent values."
  },
  {
    "id": 1304,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count distinct nhac_cu values from the same joined tables with identical join conditions and WHERE clause filtering for the same song title (case-insensitive and ignoring quote style differences)."
  },
  {
    "id": 1305,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both count distinct nhac_cu values from the same join with identical conditions."
  },
  {
    "id": 1306,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, table order, and case differences. Both count distinct nhac_cu values from the same join with equivalent WHERE conditions."
  },
  {
    "id": 1307,
    "db_id": "music_2",
    "strict_match": false,
    "score": 20,
    "reason": "Different WHERE conditions: 'Hello' vs 'heilo' are not equivalent values, and different JOIN logic with swapped table references and different ON conditions."
  },
  {
    "id": 1308,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string values - both select the same column from the same tables with identical JOIN conditions and WHERE filters."
  },
  {
    "id": 1309,
    "db_id": "music_2",
    "strict_match": false,
    "score": 20,
    "reason": "Different WHERE conditions: 'Hello' vs 'heilo' are not equivalent values, and different JOIN logic with mismatched column references."
  },
  {
    "id": 1310,
    "db_id": "music_2",
    "strict_match": false,
    "score": 50,
    "reason": "Different GROUP BY columns: Gen groups by bai_hat.id_bai_hat while Gold groups by t1.id_bai_hat (giong_hat.id_bai_hat). These are different columns from different tables, leading to potentially different results."
  },
  {
    "id": 1311,
    "db_id": "music_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same song title with highest voice count, but Gen includes an extra COUNT(*) column in SELECT while Gold only selects tieu_de. The main logic (JOIN, GROUP BY, ORDER BY, LIMIT) is identical."
  },
  {
    "id": 1312,
    "db_id": "music_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the most frequent loai value, but Gen includes an extra COUNT(*) column in SELECT while Gold only selects loai. This is a minor cosmetic difference that doesn't change the main answer."
  },
  {
    "id": 1313,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same grouping, same ordering, and same limit. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1314,
    "db_id": "music_2",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions ('Hello' vs 'heilo' are not equivalent values) and Gold has GROUP BY with aggregation while Gen does not, leading to different result sets."
  },
  {
    "id": 1315,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have different WHERE conditions ('Hello' vs 'heilo' are not equivalent values) and Gold includes GROUP BY with aggregation while Gen does not, leading to different result sets."
  },
  {
    "id": 1316,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE clauses, selecting the same column. The only differences are cosmetic: table aliases, keyword case, and single vs double quotes."
  },
  {
    "id": 1317,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE clauses, differing only in table aliases, keyword case, and whitespace formatting."
  },
  {
    "id": 1318,
    "db_id": "music_2",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(DISTINCT loai) while Gold uses COUNT(*). These will return different results when there are duplicate loai values for the same song."
  },
  {
    "id": 1319,
    "db_id": "music_2",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic: Gen uses COUNT(DISTINCT giong_hat.loai) while Gold uses COUNT(*), which count different things and will return different results when there are duplicate loai values."
  },
  {
    "id": 1320,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have different aggregation logic (COUNT(*) vs COUNT(DISTINCT tieu_de)) and different WHERE conditions ('chính' vs 'lead' which are not equivalent values)."
  },
  {
    "id": 1321,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Different aggregation logic (COUNT(*) vs COUNT(DISTINCT tieu_de)) and different WHERE conditions ('chính' vs 'lead' are not equivalent values)."
  },
  {
    "id": 1322,
    "db_id": "music_2",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases, keyword case, and English vs Vietnamese string values for the same real-world meaning ('Quán bar ở Amsterdam' = 'a bar in Amsterdam')."
  },
  {
    "id": 1323,
    "db_id": "music_2",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically identical after normalizing aliases, case, and treating English/Vietnamese string values as equivalent ('Quán bar ở Amsterdam' = 'a bar in amsterdam', 'Solveig' = 'solveig')."
  },
  {
    "id": 1324,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen finds songs without 'chính' vocals, while Gold finds songs with vocals but excludes those with 'lead' vocals. They operate on different subsets of data."
  },
  {
    "id": 1325,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen excludes songs with 'chính' type vocals, while Gold excludes songs with 'lead' type vocals. These are different string values that are not equivalent in meaning."
  },
  {
    "id": 1326,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select distinct values from the same column in the same table. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 1327,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select distinct values from the same column in the same table, with only cosmetic differences in keyword case."
  },
  {
    "id": 1328,
    "db_id": "music_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return rows from the album table for year 2010, but Gen explicitly selects specific columns while Gold uses SELECT * which returns all columns. On any possible database, they would return the same rows but with different column sets."
  },
  {
    "id": 1329,
    "db_id": "music_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return rows from the album table where nam = 2010, but Gen explicitly selects specific columns while Gold uses SELECT * which returns all columns. The result sets will have different column structures."
  },
  {
    "id": 1330,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and table references. Both join the same three tables with equivalent conditions and filter on the same column value (treating 'Le Pop' and 'le pop' as case-insensitive matches)."
  },
  {
    "id": 1331,
    "db_id": "music_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and table join order. Both select the same columns from the same tables with identical join conditions and WHERE clause filtering."
  },
  {
    "id": 1332,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses ban_nhac+nhac_cu, Gold uses buoi_bieu_dien+ban_nhac+bai_hat) and different JOIN conditions, leading to fundamentally different logic and results."
  },
  {
    "id": 1333,
    "db_id": "music_2",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved (Gen uses nhac_cu and giong_hat, Gold uses buoi_bieu_dien and bai_hat) and different JOIN conditions, leading to completely different semantic logic."
  },
  {
    "id": 1334,
    "db_id": "music_2",
    "strict_match": false,
    "score": 40,
    "reason": "Different table structure: Generated query uses 3 tables (nhac_cu, ban_nhac, bai_hat) while Gold query uses 4 tables including buoi_bieu_dien. Different JOIN conditions and relationships between tables."
  },
  {
    "id": 1335,
    "db_id": "music_2",
    "strict_match": false,
    "score": 30,
    "reason": "Different table structures: Gen uses nhac_cu directly with joins to ban_nhac and bai_hat, while Gold uses buoi_bieu_dien as the main table with additional joins. The WHERE conditions also have different string values ('Hello' vs 'heilo') that are not equivalent."
  },
  {
    "id": 1336,
    "db_id": "music_2",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different aggregation logic: Gen uses COUNT(*) which counts all rows, while Gold uses COUNT(DISTINCT nhac_cu) which counts distinct nhac_cu values. These will return different results when there are duplicate nhac_cu values in the joined result."
  },
  {
    "id": 1719,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and select the same columns, differing only in table aliases and column order in SELECT clause, which are cosmetic differences."
  },
  {
    "id": 1720,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both use NOT IN to find students who haven't participated in any courses, with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 1721,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query excludes students who appear in EITHER attendance OR registration tables, while Gold only excludes those in attendance table. This creates different exclusion logic that could return different results."
  },
  {
    "id": 1722,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with no filtering or aggregation."
  },
  {
    "id": 1723,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "The generated query performs an INNER JOIN with the sinh_vien table, which will only return students that exist in both tables, while the gold query returns all students from lan_tham_du_khoa_hoc_cua_sinh_vien regardless of whether they exist in sinh_vien. These are semantically different operations."
  },
  {
    "id": 1724,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 20,
    "reason": "Gen query includes an extra table (sinh_vien) and different JOIN conditions, while Gold query only uses two tables with different aliases and JOIN logic."
  },
  {
    "id": 1725,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 30,
    "reason": "The queries return completely different result sets: Gen returns personal details from ca_nhan table, while Gold returns only student IDs from sinh_vien table. They join different tables and select different columns."
  },
  {
    "id": 1726,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different SELECT clauses and JOIN structures. Gen returns detailed personal information from ca_nhan table, while Gold returns only a single ID column from sinh_vien table."
  },
  {
    "id": 1727,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries count distinct students who attended courses with specific names, using equivalent English/Vietnamese course names ('tiếng Anh' = 'english') and COUNT(DISTINCT id) vs COUNT(*) with proper JOIN logic."
  },
  {
    "id": 1728,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved (sinh_vien vs lan_tham_du_khoa_hoc_cua_sinh_vien) and different JOIN logic. The English/Vietnamese value equivalence for 'tiếng Anh'/'english' doesn't compensate for the structural differences."
  },
  {
    "id": 1729,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 40,
    "reason": "Gen query counts from single table with WHERE condition, while Gold query joins two tables with different filtering logic. The Gold query includes an additional table (khoa_hoc) and join condition, making the queries semantically different."
  },
  {
    "id": 1730,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 40,
    "reason": "Gen query counts from single table with WHERE condition, while Gold query joins two tables with different filtering logic. These queries will return different results when khoa_hoc table has multiple matching records."
  },
  {
    "id": 1731,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent join conditions and filter on the same email value, differing only in table aliases and column selection order."
  },
  {
    "id": 1732,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN logic: Gen joins on ung_cu_vien.id_ca_nhan = ca_nhan.id_ca_nhan while Gold joins on t1.id_ca_nhan = t2.id_ung_cu_vien, which are not equivalent conditions."
  },
  {
    "id": 1733,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "Different tables involved - Gen joins two tables while Gold only uses one table. This creates different semantic logic that could return different results depending on the data."
  },
  {
    "id": 1734,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "Different tables involved - Gen joins two tables while Gold only uses one table. This creates different result sets when candidates exist without evaluations."
  },
  {
    "id": 1735,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the student with most course registrations, but Gen includes extra personal name columns and uses a different GROUP BY approach with additional JOIN to ca_nhan table, while Gold only returns the student detail ID."
  },
  {
    "id": 1736,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 65,
    "reason": "Different SELECT columns: Gen returns ho, ten, id_sinh_vien from ca_nhan table, while Gold returns chi_tiet_sinh_vien from sinh_vien table. Different JOIN structure: Gen has an extra JOIN to ca_nhan table that Gold doesn't have."
  },
  {
    "id": 1737,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same tables, JOIN conditions, GROUP BY clause, and aggregation. The only differences are cosmetic (aliases T1 vs t1, keyword case, and whitespace formatting)."
  },
  {
    "id": 1738,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are table aliases (t1/t2 vs none) and formatting, which are cosmetic variations per the rules."
  },
  {
    "id": 1739,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN logic: Gen joins khoa_hoc directly with luot_dang_ky_khoa_hoc_cua_sinh_vien, while Gold joins sinh_vien first then khoa_hoc through luot_dang_ky_khoa_hoc_cua_sinh_vien. This changes which rows are included in the result set."
  },
  {
    "id": 1740,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 40,
    "reason": "Different table joins and grouping logic - Gen uses only khoa_hoc and luot_dang_ky_khoa_hoc_cua_sinh_vien while Gold includes sinh_vien table and groups by different column."
  },
  {
    "id": 1741,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "Different table structure: Gen uses JOIN with ung_cu_vien table while Gold only queries danh_gia_ung_cu_vien. The WHERE condition uses different string values ('Đạt' vs 'pass') which may not be equivalent."
  },
  {
    "id": 1742,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "Different table structure: Gen uses JOIN with ung_cu_vien table while Gold only queries danh_gia_ung_cu_vien. Different WHERE values: 'Đạt' vs 'pass' are not equivalent in the provided mapping."
  },
  {
    "id": 1743,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN conditions: Gen uses T1.id_ca_nhan = T3.id_ca_nhan while Gold uses T1.id_ung_cu_vien = T3.id_ca_nhan. Also, WHERE clause values 'Trượt' and 'fail' are not equivalent in the provided Vietnamese-English mapping."
  },
  {
    "id": 1744,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical; the only difference is the WHERE clause value 'Trượt' (Vietnamese for 'fail') vs 'fail' (English), which are equivalent according to the rules."
  },
  {
    "id": 1745,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved: Gen uses 'sinh_vien' and 'luot_dang_ky_khoa_hoc_cua_sinh_vien' while Gold uses only 'lan_tham_du_khoa_hoc_cua_sinh_vien'. These appear to be different tables with different semantics."
  },
  {
    "id": 1746,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved (sinh_vien JOIN luot_dang_ky_khoa_hoc_cua_sinh_vien vs lan_tham_du_khoa_hoc_cua_sinh_vien) and different WHERE value types (string '301' vs integer 301). These are semantic differences that can produce different results."
  },
  {
    "id": 1747,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the student ID for course '301' with the latest participation date, but Gen includes an unnecessary JOIN to the sinh_vien table which doesn't affect the result. The main difference is the JOIN vs no JOIN, but since the JOIN doesn't filter or add columns, the results are functionally equivalent."
  },
  {
    "id": 1748,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same student ID for course 301 with the most recent participation date. The JOIN in Gen is redundant since all needed columns are in the same table."
  },
  {
    "id": 1749,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both select distinct city values from the same tables with the same JOIN condition, differing only in table aliases and formatting."
  },
  {
    "id": 1750,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 40,
    "reason": "Gen query selects from only dia_chi table, while Gold query joins dia_chi with dia_chi_ca_nhan table. The JOIN in Gold adds a filtering condition that restricts results to only cities with associated personal addresses."
  },
  {
    "id": 1751,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 40,
    "reason": "Different JOIN logic and relationships between tables - Gen uses ca_nhan as intermediate table while Gold directly joins sinh_vien with dia_chi_ca_nhan using different column relationships."
  },
  {
    "id": 1752,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN logic: Gen joins through ca_nhan table while Gold directly joins sinh_vien with dia_chi_ca_nhan using different foreign key relationships."
  },
  {
    "id": 1753,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ORDER BY clauses (ASC is default). The only differences are cosmetic: keyword case and explicit ASC specification."
  },
  {
    "id": 1754,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ORDER BY clauses (ASC is default). The only differences are cosmetic: keyword case and explicit ASC specification."
  },
  {
    "id": 1755,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ordering. The only differences are keyword case (SELECT vs select) and explicit ASC specification, which are cosmetic."
  },
  {
    "id": 1756,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ORDER BY logic (ASC is default). The only differences are keyword case and explicit ASC specification, which are cosmetic."
  },
  {
    "id": 1757,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both perform a UNION of the same column from the same two tables, with only cosmetic differences in keyword case and formatting."
  },
  {
    "id": 1758,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both perform a UNION of the same two tables selecting the same column, with only minor cosmetic differences in keyword case."
  },
  {
    "id": 1759,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same set of course IDs for student 121 by combining registration and attendance records using UNION with identical filtering logic."
  },
  {
    "id": 1760,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same set of course IDs for student 121 from two tables using UNION, with only cosmetic differences in table aliases and JOIN syntax."
  },
  {
    "id": 1761,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 50,
    "reason": "Different tables in main FROM clause: Gen queries 'sinh_vien' table while Gold queries 'luot_dang_ky_khoa_hoc_cua_sinh_vien' table. The EXCEPT vs NOT IN logic is equivalent, but the base data source differs."
  },
  {
    "id": 1762,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 40,
    "reason": "The queries use different tables and return different columns. Gen query joins sinh_vien and ca_nhan tables with specific columns, while Gold query only uses luot_dang_ky_khoa_hoc_cua_sinh_vien table with SELECT *."
  },
  {
    "id": 1763,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and the course name value ('thống kê' vs 'statistics'), which are treated as equivalent English/Vietnamese translations."
  },
  {
    "id": 1764,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and Vietnamese vs English course name values ('thống kê' = 'statistics'). Both join the same tables with equivalent conditions and return the same student IDs ordered by registration date."
  },
  {
    "id": 1765,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries return student IDs who attended courses named 'statistics'/'thống kê' (same meaning), ordered by attendance date. The Gen query has additional JOINs that don't change the result since they're redundant given the relationships."
  },
  {
    "id": 1766,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same tables with equivalent conditions and return the same student IDs ordered by participation date. The only difference is the WHERE clause uses 'thống kê' (Vietnamese) vs 'statistics' (English), which are semantically equivalent values for the same course name."
  },
  {
    "id": 1767,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1768,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1769,
    "db_id": "workshop_paper",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return results ordered by so_diem ASC, but Gen includes an extra column (so_diem) in SELECT that Gold doesn't request. This is a minor cosmetic difference that doesn't change the main answer about tac_gia ordering."
  },
  {
    "id": 1770,
    "db_id": "workshop_paper",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return results ordered by so_diem ASC, but Gen includes an extra column (so_diem) in SELECT that Gold doesn't request. This is a minor cosmetic difference that doesn't change the main answer about which tac_gia appears."
  },
  {
    "id": 1771,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are ignored per the rules."
  },
  {
    "id": 1772,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for keyword case (SELECT vs select) and minor whitespace differences, which are cosmetic variations that don't affect the semantic meaning."
  },
  {
    "id": 1773,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same column selection, same WHERE conditions with OR logic, only differences are cosmetic (keyword case, single vs double quotes, whitespace)."
  },
  {
    "id": 1774,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select authors from the same table with the same OR conditions, with only minor cosmetic differences in keyword case and quotation marks."
  },
  {
    "id": 1775,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the average of 'so_diem' from the same table 'luot_nop_bai'. The only differences are cosmetic (keyword case, whitespace, and parentheses formatting)."
  },
  {
    "id": 1776,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the average of the same column from the same table with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 1777,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with identical ORDER BY and LIMIT clauses."
  },
  {
    "id": 1778,
    "db_id": "workshop_paper",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the author with the highest score, but Gen includes an extra column (so_diem) in SELECT that wasn't explicitly requested in Gold. This is a minor cosmetic difference that doesn't change the main answer."
  },
  {
    "id": 1779,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 1780,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count records grouped by the same column from the same table, with only cosmetic differences in formatting and whitespace."
  },
  {
    "id": 1781,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the university with the highest submission count, differing only in cosmetic formatting (keyword case and whitespace)."
  },
  {
    "id": 1782,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the university with the most submissions, differing only in cosmetic formatting and whitespace."
  },
  {
    "id": 1783,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same tables, same INTERSECT operation, same WHERE conditions with identical numeric values, and only differ in cosmetic formatting (keyword case)."
  },
  {
    "id": 1784,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return universities with both high (>90) and low (<80) scores, using different but semantically equivalent approaches: Gen uses GROUP BY with conditional sums, Gold uses INTERSECT of two subqueries."
  },
  {
    "id": 1785,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform an INNER JOIN between the same two tables with equivalent join conditions, selecting the same columns with only table alias differences."
  },
  {
    "id": 1786,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform an INNER JOIN between the same two tables with the same join condition, selecting the same columns. The only differences are table aliases and formatting, which are cosmetic."
  },
  {
    "id": 1787,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same tables with identical JOIN conditions and ORDER BY logic, differing only in table aliases and formatting."
  },
  {
    "id": 1788,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same tables with identical JOIN conditions and ORDER BY logic, differing only in table aliases and formatting."
  },
  {
    "id": 1789,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with equivalent conditions, select the same columns with the same aggregation, and group by the same column. The only differences are cosmetic (aliases, formatting, and JOIN order)."
  },
  {
    "id": 1790,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and table references. Both count distinct conference IDs per author from the same join between the same tables with the same join condition."
  },
  {
    "id": 1791,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries have identical semantic structure: they join the same tables with the same condition, group by the same column, and apply the same HAVING condition with identical aggregation logic."
  },
  {
    "id": 1792,
    "db_id": "workshop_paper",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen counts all rows per author, Gold counts distinct conferences per author with HAVING condition >1. Different ORDER BY/LIMIT vs HAVING clause."
  },
  {
    "id": 1793,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same table with identical ORDER BY logic (ASC is default). The only differences are cosmetic: keyword case and whitespace."
  },
  {
    "id": 1794,
    "db_id": "workshop_paper",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same table with identical ORDER BY logic. The differences are purely cosmetic (keyword case, whitespace, and optional ASC keyword)."
  },
  {
    "id": 1797,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The queries reference different columns in the WHERE clause - 'danh_gia_xep_hang' vs 'ddanh_gia_xep_hang' (likely a typo in Gold). This is a semantic difference that will produce different results."
  },
  {
    "id": 1798,
    "db_id": "yelp",
    "strict_match": false,
    "score": 0,
    "reason": "The queries reference different columns: 'danh_gia_xep_hang' vs 'ddanh_gia_xep_hang'. This is a semantic difference that will produce different results on any database."
  },
  {
    "id": 1799,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case in the string value ('Michelle' vs 'michelle'), which SQLite treats as different values but are considered equivalent under the normalization rules."
  },
  {
    "id": 1800,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "Different columns selected (thanh_pho vs tieu_bang) and different WHERE conditions (ten = 'Whataburger' vs ten = 'whataburger') - these are semantic differences that would return different results."
  },
  {
    "id": 1801,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The queries have fundamentally different structures: Gen queries only the 'doanh_nghiep' table with a specific name filter, while Gold joins 'doanh_nghiep' with 'loai_hinh' and adds an additional filter on 'ten_loai_hinh'. They would return different results on most database states."
  },
  {
    "id": 1802,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The Gold query references a non-existent column 'ddanh_gia_xep_hang' (with extra 'd'), while the Generated query correctly uses 'danh_gia_xep_hang'. This is a semantic difference that will cause the Gold query to fail or return different results."
  },
  {
    "id": 1803,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same column selection, same WHERE condition with equivalent string values (case-insensitive comparison). Only differences are cosmetic: keyword case, string literal quotes, and letter case in the literal value."
  },
  {
    "id": 1804,
    "db_id": "yelp",
    "strict_match": false,
    "score": 0,
    "reason": "The Gold query references a non-existent column 'ddanh_gia_xep_hang' (typo with extra 'd'), while the Generated query correctly uses 'danh_gia_xep_hang'. These are different columns that would return different results."
  },
  {
    "id": 1805,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query selects from only one table with a simple WHERE condition, while Gold query joins two tables with an additional filter on the second table. These will return different results on most database states."
  },
  {
    "id": 1806,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query selects from only one table (doanh_nghiep) while Gold query joins two tables (doanh_nghiep and loai_hinh) with additional filtering on loai_hinh.ten_loai_hinh = 'restaurant', which fundamentally changes the result set."
  },
  {
    "id": 1807,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE clauses, differing only in table aliases and formatting."
  },
  {
    "id": 1808,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause filtering for the same customer name. The only differences are cosmetic: table aliases, keyword case, and whitespace formatting."
  },
  {
    "id": 1809,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The Gold query has a syntax error with column name 'ddanh_gia_xep_hang' (typo), while Gen uses correct 'danh_gia_xep_hang'. Additionally, Gold uses double quotes for string literal while Gen uses single quotes, but the main issue is the invalid column reference."
  },
  {
    "id": 1810,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different table joins and WHERE conditions: Gen joins 4 tables with specific conditions while Gold joins 5 tables with different conditions, including different string values ('nhà hàng Ý' vs 'italian' and 'category category name1') that are not equivalent."
  },
  {
    "id": 1811,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses only danh_gia and doanh_nghiep, Gold adds loai_hinh) and different WHERE conditions (Gen checks thanh_pho='Texas', Gold checks tieu_bang='Texas' and adds ten_loai_hinh='restaurant'). Also, Gold uses COUNT(DISTINCT van_ban) while Gen uses COUNT(*)."
  },
  {
    "id": 1812,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Gold query has different JOIN logic (joins loai_hinh twice with different conditions) and WHERE conditions (requires both 'italian' and 'restaurant' types), while Gen only requires 'Ý' type. Also Gold has a typo 'ddanh_gia_xep_hang' vs 'danh_gia_xep_hang'."
  },
  {
    "id": 1813,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Gold query joins loai_hinh table twice with different aliases (t3 and t4) and requires both 'italian' AND 'restaurant' conditions, while Gen query joins loai_hinh only once and requires 'nhà hàng Ý' (Italian restaurant) condition. These represent different semantic filtering logic."
  },
  {
    "id": 1814,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gold includes additional filter on city (t2.thanh_pho = 'madison') and requires two different loai_hinh conditions, while Gen only requires one loai_hinh condition. Different JOIN structure: Gold joins loai_hinh twice with different aliases, while Gen joins loai_hinh once and danh_gia once."
  },
  {
    "id": 1815,
    "db_id": "yelp",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions: Gen filters on 'thanh_pho = Pennsylvania' while Gold filters on 'tieu_bang = pennsylvania' (city vs state). Also different SELECT columns: Gen returns 10 columns while Gold returns only 'ten'."
  },
  {
    "id": 1816,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen filters by 'thanh_pho = Pennsylvania' while Gold filters by 'tieu_bang = pennsylvania' (city vs state). Also Gen selects many columns while Gold selects only 'ten'."
  },
  {
    "id": 1817,
    "db_id": "yelp",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: both join the same three tables with equivalent conditions, and the WHERE clause values 'chải chuốt cho vật nuôi' and 'pet groomers' are Vietnamese-English equivalents for the same real-world meaning."
  },
  {
    "id": 1818,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query selects from only one table with a simple WHERE condition, while Gold query joins two tables with additional filtering on the second table. These will return different results on any database where breweries exist in Los Angeles."
  },
  {
    "id": 1819,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different structures: Gen queries only the 'doanh_nghiep' table with a simple WHERE condition, while Gold performs a JOIN between 'doanh_nghiep' and 'loai_hinh' tables with additional filtering on 'ten_loai_hinh'. They would return different results on most database states."
  },
  {
    "id": 1820,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "The queries have different WHERE conditions (ten_loai_hinh = 'Brewery' vs ten_loai_hinh = 'breweries') and different SELECT columns (Gen returns 9 columns vs Gold returns only 'ten')."
  },
  {
    "id": 1821,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different table sets and WHERE conditions - Gen uses only 3 tables with no loai_hinh table, while Gold uses 4 tables with additional filtering on loai_hinh.ten_loai_hinh = 'restaurant'."
  },
  {
    "id": 1822,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences: column order in WHERE clause, keyword case, and string literal quoting style."
  },
  {
    "id": 1823,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen doesn't include loai_hinh table) and different WHERE conditions (Gen missing ten_loai_hinh = 'restaurant' filter). These are semantic differences that would produce different results."
  },
  {
    "id": 1824,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Gold query includes an additional table 'loai_hinh' with condition 'ten_loai_hinh = \"restaurant\"' that is not present in the generated query, making the WHERE logic different. The generated query filters only by city and consumer name, while gold query also filters by business type."
  },
  {
    "id": 1825,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses only 3 tables, Gold uses 4 tables including 'loai_hinh') and different WHERE conditions (Gen filters only by name, Gold filters by both name and business type)."
  },
  {
    "id": 1826,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different table sets and WHERE conditions: Gen uses only 3 tables with a consumer name filter, while Gold uses 4 tables with additional business type filter and has a typo in column name."
  },
  {
    "id": 1827,
    "db_id": "yelp",
    "strict_match": true,
    "score": 98,
    "reason": "Queries are semantically equivalent after normalizing aliases, ignoring case, and treating the Vietnamese-accented string value 'Barrio Café' as equivalent to 'barrio cafe'. Both queries join the same three tables with equivalent join conditions and apply identical WHERE filters."
  },
  {
    "id": 1828,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different WHERE conditions: Gen uses 'thanh_pho = Texas' while Gold uses 'tieu_bang = texas' (different column names and values). Different SELECT columns: Gen selects all columns (*) while Gold selects only 'ten'."
  },
  {
    "id": 1829,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Gold query requires businesses to have BOTH 'seafood' AND 'restaurant' types, while Gen query only requires 'hải sản' (seafood). Even though 'hải sản' = 'seafood' semantically, the logic differs significantly."
  },
  {
    "id": 1830,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE logic: Gen requires 'hải sản' (seafood) only, while Gold requires both 'seafood' AND 'restaurant' types for the same business. Different SELECT columns: Gen returns 10 columns, Gold returns only 'ten' (name)."
  },
  {
    "id": 1831,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE logic: Gen requires 'Hải sản' (seafood) business type only, while Gold requires both 'seafood' AND 'restaurant' business types for the same business. Different SELECT columns: Gen returns 10 columns, Gold returns only 'ten' (name)."
  },
  {
    "id": 1832,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The WHERE conditions differ: Gen uses 'danh_gia.danh_gia_xep_hang > 4' while Gold uses 't1.ddanh_gia_xep_hang > 4' (typo in column name). This is a semantic difference that affects results."
  },
  {
    "id": 1833,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different SELECT columns (ten, thanh_pho vs id_doanh_nghiep) and different WHERE conditions (ten = 'Apple' vs ten = 'apple store'). These are semantic differences that would produce different result sets."
  },
  {
    "id": 1834,
    "db_id": "yelp",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries join the same tables with the same join condition and filter for businesses in Dallas with rating > 4.5, but Gen selects many more columns while Gold only selects 'ten'. Additionally, Gold has a typo in 'ddanh_gia_xep_hang' which should be 'danh_gia_xep_hang'."
  },
  {
    "id": 1835,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Generated query joins only 2 tables (doanh_nghiep and khu_vuc_lan_can) while Gold query joins 3 tables (including loai_hinh with additional condition). The WHERE clauses differ significantly - Gold has an extra condition filtering by loai_hinh.ten_loai_hinh."
  },
  {
    "id": 1836,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with identical conditions and return the same column."
  },
  {
    "id": 1837,
    "db_id": "yelp",
    "strict_match": false,
    "score": 50,
    "reason": "Different table aliases cause different column selections (T1.van_ban vs t2.van_ban), which refer to different tables after alias swapping. The WHERE conditions use different string values ('cung điện Kabob' vs 'kabob palace') that are not equivalent translations."
  },
  {
    "id": 1838,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and filter on the same city value (case-insensitive 'Dallas'). The only differences are cosmetic: table aliases, column aliases, keyword case, and single vs double quotes."
  },
  {
    "id": 1839,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The queries access different tables and have different filtering conditions. Generated query only uses 'doanh_nghiep' table with different WHERE conditions, while Gold query joins 'doanh_nghiep' with 'loai_hinh' and includes additional filters."
  },
  {
    "id": 1840,
    "db_id": "yelp",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same tables with equivalent conditions and filter on the same column with semantically equivalent values ('chải chuốt cho thú nuôi' = 'pet groomers'). The only differences are table aliases and JOIN order, which are cosmetic."
  },
  {
    "id": 1841,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen uses 'thanh_pho' column while Gold uses 'tieu_bang' column. These are different columns with potentially different meanings (city vs state)."
  },
  {
    "id": 1842,
    "db_id": "yelp",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same four tables with equivalent join conditions and filter for the same semantic concept ('restaurant' = 'nhà hàng'), differing only in table aliases and English/Vietnamese string literal values."
  },
  {
    "id": 1843,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen uses 'thanh_pho' column while Gold uses 'tieu_bang' column. These are different columns with potentially different meanings (city vs state)."
  },
  {
    "id": 1844,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "Generated query joins only nguoi_tieu_dung and danh_gia tables with year condition, while Gold query involves additional tables (loai_hinh and doanh_nghiep) with extra filtering for restaurant type. These are fundamentally different queries with different table structures and filtering logic."
  },
  {
    "id": 1845,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen filters on T2.nam = 2012 while Gold filters on t1.nam = 2012. Different JOIN structure: Gen joins danh_gia with khoan_tien_boa directly, while Gold joins nguoi_tieu_dung with both tables separately."
  },
  {
    "id": 1846,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query selects from only 'danh_gia' table with condition on 'danh_gia_xep_hang', while Gold query joins 'danh_gia' with 'doanh_nghiep' table and applies condition on 'ddanh_gia_xep_hang' from the 'doanh_nghiep' table. These are fundamentally different table structures and filtering conditions."
  },
  {
    "id": 1847,
    "db_id": "yelp",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic: Gen counts all rows with COUNT(*), Gold counts distinct names with COUNT(DISTINCT t1.ten). Different WHERE conditions: Gen uses 'trò chơi trốn thoát', Gold uses 'escape games' - these are not equivalent values in the provided mapping."
  },
  {
    "id": 1848,
    "db_id": "yelp",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic: Gen uses COUNT(*) while Gold uses COUNT(DISTINCT t1.ten). Different WHERE conditions: 'trò chơi trốn thoát' vs 'escape games' are not equivalent values."
  },
  {
    "id": 1849,
    "db_id": "yelp",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic (COUNT(*) vs COUNT(DISTINCT ten)) and different WHERE conditions (different string values that are not equivalent in meaning)."
  },
  {
    "id": 1850,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic (COUNT(*) vs COUNT(DISTINCT ten)) and different JOIN conditions (CAST vs direct join). The WHERE conditions are semantically equivalent after normalizing Vietnamese/English values."
  },
  {
    "id": 1851,
    "db_id": "yelp",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic: Gen uses COUNT(*) while Gold uses COUNT(DISTINCT t1.ten). Also different WHERE conditions: 'trò chơi trốn thoát' vs 'escape games' are not equivalent values."
  },
  {
    "id": 1852,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query counts all businesses with rating > 3.5, while Gold query counts distinct business names only for restaurants with rating > 3.5. Different tables, JOIN conditions, and WHERE filters make them semantically different."
  },
  {
    "id": 1853,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different WHERE conditions: Gen filters for 'Ma-rốc' (Moroccan) business type, while Gold filters for both 'restaurant' AND 'moroccan' business types. Additionally, Gold has duplicate JOINs to the loai_hinh table with different aliases and conditions."
  },
  {
    "id": 1854,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen has 2 conditions (city='Los Angeles', type='Ma-rốc', day contains 'Fri'), Gold has 4 conditions (city='los angeles', type='moroccan', type='restaurant', day='friday'). Gold requires both 'moroccan' AND 'restaurant' types, while Gen only requires 'Ma-rốc' type."
  },
  {
    "id": 1855,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Gold query has an extra JOIN condition (t3.ten_loai_hinh = 'restaurant') and different WHERE logic (AND vs OR semantics), while Gen only filters for 'Ma-rốc'/'moroccan'. These are semantic differences that can produce different results."
  },
  {
    "id": 1856,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "The queries use different tables and WHERE conditions: Gen filters on doanh_nghiep.ten='Italian Delis' and ngay LIKE '%Sunday%', while Gold joins with loai_hinh twice to filter on ten_loai_hinh='italian' and 'delis' separately, and uses exact match ngay='sunday'."
  },
  {
    "id": 1857,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Generated query counts all rows while Gold query counts distinct documents (van_ban). Different aggregation logic leads to potentially different results."
  },
  {
    "id": 1858,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The Gold query references a non-existent column 'ddanh_gia_xep_hang' (typo with double 'd'), while Gen uses correct column 'danh_gia_xep_hang'. This is a semantic difference that will cause Gold to fail on any database."
  },
  {
    "id": 1859,
    "db_id": "yelp",
    "strict_match": false,
    "score": 50,
    "reason": "Gen uses SUM aggregation while Gold selects individual rows; Gen sums all matching quantities while Gold returns each quantity separately."
  },
  {
    "id": 1860,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables involved (Gen uses 2 tables, Gold uses 3 tables) and different aggregation columns (Gen counts distinct users, Gold counts distinct user names). These are semantic differences that affect results."
  },
  {
    "id": 1861,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The queries have fundamentally different structures: Gen queries a single table with a filter on rating > 4.5, while Gold joins two tables with a filter on rating = 4.5 and an additional condition on restaurant type."
  },
  {
    "id": 1862,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The queries use different tables (danh_gia vs none) and count different columns (all rows vs distinct van_ban), leading to fundamentally different results."
  },
  {
    "id": 1863,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Gen query filters by id_doanh_nghiep = 'Niloofar' while Gold query filters by t2.ten = 'niloofar' after joining with nguoi_tieu_dung table. These are fundamentally different filtering conditions on different columns/tables."
  },
  {
    "id": 1864,
    "db_id": "yelp",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries calculate the same sum from the same tables with the same join logic and WHERE condition, but Gen uses CAST(doanh_nghiep.id_doanh_nghiep AS TEXT) while Gold uses direct column equality without CAST, which could produce different results if data types differ."
  },
  {
    "id": 1865,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Gold query includes an additional JOIN with table 'nguoi_tieu_dung' and an extra WHERE condition on 't3.ten', which fundamentally changes the result set by filtering based on a specific user name."
  },
  {
    "id": 1866,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables and columns: Gen uses 'danh_gia' table counting all rows, Gold uses 'khoan_tien_boa' table counting distinct 'van_ban' values. Different aggregation logic and different source tables."
  },
  {
    "id": 1867,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved (Gen uses danh_gia table, Gold doesn't) and different aggregation logic (COUNT(*) vs COUNT(DISTINCT van_ban)). These are fundamental semantic differences."
  },
  {
    "id": 1868,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different aggregation (COUNT(*) vs COUNT(DISTINCT t1.van_ban)) and different WHERE conditions (different column references and different string values that are not equivalent)."
  },
  {
    "id": 1869,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The queries have completely different structures: Gen counts all businesses in Texas city, while Gold counts distinct business names of restaurants in Texas state, involving an additional table join and different filtering conditions."
  },
  {
    "id": 1870,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query counts all businesses in Dallas with rating > 3.5, while Gold query counts distinct business names only for bars in Dallas with rating > 3.5, involving different tables and additional filtering."
  },
  {
    "id": 1871,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic (COUNT(*) vs COUNT(DISTINCT ten)) and different WHERE conditions (rating column name mismatch: danh_gia_xep_hang vs ddanh_gia_xep_hang)."
  },
  {
    "id": 1872,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query counts distinct users who reviewed a specific business, while Gold query counts distinct user names (ten) from a different table with additional filters including business type and state."
  },
  {
    "id": 1873,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query counts all reviews for a specific business in 2015, while Gold query counts distinct customer names who reviewed that business in 2015. They involve different tables and aggregation logic."
  },
  {
    "id": 1874,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables involved (Gold includes khu_vuc_lan_can table) and different aggregation (COUNT(*) vs COUNT(DISTINCT t1.ten)). The WHERE conditions also differ in string values ('nhà hàng' vs 'restaurant', '%Hazelwood%' vs 'hazelwood')."
  },
  {
    "id": 1875,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Gold query includes an additional condition (tieu_bang = 'texas') and uses COUNT(DISTINCT id_doanh_nghiep) instead of COUNT(*), which are semantically different as they count different things and have different filtering logic."
  },
  {
    "id": 1876,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables and columns: Gen queries danh_gia table with JOIN, Gold queries only doanh_nghiep table. Gen returns COUNT(*), Gold returns so_luong_ddanh_gia column."
  },
  {
    "id": 1877,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Generated query joins only luot_dang_ky and doanh_nghiep with a simple WHERE filter, while Gold query adds an extra join to loai_hinh with additional filtering for 'restaurant' and includes GROUP BY t3.ngay, making them semantically different."
  },
  {
    "id": 1878,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Gen uses COUNT(*) while Gold uses COUNT(DISTINCT t1.ten) - these count different things (all rows vs distinct names). The WHERE conditions and JOIN logic are otherwise equivalent."
  },
  {
    "id": 1879,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different aggregation logic: Gen counts all rows while Gold counts distinct values of a specific column (van_ban). Different tables/columns in SELECT clause."
  },
  {
    "id": 1880,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different aggregation logic (COUNT(*) vs COUNT(DISTINCT van_ban)) and different WHERE conditions (thang='3' vs thang='march') which are not equivalent values."
  },
  {
    "id": 1881,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "Gen counts distinct businesses, Gold counts distinct business names. Different aggregation logic with different columns in COUNT(DISTINCT)."
  },
  {
    "id": 1882,
    "db_id": "yelp",
    "strict_match": false,
    "score": 20,
    "reason": "The queries count different things: Gen counts distinct business IDs, while Gold counts distinct business names. These are fundamentally different aggregations that will produce different results unless business names are unique and map 1:1 with IDs."
  },
  {
    "id": 1883,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(*) while Gold uses COUNT(DISTINCT id_doanh_nghiep). These produce different results when duplicate id_doanh_nghiep values exist in matching rows."
  },
  {
    "id": 1884,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables and WHERE conditions: Gen uses only danh_gia and doanh_nghiep with LIKE filter, while Gold joins 4 tables with exact string match on loai_hinh.ten_loai_hinh."
  },
  {
    "id": 1885,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the average of the same column from the same table with the same WHERE condition. The only differences are cosmetic (whitespace, keyword case, and column name spelling with/without accents)."
  },
  {
    "id": 1886,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "The queries join different tables and have different WHERE conditions. Gen only joins danh_gia and doanh_nghiep with one filter, while Gold joins four tables with an additional filter on loai_hinh.ten_loai_hinh."
  },
  {
    "id": 1887,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have different aggregation logic: Gen counts all rows while Gold counts distinct values of 'van_ban' column. They also join tables in different orders and use different column references."
  },
  {
    "id": 1888,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "The queries have different aggregation logic: Gen counts all rows with ten='Michelle' while Gold counts distinct values of ten where ten='Michelle'. For a single value condition, COUNT(*) and COUNT(DISTINCT ten) can return different results if there are duplicate rows."
  },
  {
    "id": 1889,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different aggregation logic (COUNT(*) vs COUNT(DISTINCT ten)) and different WHERE conditions (different string values that are not equivalent)."
  },
  {
    "id": 1890,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct cities from the same table with the same filtering condition, with only minor cosmetic differences in keyword case and string literal quotes."
  },
  {
    "id": 1891,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (danh_gia vs nguoi_tieu_dung) and different aggregation logic (COUNT(*) vs COUNT(DISTINCT van_ban)). These are semantic differences that would produce different results on many database states."
  },
  {
    "id": 1892,
    "db_id": "yelp",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and JOIN order. Both compute the same sum from the same tables with equivalent JOIN conditions and WHERE clause."
  },
  {
    "id": 1893,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different aggregation logic: Gen uses COUNT(*) while Gold uses COUNT(DISTINCT van_ban). Different WHERE conditions: Gen filters by '3' while Gold filters by 'march' (not equivalent values)."
  },
  {
    "id": 1894,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen includes JOIN with danh_gia table, Gold does not) and different aggregation logic (Gen counts all rows, Gold counts distinct van_ban values). These are semantic differences that can produce different results."
  },
  {
    "id": 1895,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Gen counts all rows while Gold counts distinct neighborhood names; Gen has correct column name 'danh_gia_xep_hang' while Gold has typo 'ddanh_gia_xep_hang'."
  },
  {
    "id": 1896,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen filters for 'Ma-rốc' type in Texas city, Gold filters for 'moroccan' AND 'restaurant' types in Texas state. Different tables involved: Gold joins loai_hinh twice with different aliases."
  },
  {
    "id": 1897,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(luot_dang_ky.so_luong) while Gold uses SUM(t2.so_luong). Also different GROUP BY columns: Gen groups by id_doanh_nghiep while Gold groups by ten."
  },
  {
    "id": 1898,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(*) (counts all rows), Gold uses COUNT(DISTINCT t2.ten) (counts distinct names). These will produce different results when businesses have duplicate names in the same neighborhood."
  },
  {
    "id": 1899,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen filters for 'Mexico' type only, while Gold requires both 'mexican' AND 'restaurant' types. Different column selection: Gen selects 10 columns, Gold selects only 'ten'."
  },
  {
    "id": 1900,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have different WHERE conditions: Gen filters for 'Mexico' business type, while Gold filters for both 'mexican' AND 'restaurant' business types from the same table joined twice. Also, Gold has a typo 'ddanh_gia_xep_hang' and uses > instead of >= for rating."
  },
  {
    "id": 1901,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different logic: Gen uses LIKE '%dịch vụ đỗ xe%' with OR condition on doanh_nghiep.ten or loai_hinh.ten_loai_hinh, while Gold requires specific values 'valet service' AND 'restaurant' in separate loai_hinh joins. Also Gold has extra condition t1.tieu_bang = 'texas' not in Gen."
  },
  {
    "id": 1902,
    "db_id": "yelp",
    "strict_match": false,
    "score": 30,
    "reason": "Different WHERE conditions: Gold has additional filters on city and multiple business types, while Gen only filters on neighborhood and one business type. Different JOIN structure: Gold joins loai_hinh twice with different aliases for multiple type conditions."
  },
  {
    "id": 1903,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "The queries have different WHERE conditions: Gold uses 't1.so_luong_ddanh_gia > 30' while Gen uses 'so_luong_danh_gia >= 30' (different column name spelling and different operator). Also, Gold has 't1.ddanh_gia_xep_hang' vs Gen's 'danh_gia_xep_hang' (different column name spelling)."
  },
  {
    "id": 1904,
    "db_id": "yelp",
    "strict_match": false,
    "score": 40,
    "reason": "Gen counts all businesses matching one category ('Nhà hàng Ai Cập' = 'Egyptian restaurant'), while Gold counts distinct business names matching two separate categories ('restaurant' AND 'egyptian'). Different WHERE logic and aggregation (COUNT vs COUNT DISTINCT)."
  },
  {
    "id": 1905,
    "db_id": "yelp",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries join the same tables with equivalent conditions and filter on the same average rating threshold, but Gen includes id_nguoi_tieu_dung in SELECT and GROUP BY while Gold only uses ten. If ten is unique per customer, they are semantically equivalent."
  },
  {
    "id": 1906,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(*) on all rows, Gold uses COUNT(DISTINCT t2.van_ban) on distinct documents. Different GROUP BY columns: Gen groups by id_doanh_nghiep, Gold groups by ten (name)."
  },
  {
    "id": 1907,
    "db_id": "yelp",
    "strict_match": false,
    "score": 65,
    "reason": "Different GROUP BY columns (id_doanh_nghiep vs ten) and different COUNT expressions (COUNT(*) vs COUNT(DISTINCT t2.ten_loai_hinh)) lead to potentially different results."
  },
  {
    "id": 573,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same five tables with identical join conditions, just in a different order. The column selections are identical after normalizing aliases and table references."
  },
  {
    "id": 574,
    "db_id": "college_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries join the same five tables with equivalent join conditions, but Gen includes an extra column (ho_cua_nhan_vien) in SELECT that Gold doesn't have. All other aspects (tables, joins, conditions) are semantically equivalent."
  },
  {
    "id": 575,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column order. Both join the same four tables with identical conditions and select the same three columns."
  },
  {
    "id": 576,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same tables, same JOIN conditions, same columns (only column order differs, which is cosmetic), and same logic. All differences are cosmetic (aliases, formatting, column order)."
  },
  {
    "id": 577,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalization - same tables, same JOIN condition, same WHERE logic (IN vs OR with same values), and same columns (just different order)."
  },
  {
    "id": 578,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same tables with the same JOIN condition and filter for the same grade values ('A'/'C' vs 'a'/'c' - case difference ignored). The only differences are cosmetic: column order, table aliases, and IN vs OR syntax."
  },
  {
    "id": 579,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same four tables with equivalent join conditions and filter for the same department name ('Kế toán' vs 'accounting' are equivalent English/Vietnamese values). The only differences are column selection (Gen includes ho_cua_nhan_vien), aliases, and formatting."
  },
  {
    "id": 580,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same four tables with equivalent join conditions and filter for the same department name (English 'accounting' vs Vietnamese 'Kế toán' are equivalent values). The only differences are column selection order, table aliases, and language of the string literal."
  },
  {
    "id": 581,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses giao_su and nhan_vien directly, Gold uses lop_hoc as starting table) and different WHERE conditions (different department names that are not equivalent English/Vietnamese pairs)."
  },
  {
    "id": 582,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different table joins and WHERE conditions: Gen uses giao_su-khoa-nhan_vien with different join logic and WHERE value 'Hệ thống thông tin máy tính', while Gold uses lop_hoc-nhan_vien-giao_su-khoa with WHERE value 'computer info. systems'."
  },
  {
    "id": 583,
    "db_id": "college_1",
    "strict_match": true,
    "score": 99,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal formats. The only differences are cosmetic: table aliases, keyword case, and string literal representation (single vs double quotes, numeric vs string value for ma_lop)."
  },
  {
    "id": 584,
    "db_id": "college_1",
    "strict_match": true,
    "score": 99,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal formats. The only differences are cosmetic: table aliases, keyword case, and string literal formatting (single vs double quotes, numeric vs string value for ma_lop)."
  },
  {
    "id": 585,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases, keyword case, and English/Vietnamese string value equivalents ('Lịch sử' = 'history', 'Tiến sĩ' = 'ph.d.')."
  },
  {
    "id": 586,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query joins giao_su with khoa directly, while Gold query joins giao_su with nhan_vien first, then with khoa. The WHERE conditions use different string values ('Lịch sử' vs 'history', 'Tiến sĩ' vs 'ph.d.'), but even with language equivalence, the table structures differ fundamentally."
  },
  {
    "id": 587,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (giao_su vs nhan_vien) and different columns selected (ho_cua_nhan_vien, ten_cua_nhan_vien vs only ten_cua_nhan_vien). These are semantic differences that would produce different results."
  },
  {
    "id": 588,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN logic - Gen includes an extra JOIN to giao_su table and selects different columns, while Gold only joins lop_hoc with nhan_vien and selects different columns. The GROUP BY columns also differ (T3.ma_so_nhan_vien vs t1.ma_so_nhan_vien_cua_giao_su)."
  },
  {
    "id": 589,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return students with exactly one course registration, but Gen includes an extra column (ho_cua_sinh_vien) in SELECT that Gold doesn't request. The GROUP BY uses different columns (sinh_vien.ma_so_sinh_vien vs t2.ma_so_sinh_vien) but they're functionally equivalent due to the JOIN condition."
  },
  {
    "id": 590,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return students with exactly one course registration, but Gen includes an extra column (ho_cua_sinh_vien) and groups by different columns (T1.ma_so_sinh_vien vs t2.ma_so_sinh_vien), though these are functionally equivalent since they join on the same student ID."
  },
  {
    "id": 591,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and Vietnamese vs English string literal values ('Thống kê' vs 'statistics') that represent the same meaning."
  },
  {
    "id": 592,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and Vietnamese vs English string literal values ('Thống kê' vs 'statistics') which represent the same meaning."
  },
  {
    "id": 593,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return students with last names starting with 'S' enrolled in course 'ACCT-211', but Gen includes both first and last names while Gold only includes first name. This is a minor difference in selected columns."
  },
  {
    "id": 594,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different table joins and WHERE conditions: Gen uses khoa and khoa_hoc tables with ma_khoa joins, while Gold uses dang_ky_khoa_hoc and lop_hoc tables with ma_so_sinh_vien and ma_lop joins. The queries access different data relationships."
  },
  {
    "id": 595,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with no filtering or aggregation."
  },
  {
    "id": 596,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries return the same data: descriptions from trang_thai_cua_tai_lieu where the status code matches 'working'/'đang được xử lý'. The only differences are cosmetic (JOIN vs direct table access) and language equivalence in the WHERE clause value."
  },
  {
    "id": 597,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column, no filtering conditions, no aggregation. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 598,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 30,
    "reason": "Different table joins and WHERE conditions: Gen joins two tables with a condition on description value, while Gold queries single table with condition on type code. These would return different results in most database states."
  },
  {
    "id": 599,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with no filtering or aggregation."
  },
  {
    "id": 600,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case sensitivity in the string value ('UPS' vs 'ups'), which SQLite treats as equivalent in most configurations."
  },
  {
    "id": 601,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for keyword case (SELECT vs select), which is a cosmetic difference. Both queries select the same column from the same table with no filtering or aggregation."
  },
  {
    "id": 602,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case in the literal value ('ED' vs 'ed'), which SQLite treats as equivalent for string comparison."
  },
  {
    "id": 603,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 604,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE clauses, differing only in table aliases and formatting. The WHERE clause uses the same string value 'Koby' (case-insensitive in SQLite string comparison)."
  },
  {
    "id": 605,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are identical except for cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are ignored per the rules."
  },
  {
    "id": 606,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries join the same tables with the same condition and return the same columns, but Gen groups by T1.ma_vai_tro while Gold groups by t2.ma_vai_tro. Since these are the same column from different aliases, they are functionally equivalent."
  },
  {
    "id": 607,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with equivalent conditions, group by the same column, and use equivalent aggregation (COUNT(*) vs COUNT(nhan_vien.id_nhan_vien) when id_nhan_vien is non-null)."
  },
  {
    "id": 608,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same tables, same JOIN condition, same WHERE clause, same SELECT column. Only difference is JOIN order which doesn't affect results in INNER JOIN."
  },
  {
    "id": 609,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen filters by description text 'Đã được hoàn thành' via JOIN, while Gold filters by status code 'done' directly on tai_lieu table. These are not semantically equivalent conditions."
  },
  {
    "id": 610,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 611,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only language differences in WHERE clause values: 'Đã được hoàn thành' = 'done' and 'Giấy' = 'paper'."
  },
  {
    "id": 612,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same tables, same JOIN condition, same WHERE clause, same SELECT columns. Only difference is table order in FROM clause and keyword case, which are cosmetic."
  },
  {
    "id": 613,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalization - same tables, same JOIN condition, same WHERE condition with equivalent string values (USPS vs usps), and same aggregation."
  },
  {
    "id": 614,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the same top delivery agent, but Gen includes only the name while Gold includes both name and count. This is a minor difference where Gen adds extra aggregation not explicitly requested."
  },
  {
    "id": 615,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column from the same table with the same WHERE condition, differing only in table alias usage and keyword case."
  },
  {
    "id": 616,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same chi_tiet_dia_chi values by joining dia_chi and tai_lieu_duoc_gui tables with the same join condition and filtering on id_tai_lieu = 4. The Gen query includes an extra join to tai_lieu table, but this doesn't change the result since it's filtered to the same id_tai_lieu = 4 condition."
  },
  {
    "id": 617,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 50,
    "reason": "The generated query includes an unnecessary JOIN with the 'tai_lieu' table that doesn't add any filtering or additional columns beyond what's already available in 'tai_lieu_duoc_gui'. The gold query directly selects from 'tai_lieu_duoc_gui' with the same WHERE condition."
  },
  {
    "id": 618,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return documents with status 'done/completed', type 'paper', and exclude those shipped by USPS. The Gen query uses explicit JOINs with string comparisons while Gold uses EXCEPT with value comparisons, but they are semantically equivalent."
  },
  {
    "id": 619,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return documents with status 'done/completed', type 'paper', and carrier 'USPS'. The Gen query uses explicit JOINs with string comparisons, while Gold uses INTERSECT with ID comparisons, but they are semantically equivalent."
  },
  {
    "id": 620,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same chi_tiet_du_thao values for id_tai_lieu = 7. The JOIN in the generated query is redundant since it doesn't add any filtering or columns from the tai_lieu table."
  },
  {
    "id": 621,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables (ban_du_thao_cua_tai_lieu vs ban_sao) and different columns selected (so_luong_du_thao vs count(*)). These are fundamentally different queries that would return different results on most database states."
  },
  {
    "id": 622,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic (SUM vs COUNT) and different table joins (Gen joins with tai_lieu table while Gold only uses ban_sao). These are semantic differences that can produce different results."
  },
  {
    "id": 623,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 40,
    "reason": "Different table joins and WHERE/HAVING conditions: Gen joins tai_lieu table and filters on so_luong_ban_sao column value, while Gold only uses ban_sao table and filters on count aggregation."
  },
  {
    "id": 624,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE clauses, selecting the same column. The only differences are cosmetic: table aliases, keyword case, and whitespace."
  },
  {
    "id": 625,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return employees who have no travel history, using NOT IN vs EXCEPT with JOIN. EXCEPT is the preferred SQL pattern for set exclusion, making Gen slightly better."
  },
  {
    "id": 626,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 65,
    "reason": "Different GROUP BY logic: Gen groups by employee ID only, Gold groups by document ID, draft quantity, and copy quantity. This changes which rows are aggregated together."
  },
  {
    "id": 627,
    "db_id": "cre_Doc_Control_Systems",
    "strict_match": false,
    "score": 40,
    "reason": "The queries use different aggregation logic (COUNT(*) vs COUNT(DISTINCT id_nhan_vien)) and different table joins (Gen joins with tai_lieu table while Gold doesn't). These are semantic differences that can produce different results."
  },
  {
    "id": 628,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 629,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 630,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for keyword case (SELECT vs select), which is a cosmetic difference that does not affect the results."
  },
  {
    "id": 631,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with no filtering or aggregation. The only differences are cosmetic: keyword case (SELECT vs select) and table alias usage in the generated query."
  },
  {
    "id": 632,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 633,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 634,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 0,
    "reason": "The queries reference different tables (khach_hang vs khach_hang_1), which are semantically distinct and will produce different results on any database state."
  },
  {
    "id": 635,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 20,
    "reason": "The generated query counts rows from two tables and unions them, while the gold query only counts rows from one table. These will return different results unless both tables have exactly the same number of rows."
  },
  {
    "id": 636,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition. The differences are purely cosmetic: keyword case, whitespace, and single vs double quotes around the same string value."
  },
  {
    "id": 637,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences: column order in SELECT, keyword case, and single vs double quotes for string literal (both refer to same value 'Harold')."
  },
  {
    "id": 638,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 30,
    "reason": "The queries involve different tables and JOIN logic - Gen joins three tables while Gold only selects from one table. They would return different results on most database states."
  },
  {
    "id": 639,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 30,
    "reason": "The queries join different tables: Gen joins cua_hang with nhom_hoi_thao_kich, while Gold selects only from nhom_hoi_thao_kich. This creates different result sets as Gen requires matching records between both tables, whereas Gold returns all records from nhom_hoi_thao_kich regardless of cua_hang."
  },
  {
    "id": 640,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate MIN, AVG, and MAX of the same column from the same table with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 641,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate MIN, AVG, and MAX of the same column from the same table with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 642,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The DISTINCT keyword in Gold SQL is redundant since SELECT without DISTINCT already returns unique values when querying a single column, making both queries semantically identical."
  },
  {
    "id": 643,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return distinct payment method codes from the hoa_don table, but Gen includes an unnecessary JOIN to phuong_thuc_thanh_toan table that doesn't add filtering or change the result set. The JOIN is redundant since it only matches on the same column being selected."
  },
  {
    "id": 644,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical - both select the same column from the same table with the same filtering condition. The only difference is the language of the string literal value ('Trung Quốc' vs 'China'), which represent the same real-world meaning according to the Vietnamese-English value equivalence rules."
  },
  {
    "id": 645,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical except for the WHERE clause value 'Trung Quốc' (Vietnamese) vs 'china' (English), which represent the same real-world country according to Rule 5 about Vietnamese-English value equivalence."
  },
  {
    "id": 646,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select product names where price exceeds the average price from the same table. The only differences are cosmetic: DISTINCT keyword in Gold and formatting/whitespace."
  },
  {
    "id": 647,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select product names where price exceeds the average price from the same table. The only differences are cosmetic: DISTINCT keyword in Gold (which doesn't affect results since the subquery comparison ensures uniqueness) and formatting/whitespace variations."
  },
  {
    "id": 648,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are ignored according to the rules."
  },
  {
    "id": 649,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored per the rules."
  },
  {
    "id": 650,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 651,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same ordering. The only differences are cosmetic (keyword case and formatting), which should be ignored."
  },
  {
    "id": 652,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same column selection, same WHERE condition with equivalent string values (case-insensitive comparison), only differences are cosmetic (keyword case, single vs double quotes)."
  },
  {
    "id": 653,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same column selection, same WHERE condition with equivalent string values (case-insensitive comparison), only differences are cosmetic (keyword case, quote style)."
  },
  {
    "id": 654,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen joins three tables and counts distinct order IDs from luot_dat_hang, while Gold only queries hoa_don table and counts all rows. These would return different results when payment methods have multiple invoices or orders."
  },
  {
    "id": 655,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "Gen query joins additional table 'luot_dat_hang' and uses DISTINCT count on different column, while Gold query only aggregates from 'hoa_don' table with simple COUNT(*). These are semantically different operations that could produce different results."
  },
  {
    "id": 656,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "Gen query includes JOIN with luot_dat_hang table while Gold query only uses hoa_don table. This creates different semantic logic - Gen only counts payment methods for orders that have corresponding booking records, while Gold counts all payment methods in hoa_don regardless of booking existence."
  },
  {
    "id": 657,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same payment method with highest frequency; the JOIN in Gen is redundant since ma_phuong_thuc_thanh_toan is already in hoa_don table, making them semantically equivalent."
  },
  {
    "id": 658,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE condition values: 'FJM Filming' vs 'fja filming' are not semantically equivalent English/Vietnamese pairs. Different table aliases and JOIN order are cosmetic differences."
  },
  {
    "id": 659,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with the same conditions and select the same column."
  },
  {
    "id": 660,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries join the same tables with the same condition and filter on the same column with equivalent values, but Gen selects an extra column (thanh_pho_thi_tran) that Gold does not include."
  },
  {
    "id": 661,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries join the same tables with the same conditions and filter on the same column with equivalent values ('CA' vs 'ca'), but Gen selects two columns while Gold selects only one. The extra column in Gen doesn't change the main answer but creates a different result structure."
  },
  {
    "id": 662,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 99,
    "reason": "Queries are semantically identical after normalizing aliases, case, and JOIN direction. The only minor difference is the string literal value 'Rob Dinning' vs 'rob dinning' (case difference), which is treated as a cosmetic difference."
  },
  {
    "id": 663,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and JOIN conditions. The only differences are cosmetic: table aliases, keyword case, and single vs double quotes."
  },
  {
    "id": 664,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are table aliases (t1/t2 vs none) and keyword case, which are cosmetic per rules."
  },
  {
    "id": 665,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are table aliases (t1/t2 vs none) and keyword case, which are cosmetic variations that don't affect the result set."
  },
  {
    "id": 666,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column order. Both join the same tables with the same condition, group by the same column, and count the same rows."
  },
  {
    "id": 667,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries count services by type but Gen includes extra GROUP BY column (mo_ta_ve_loai_dich_vu) and different column order in SELECT, while Gold groups only by ma_loai_dich_vu. Since mo_ta_ve_loai_dich_vu is functionally dependent on ma_loai_dich_vu (primary key), they return semantically equivalent results with minor cosmetic differences."
  },
  {
    "id": 668,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, column order, and formatting. Both select the same columns from the same tables with identical JOIN conditions, GROUP BY, ORDER BY, and LIMIT clauses."
  },
  {
    "id": 669,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences in column order and alias naming. Both queries join the same tables with the same condition, group by the same column, and order by the same aggregate function."
  },
  {
    "id": 670,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries join the same tables with the same join condition, but Gen has an extra WHERE clause (dich_vu.id_nhom_hoi_thao_kich IS NOT NULL) that is redundant since the INNER JOIN already ensures non-null matches. This makes them semantically equivalent in practice but technically different."
  },
  {
    "id": 671,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query has an extra WHERE condition (dich_vu.id_nhom_hoi_thao_kich IS NOT NULL) that filters out rows, while the Gold query returns all joined rows without filtering. This creates different result sets."
  },
  {
    "id": 672,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical except for the string literal value in the WHERE clause ('phim' vs 'film'), which are English/Vietnamese equivalents for the same real-world meaning."
  },
  {
    "id": 673,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: different column selection order, table aliases, and English vs Vietnamese string values ('phim' vs 'film') which represent the same meaning."
  },
  {
    "id": 674,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 30,
    "reason": "Gold query uses aggregation (AVG) with GROUP BY, while Gen query selects individual rows without aggregation. These will return different result sets - Gold returns one row per product with average price, Gen returns all rows with individual prices."
  },
  {
    "id": 675,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 95,
    "reason": "Both queries calculate average price grouped by product, but GROUP BY id_san_pham vs ten_san_pham are semantically equivalent if product name is functionally dependent on product ID (common in normalized databases)."
  },
  {
    "id": 676,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "Gen filters individual products by price, while Gold groups products by name and filters groups by average price. These can return different results when multiple products share the same name with varying prices."
  },
  {
    "id": 677,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "Gen filters individual products by price, while Gold groups products by name and filters groups by average price. These can return different results when multiple products share the same name with varying prices."
  },
  {
    "id": 678,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables and JOIN conditions: Gen uses dich_vu, dich_vu_dat_hang, mat_hang_trong_hoa_don with LIKE '%ảnh%' on mo_ta_ve_san_pham, while Gold uses mat_hang_duoc_dat, cac_san_pham with = 'photo' on ten_san_pham. The queries filter different data sources with different conditions."
  },
  {
    "id": 679,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions use different string values ('ảnh' vs 'photo') that are not listed as English/Vietnamese equivalents in the rules, and there's no indication they share the same real-world meaning. This creates a semantic difference in filtering criteria."
  },
  {
    "id": 680,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables involved (Gen uses 3 tables with luot_dat_hang, Gold uses 2 tables) and different columns selected (Gen selects 7 columns from all tables, Gold selects only chi_tiet_khac_ve_mat_hang from mat_hang_duoc_dat)."
  },
  {
    "id": 681,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 30,
    "reason": "The queries select completely different columns and tables - Gen selects 6 columns from 3 joined tables while Gold selects only 1 column from 2 joined tables. They also have different WHERE conditions and join structures."
  },
  {
    "id": 682,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and treating string literal '1' as equivalent to numeric 1. Both join the same tables with the same condition and select the same column."
  },
  {
    "id": 683,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries have identical structure and join logic, but differ in WHERE clause: Gen uses string literal '1' while Gold uses numeric 1. In SQLite, string '1' and integer 1 are not strictly equivalent in comparisons."
  },
  {
    "id": 684,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 40,
    "reason": "Different aggregation logic (HAVING with SUM vs WHERE with simple comparison) and different table/column names that don't appear to be equivalent."
  },
  {
    "id": 685,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 40,
    "reason": "Different aggregation logic: Gen uses GROUP BY with HAVING on sum of price*quantity, while Gold uses WHERE on price only without aggregation. Different tables: Gen joins 'hoa_don' while Gold joins 'mat_hang_duoc_dat'."
  },
  {
    "id": 686,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of ma_tien_te from the same table nhom_hoi_thao_kich with no filtering conditions."
  },
  {
    "id": 687,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "Gen counts all rows while Gold counts distinct currency codes, which are fundamentally different aggregations that can produce different results on any database state."
  },
  {
    "id": 688,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and filter on the same column with the same value, differing only in table aliases and formatting."
  },
  {
    "id": 689,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and filter on the same column with the same value, differing only in table aliases and formatting."
  },
  {
    "id": 690,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 30,
    "reason": "Different WHERE conditions: Gen filters on 'thanh_pho_thi_tran = Alaska' while Gold filters on 'quan_hat = alaska'. These are different column names with different values, not just language equivalents."
  },
  {
    "id": 691,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 20,
    "reason": "Different WHERE conditions: Gen filters on 'thanh_pho_thi_tran = Alaska' while Gold filters on 'quan_hat = alaska'. These are different column names with different values, not just language equivalents."
  },
  {
    "id": 692,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and table order - both count records grouped by city/town from the same join between the same tables with the same join condition."
  },
  {
    "id": 693,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same condition, group by the same column, and count the same rows. The only differences are cosmetic (aliases, formatting, and table order in FROM clause)."
  },
  {
    "id": 694,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 695,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "Gen query joins with khu_vuc_tiep_thi table while Gold query only uses nhom_hoi_thao_kich table, which changes the semantics - Gen requires matching records in both tables while Gold doesn't."
  },
  {
    "id": 696,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return cities from addresses of customers but not performers using identical EXCEPT logic with same tables and join conditions, differing only in table aliases and column references."
  },
  {
    "id": 697,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query includes UNION with khach_hang and khach_hang_1 tables, while Gold only uses khach_hang_1. This creates different logic: Gen returns cities from customers in either table, Gold only from khach_hang_1."
  },
  {
    "id": 698,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the most frequent ma_trang_thai from luot_dat_hang using the same GROUP BY, ORDER BY, and LIMIT logic. The only differences are cosmetic (keyword case and whitespace around COUNT(*))."
  },
  {
    "id": 699,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the most frequent ma_trang_thai from luot_dat_hang using the same GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case and whitespace around COUNT(*))."
  },
  {
    "id": 700,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and English vs Vietnamese string values ('stop' vs 'dừng') which have the same meaning according to the equivalence rules."
  },
  {
    "id": 701,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and Vietnamese vs English string values ('dừng' vs 'stop') that represent the same status meaning."
  },
  {
    "id": 702,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "Different table names (khach_hang vs khach_hang_1) and different exclusion logic (NOT IN subquery vs EXCEPT with JOIN). These are semantic differences that could produce different results."
  },
  {
    "id": 703,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 65,
    "reason": "The queries use different exclusion logic: Gen uses NOT IN with a subquery on luot_dat_hang_cua_khach_hang, while Gold uses EXCEPT with a JOIN between luot_dat_hang and khach_hang_1. These are different tables and approaches, so they may not return identical results on all database states."
  },
  {
    "id": 704,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 65,
    "reason": "The Gen query joins with phuong_thuc_thanh_toan table and filters by mo_ta_ve_phuong_thuc_thanh_toan='Mastercard', while Gold filters directly on ma_phuong_thuc_thanh_toan='mastercard'. These are semantically different conditions that could return different results depending on the data relationship."
  },
  {
    "id": 705,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different logic: Gen joins with phuong_thuc_thanh_toan table and filters by description, while Gold filters directly by ma_phuong_thuc_thanh_toan value. These would return different results if ma_phuong_thuc_thanh_toan values don't match the description filter."
  },
  {
    "id": 706,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 50,
    "reason": "Gen query joins with cac_san_pham table while Gold query only uses hoa_don table, which could produce different results if there are products in cac_san_pham not referenced in hoa_don. The GROUP BY logic differs due to the additional table in Gen."
  },
  {
    "id": 707,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 20,
    "reason": "The queries select from different tables (mat_hang_duoc_dat vs hoa_don), which are semantically different entities. This is a fundamental structural difference that will produce different results on most database states."
  },
  {
    "id": 708,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen uses LIKE '%anh%' and LIKE '%phim%' on mo_ta_ve_san_pham column, while Gold uses exact equality ten_san_pham = 'photo' and ten_san_pham = 'film'. Different columns and different matching logic."
  },
  {
    "id": 709,
    "db_id": "cre_Drama_Workshop_Groups",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen uses LIKE '%ảnh%' OR LIKE '%phim%' on mo_ta_ve_san_pham column, while Gold uses INTERSECT with ten_san_pham = 'photo' and ten_san_pham = 'film' on different column."
  },
  {
    "id": 710,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 711,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 712,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "The queries join different tables - Gen joins both khach_hang and tai_khoan tables, while Gold only queries from tai_khoan. This creates different semantics as Gen counts distinct customers who have accounts, while Gold counts all distinct customers in the accounts table regardless of whether they exist in the customer table."
  },
  {
    "id": 713,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query joins with khach_hang table while Gold query doesn't, which creates different semantics - Gen counts distinct customers with accounts that have matching customer records, while Gold counts all distinct customers with accounts regardless of khach_hang table existence."
  },
  {
    "id": 714,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 715,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns, same selection logic, with only minor cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 716,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 20,
    "reason": "Different WHERE conditions with non-equivalent string values ('Mea Afghanistan' vs 'meaghan'), and different column order in SELECT clause."
  },
  {
    "id": 717,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 20,
    "reason": "Different WHERE conditions with non-equivalent string values ('Mea Afghanistan' vs 'meaghan'), and different column order in SELECT clause."
  },
  {
    "id": 718,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 20,
    "reason": "Different WHERE conditions with different string literal values that are not equivalent (English vs English but different names). The queries join the same tables but filter for different customers."
  },
  {
    "id": 719,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 30,
    "reason": "Different WHERE conditions: Gen filters on full name 'Mea Afghanistan Keeling' while Gold filters on first name 'meaghan' and last name 'keeling' separately. Different SELECT columns: Gen selects 6 columns including customer info while Gold selects only 2 account columns."
  },
  {
    "id": 720,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE clauses, differing only in table aliases and formatting."
  },
  {
    "id": 721,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 65,
    "reason": "Different SELECT columns: Gen selects only ten_khach_hang while Gold selects both ten_khach_hang and ho_cua_khach_hang. The JOIN logic and WHERE conditions are equivalent."
  },
  {
    "id": 722,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count customers without accounts using the same NOT IN subquery structure, with only minor whitespace and keyword case differences."
  },
  {
    "id": 723,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count customers without accounts using NOT IN with the same subquery structure, with only minor whitespace and formatting differences."
  },
  {
    "id": 724,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both select the same columns from the same tables with the same JOIN condition."
  },
  {
    "id": 725,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences in table aliases and formatting. Both select the same columns from the same tables with the same JOIN condition and DISTINCT modifier."
  },
  {
    "id": 726,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return customers who don't have accounts - NOT IN with subquery is semantically equivalent to EXCEPT for set exclusion, and EXCEPT is the preferred SQL pattern."
  },
  {
    "id": 727,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return customers who don't have accounts - NOT IN with subquery is semantically equivalent to EXCEPT for set exclusion, and EXCEPT is the preferred SQL pattern."
  },
  {
    "id": 728,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "Gen query joins khach_hang table while Gold query only uses tai_khoan table, resulting in different semantics - Gen counts customers with accounts while Gold counts all accounts regardless of customer existence."
  },
  {
    "id": 729,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 40,
    "reason": "The queries join different tables - Gen joins both khach_hang and tai_khoan tables, while Gold only queries the tai_khoan table. This creates different result sets as Gen requires matching records in both tables."
  },
  {
    "id": 730,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column references - both join khach_hang and tai_khoan on id_khach_hang, group by id_khach_hang, and select the same customer information ordered by count descending with limit 1."
  },
  {
    "id": 731,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the customer with the most accounts, but Gen selects only id and name while Gold includes an additional column (ho_cua_khach_hang). The core logic and result are identical except for this minor column difference."
  },
  {
    "id": 732,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return customer information with account counts, but Gen includes extra GROUP BY columns (ten_khach_hang, ho_cua_khach_hang) that are functionally dependent on id_khach_hang, making them semantically equivalent for most practical purposes."
  },
  {
    "id": 733,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries join the same tables with the same condition and group by customer ID, but Gold selects additional columns (ho_cua_khach_hang) and includes id_khach_hang in SELECT, while Gen only selects ten_khach_hang and COUNT(*). The main aggregation logic is equivalent."
  },
  {
    "id": 734,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column order. Both join the same tables with the same condition, group by the same column, and have identical HAVING clauses."
  },
  {
    "id": 735,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return customers with at least 2 accounts, using the same tables, join conditions, grouping logic, and HAVING clause. The differences are purely cosmetic (aliases, column order, whitespace)."
  },
  {
    "id": 736,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 737,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 738,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count customers grouped by gender, with only cosmetic differences in formatting and table prefix usage."
  },
  {
    "id": 739,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries group customers by gender and count them, but Gen returns only the count values while Gold returns both gender and count columns. The main answer (gender distribution counts) is correct, but Gen omits the gender column from SELECT."
  },
  {
    "id": 740,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 741,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering conditions. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 742,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 30,
    "reason": "Gen query joins two tables and groups by account ID, while Gold query only selects from one table without grouping. These will return different results on most database states."
  },
  {
    "id": 743,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 30,
    "reason": "Gen query joins two tables and groups by account ID, while Gold query only selects from one table without grouping. These will produce different result sets on most database states."
  },
  {
    "id": 744,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count transactions for account '337' with identical JOIN logic and WHERE conditions, differing only in table aliases and whitespace formatting."
  },
  {
    "id": 745,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both count transactions for account '337' with the same join logic."
  },
  {
    "id": 746,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same aggregate functions (AVG, MIN, MAX, SUM) from the same table with no filtering conditions. The only differences are cosmetic (whitespace formatting and keyword case)."
  },
  {
    "id": 747,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical, selecting the same aggregate functions from the same table with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 748,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select transaction IDs where the amount exceeds the average amount from the same table, with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 749,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select transaction IDs where the amount exceeds the average amount from the same table, with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 750,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with identical aggregation and grouping, with only minor whitespace and formatting differences."
  },
  {
    "id": 751,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with the same aggregation and grouping, with only minor cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 752,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, select the same columns (with different aliases), and group by the same column. The only differences are table aliases and formatting, which are cosmetic."
  },
  {
    "id": 753,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, group by the same column (id_tai_khoan), and select the same columns (id_tai_khoan, ten_tai_khoan, COUNT(*)). The only differences are table aliases and column order in SELECT, which are cosmetic."
  },
  {
    "id": 754,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same id_tai_khoan with highest transaction count, but Gen includes an unnecessary JOIN to tai_khoan table while Gold directly groups giao_dich_tai_chinh. The JOIN doesn't change the result since it's on the grouping column."
  },
  {
    "id": 755,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same id_tai_khoan with highest transaction count, but Gen includes an unnecessary JOIN to tai_khoan table while Gold directly groups giao_dich_tai_chinh. The JOIN doesn't change the result since it's on the grouping column."
  },
  {
    "id": 756,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with the same condition, group by the same column, and have identical HAVING clauses. The only differences are cosmetic: table aliases (T1/T2 vs t1/t2) and column aliases in SELECT (T1.ten_tai_khoan vs t2.ten_tai_khoan), which refer to the same column from the same table."
  },
  {
    "id": 757,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing table aliases and column references. Both select accounts with at least 4 financial transactions using the same JOIN logic and conditions."
  },
  {
    "id": 758,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select distinct values from the same column in the same table with no filtering conditions. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 759,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select distinct values from the same column in the same table, with only cosmetic differences in keyword case."
  },
  {
    "id": 760,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 761,
    "db_id": "customers_and_invoices",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 762,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "Different tables involved - Gen query joins hoa_don and giao_dich_tai_chinh, while Gold query only uses giao_dich_tai_chinh. This changes which rows are counted in the aggregation."
  },
  {
    "id": 763,
    "db_id": "customers_and_invoices",
    "strict_match": false,
    "score": 50,
    "reason": "The queries join different tables - Gen joins hoa_don with giao_dich_tai_chinh while Gold only queries giao_dich_tai_chinh. This creates different result sets as Gen requires matching records in both tables while Gold includes all records from giao_dich_tai_chinh."
  },
  {
    "id": 1528,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same tables with identical JOIN conditions, differing only in table aliases which are cosmetic differences."
  },
  {
    "id": 1529,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and select the same columns, differing only in table aliases which are cosmetic differences."
  },
  {
    "id": 1530,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column, perform the same COUNT(*) aggregation, and group by the same column. The only differences are cosmetic (whitespace, keyword case, and formatting)."
  },
  {
    "id": 1531,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns, same aggregation, same grouping, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 1532,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same GROUP BY and ORDER BY clauses. The only differences are cosmetic (whitespace formatting and keyword case)."
  },
  {
    "id": 1533,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select religion and count from the same table with identical grouping and ordering. The only differences are cosmetic (aliases, whitespace, and keyword case)."
  },
  {
    "id": 1534,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1535,
    "db_id": "school_player",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables and columns: Gen uses JOIN with chi_tiet_truong_hoc table and selects two columns, while Gold only selects from truong_hoc table with different column name."
  },
  {
    "id": 1536,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select locations from schools where the school ID is not in the player table, with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 1537,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select locations from schools where the school ID is not in the player table, with only minor cosmetic differences in formatting and case."
  },
  {
    "id": 1538,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in structure and logic, with only minor cosmetic differences in keyword case and formatting that do not affect the semantic meaning."
  },
  {
    "id": 1539,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same tables, same columns, same INTERSECT operation, and same WHERE conditions with identical numeric values. The only differences are cosmetic (keyword case and whitespace)."
  },
  {
    "id": 1540,
    "db_id": "school_player",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions use different comparison values ('1' vs 'division 1') that are not semantically equivalent according to the Vietnamese-English equivalence rules. These are different string literals with no established equivalence mapping."
  },
  {
    "id": 1541,
    "db_id": "school_player",
    "strict_match": false,
    "score": 20,
    "reason": "Queries have completely different logic - Gen joins with truong_hoc table and filters on different columns with OR conditions, while Gold filters only on chi_tiet_truong_hoc.phan_hang column. They would return different results on most database states."
  },
  {
    "id": 1542,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column from the same table with identical GROUP BY and HAVING conditions, with only minor cosmetic differences in table alias usage and formatting."
  },
  {
    "id": 1543,
    "db_id": "school_player",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY and HAVING conditions, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 1544,
    "db_id": "soccer_1",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different logic: UNION combines all rows from both tables, while JOIN matches rows based on a condition. They would return different results on most database states."
  },
  {
    "id": 1545,
    "db_id": "soccer_1",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries count matches in tournaments for a specific country, using equivalent JOIN logic and WHERE conditions with English/Vietnamese value equivalence ('Anh' = 'england'). Only differences are table aliases, formatting, and string literal language."
  },
  {
    "id": 1546,
    "db_id": "soccer_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they calculate the average weight from the same table with the same aggregation function. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 1547,
    "db_id": "soccer_1",
    "strict_match": false,
    "score": 30,
    "reason": "Gen returns only the heaviest weight (single value), while Gold returns both max and min weights (two values). These queries produce fundamentally different result sets with different numbers of columns and rows."
  },
  {
    "id": 1548,
    "db_id": "soccer_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return players with above-average ratings, but Gen includes an extra JOIN condition on id_cau_thu_api_cua_fifa and lacks DISTINCT, while Gold uses DISTINCT and only joins on id_cau_thu_api."
  },
  {
    "id": 1549,
    "db_id": "soccer_1",
    "strict_match": false,
    "score": 65,
    "reason": "Gen uses ORDER BY + LIMIT to find max re_bong, while Gold uses subquery with MAX(danh_gia_tong_the) on a different column, making them semantically different. The DISTINCT in Gold also changes result handling compared to Gen's single-row result."
  },
  {
    "id": 1550,
    "db_id": "soccer_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases, keyword case, and Vietnamese vs English string literal values ('phải' vs 'right' for 'chan_thuan'). Both filter players with tat_bong > 90 and right-footed preference."
  },
  {
    "id": 1551,
    "db_id": "soccer_1",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only minor differences: Vietnamese vs English string value ('trái' vs 'left'), additional JOIN condition in Gen that's functionally redundant, and DISTINCT in Gold vs no DISTINCT in Gen (but same result due to JOIN conditions)."
  },
  {
    "id": 1552,
    "db_id": "soccer_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different JOIN logic - Gen includes an additional JOIN with the cau_thu table and extra JOIN conditions, while Gold only uses the dac_diem_cua_cau_thu table. This creates different semantic meaning as Gen filters based on matching records between tables."
  },
  {
    "id": 1553,
    "db_id": "soccer_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries count players by dominant foot with overall rating > 80, but Gen includes an unnecessary JOIN to the cau_thu table which doesn't affect the final result since all filtering and grouping is done on dac_diem_cua_cau_thu columns. This is a minor difference that doesn't change the semantic meaning."
  },
  {
    "id": 1554,
    "db_id": "soccer_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use fundamentally different logic: Gen uses JOIN with multiple conditions while Gold uses INTERSECT on separate queries. They may return different results when id_cau_thu_api and id_cau_thu_api_cua_fifa don't match consistently across tables."
  },
  {
    "id": 1555,
    "db_id": "soccer_1",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return players with height 180-190 AND left-footed, but Gen uses JOIN with explicit conditions while Gold uses INTERSECT. The WHERE condition 'trái' in Gen is semantically equivalent to 'left' in Gold (Vietnamese vs English)."
  },
  {
    "id": 1556,
    "db_id": "soccer_1",
    "strict_match": false,
    "score": 65,
    "reason": "Gen query has stricter JOIN conditions (requires both id_cau_thu_api AND id_cau_thu_api_cua_fifa to match), while Gold only requires id_cau_thu_api to match. This creates different semantic logic that could return different results."
  },
  {
    "id": 1557,
    "db_id": "soccer_1",
    "strict_match": false,
    "score": 65,
    "reason": "Gen query has additional JOIN condition (id_cau_thu_api_cua_fifa) and lacks DISTINCT, while Gold query has DISTINCT but simpler JOIN condition. These are semantic differences affecting result sets."
  },
  {
    "id": 1558,
    "db_id": "store_product",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different logic: Gen joins multiple tables and orders by store area, while Gold selects from a single table and orders by a different column (city area). They access different data sources and sort criteria."
  },
  {
    "id": 1559,
    "db_id": "store_product",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return district names ordered by area, but Gen includes an extra column (dien_tich_cua_cac_thanh_pho) in SELECT that Gold doesn't request. The main answer (district names in area order) is preserved."
  },
  {
    "id": 1560,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column from the same table with identical GROUP BY and HAVING conditions, with only minor cosmetic differences in formatting and table prefix usage."
  },
  {
    "id": 1561,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column from the same table with identical GROUP BY and HAVING conditions, with only minor cosmetic differences in formatting and keyword case."
  },
  {
    "id": 1562,
    "db_id": "store_product",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions: Gen uses BETWEEN 200000 AND 20000000 while Gold uses BETWEEN 200000 AND 2000000. These ranges are not equivalent and will return different results for values between 2,000,001 and 20,000,000."
  },
  {
    "id": 1563,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns, same WHERE condition with identical numeric range. The only differences are cosmetic (whitespace formatting and keyword case)."
  },
  {
    "id": 1564,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case (SELECT vs select) and whitespace formatting."
  },
  {
    "id": 1565,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1566,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same ordering, and same limit. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 1567,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select), which are ignored according to the rules. Both queries select the same column from the same table with identical ordering and limit conditions."
  },
  {
    "id": 1568,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and formatting, which are ignored according to the rules."
  },
  {
    "id": 1569,
    "db_id": "store_product",
    "strict_match": false,
    "score": 20,
    "reason": "The queries join different tables and order by different columns - Gen joins quan, quan_cua_cua_hang, and cua_hang tables ordering by cua_hang.dien_tich, while Gold only queries quan table ordering by dien_tich_cua_cac_thanh_pho."
  },
  {
    "id": 1570,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 1571,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the sum of population for the top 3 districts by area, with only minor whitespace and formatting differences."
  },
  {
    "id": 1572,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns, same aggregation, same grouping, and same logic. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1573,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with the same aggregation and grouping, with only minor cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 1574,
    "db_id": "store_product",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions differ semantically: 'Khanewal' vs 'khanewal district' are not equivalent values (one is a city name, the other includes 'district'), so the queries would return different results for some database states."
  },
  {
    "id": 1575,
    "db_id": "store_product",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions: 'Khanewal' vs 'khanewal district' are not semantically equivalent values. The queries would return different results for stores in Khanewal district but not specifically named 'Khanewal'."
  },
  {
    "id": 1576,
    "db_id": "store_product",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return stores in the district with highest population, but Gen includes an extra JOIN to quan table that Gold doesn't have. However, the WHERE condition ensures both queries filter to the same district ID."
  },
  {
    "id": 1577,
    "db_id": "store_product",
    "strict_match": false,
    "score": 40,
    "reason": "Gen returns district name and store name for the most populous district, while Gold returns only store name for stores in the most populous district. Different SELECT columns and JOIN structure lead to different result sets."
  },
  {
    "id": 1578,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal differences. Both perform the same joins with the same conditions and filter on the same column with equivalent values."
  },
  {
    "id": 1579,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal differences. Both perform the same joins with the same conditions and filter on the same column with equivalent values."
  },
  {
    "id": 1580,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both queries join the same three tables with the same conditions, group by the same column, and perform the same aggregation."
  },
  {
    "id": 1581,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same three tables with the same conditions, group by the same column, and perform the same aggregation."
  },
  {
    "id": 1582,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same conditions, group by the same column, and order by the same aggregate count. The only differences are table aliases and whitespace formatting."
  },
  {
    "id": 1583,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same conditions, group by the same column, and use the same aggregation and ordering. The only differences are table aliases and whitespace formatting, which are cosmetic."
  },
  {
    "id": 1584,
    "db_id": "store_product",
    "strict_match": false,
    "score": 30,
    "reason": "Gen returns raw column values while Gold applies AVG aggregation, producing fundamentally different result sets (individual values vs single average)."
  },
  {
    "id": 1585,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the average of the same column from the same table with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 1586,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences: table aliases (t1, t2, t3 vs none), keyword case (SELECT vs select), and string literal formatting (single vs double quotes). All JOIN conditions, WHERE logic, and column selections match exactly."
  },
  {
    "id": 1587,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and filter on the same column with the same value (case-insensitive string match). The only differences are table aliases, formatting, and single vs double quotes, which are cosmetic."
  },
  {
    "id": 1588,
    "db_id": "store_product",
    "strict_match": true,
    "score": 98,
    "reason": "The queries are semantically equivalent with only minor cosmetic differences: column alias 'san_pham.san_pham' vs 'san_pham', string literal formatting 'A 4' vs 'a4', and keyword case. Both filter the same table with identical conditions."
  },
  {
    "id": 1589,
    "db_id": "store_product",
    "strict_match": true,
    "score": 98,
    "reason": "The queries are semantically equivalent with only minor cosmetic differences: column alias 'san_pham.san_pham' vs 'san_pham', string literal formatting 'A 4' vs 'a4', and keyword case differences."
  },
  {
    "id": 1590,
    "db_id": "store_product",
    "strict_match": true,
    "score": 99,
    "reason": "The queries are semantically identical with only minor cosmetic differences: Gen uses parentheses around the OR condition and single quotes with a space in 'A 4', while Gold uses double quotes and 'a4' without space. Both represent the same logical condition."
  },
  {
    "id": 1591,
    "db_id": "store_product",
    "strict_match": true,
    "score": 99,
    "reason": "The queries are semantically identical with only minor cosmetic differences: table alias usage, keyword case, whitespace, and single vs double quotes. The string value 'A 4' vs 'a4' appears to be the same measurement with different formatting."
  },
  {
    "id": 1592,
    "db_id": "store_product",
    "strict_match": false,
    "score": 40,
    "reason": "The WHERE conditions use different search patterns ('%Máy quét%' vs '%scanner%') that are not semantically equivalent - they search for different text values that may not match the same rows in all database states."
  },
  {
    "id": 1593,
    "db_id": "store_product",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen searches for Vietnamese phrase 'Máy quét' (scanner) while Gold searches for English word 'scanner' - these are not equivalent string patterns in LIKE clauses as they match different text."
  },
  {
    "id": 1594,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same grouping column, same aggregation, same ordering, same limit. Only differences are cosmetic (table prefix in SELECT clause and whitespace formatting)."
  },
  {
    "id": 1595,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical GROUP BY, ORDER BY, and LIMIT clauses. The only differences are cosmetic (keyword case, whitespace formatting)."
  },
  {
    "id": 1596,
    "db_id": "store_product",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different semantic logic: Gen compares kich_thuoc_trang_toi_da column values, while Gold compares san_pham column values against the same subquery result, which would return different results in most database states."
  },
  {
    "id": 1597,
    "db_id": "store_product",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen compares kich_thuoc_trang_toi_da to MAX(kich_thuoc_trang_toi_da), while Gold compares san_pham to the most frequent kich_thuoc_trang_toi_da value (using GROUP BY and COUNT). These will return different results in most cases."
  },
  {
    "id": 1598,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the sum of population for cities with area greater than the average area, with only minor whitespace and formatting differences."
  },
  {
    "id": 1599,
    "db_id": "store_product",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate the sum of population for districts where area exceeds the average area, with only minor formatting differences in whitespace and keyword case."
  },
  {
    "id": 1600,
    "db_id": "store_product",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries use INTERSECT to find quan names associated with two specific store types, with identical table joins and logic. The only difference is Vietnamese vs English string values for store types, which are semantically equivalent according to the rules."
  },
  {
    "id": 1601,
    "db_id": "store_product",
    "strict_match": false,
    "score": 50,
    "reason": "Different semantic logic: Gen uses GROUP BY with HAVING COUNT(DISTINCT loai) = 2 to find quan associated with both store types, while Gold uses INTERSECT to find quan associated with both store types separately. These are semantically different approaches that could produce different results depending on data."
  },
  {
    "id": 1602,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count all rows from the same table with the same aggregation function. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1603,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with the same aggregation function. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1604,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same table with identical ORDER BY logic. The only differences are cosmetic (keyword case and whitespace)."
  },
  {
    "id": 1605,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same columns from the same table with the same ORDER BY clause. The only differences are cosmetic (keyword case and explicit ASC specification)."
  },
  {
    "id": 1606,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table with the same ordering. The only differences are cosmetic (keyword case and explicit ASC specification)."
  },
  {
    "id": 1607,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table with the same ordering. The only differences are cosmetic (keyword case and explicit ASC specification)."
  },
  {
    "id": 1608,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - both select ten_khu_vuc from khu_vuc where ten_khu_vuc is not equal to a country name. The only difference is 'Đan Mạch' (Vietnamese for Denmark) vs 'denmark' (English), which represent the same real-world value according to the Vietnamese-English value equivalence rules."
  },
  {
    "id": 1609,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - both select ten_khu_vuc from khu_vuc where ten_khu_vuc is not equal to a country name. The only difference is 'Đan Mạch' (Vietnamese) vs 'denmark' (English), which refer to the same country and are treated as equivalent values."
  },
  {
    "id": 1610,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are keyword case (SELECT vs select) and whitespace formatting, which are cosmetic differences to be ignored."
  },
  {
    "id": 1611,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions: 'so_luong_nguoi_chet >= 1' vs 'so_luong_nguoi_chet > 0' are not semantically equivalent for all possible values (e.g., decimal values between 0 and 1)."
  },
  {
    "id": 1612,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1613,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1614,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences in whitespace formatting and keyword case."
  },
  {
    "id": 1615,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 1616,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same SELECT aggregation, FROM table, and WHERE subquery condition with only minor whitespace and formatting differences."
  },
  {
    "id": 1617,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both calculate sums of the same columns from the same table with the same subquery condition, differing only in whitespace formatting and keyword case."
  },
  {
    "id": 1618,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for minor cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 1619,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns, same ordering. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1620,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different aggregation logic: Gen counts all rows while Gold counts distinct id_khu_vuc values, which will produce different results when there are duplicate id_khu_vuc values."
  },
  {
    "id": 1621,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - same table, same column, same COUNT(DISTINCT) aggregation, only differences are keyword case and whitespace formatting."
  },
  {
    "id": 1622,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select ten_khu_vuc from khu_vuc where id_khu_vuc is not in the subquery results from khu_vuc_bi_anh_huong. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1623,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 0,
    "reason": "API Error"
  },
  {
    "id": 1624,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries join the same tables with identical conditions and aggregate counts. The only difference is that Gen includes 'ten_khu_vuc' in GROUP BY, which is functionally dependent on 'id_khu_vuc' (primary key), making them semantically equivalent."
  },
  {
    "id": 1625,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with the same conditions and aggregate identically."
  },
  {
    "id": 1626,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN conditions: Gen uses 'bao.id_con_bao = khu_vuc_bi_anh_huong.id_bao' while Gold uses 't1.id_bao = t2.id_bao'. These reference different columns, so the queries join on different relationships."
  },
  {
    "id": 1627,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 40,
    "reason": "Different GROUP BY columns (id_con_bao vs id_bao) and different SELECT columns (id_con_bao vs ten) - these are not functionally equivalent and will produce different result sets."
  },
  {
    "id": 1628,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN conditions: Gen uses 'bao.id_con_bao = khu_vuc_bi_anh_huong.id_bao' while Gold uses 't1.id_bao = t2.id_bao'. These reference different columns, so the queries join on different relationships."
  },
  {
    "id": 1629,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 20,
    "reason": "Different JOIN conditions: Gen uses 'bao.id_con_bao = khu_vuc_bi_anh_huong.id_bao' while Gold uses 't1.id_bao = t2.id_bao'. These refer to different columns and will produce different results."
  },
  {
    "id": 1630,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 50,
    "reason": "Different column references in WHERE condition: Gen uses 'id_con_bao' while Gold uses 'id_bao' - these are different columns with potentially different data, making the queries semantically different."
  },
  {
    "id": 1631,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 20,
    "reason": "The queries use different columns in the NOT IN condition: Gen uses 'id_con_bao' while Gold uses 'id_bao'. This is a semantic difference that will produce different results on most database states."
  },
  {
    "id": 1632,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 50,
    "reason": "Gen uses a single GROUP BY with both conditions in HAVING, while Gold uses INTERSECT to combine two separate queries with different HAVING conditions. These produce different results when a bao has >=2 khu_vuc_bi_anh_huong but <10 total so_thanh_pho_bi_anh_huong, or vice versa."
  },
  {
    "id": 1633,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 50,
    "reason": "Gen uses HAVING with AND to combine both conditions in a single query, while Gold uses INTERSECT between two separate queries with different HAVING conditions. These are semantically different approaches that could produce different results."
  },
  {
    "id": 1634,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return the same results: names from 'bao' where the id_bao doesn't appear in khu_vuc_bi_anh_huong with 2+ records. The Gen query uses NOT IN while Gold uses EXCEPT with JOIN, which are semantically equivalent for set exclusion, and EXCEPT is the preferred SQL pattern."
  },
  {
    "id": 1635,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use fundamentally different logic: Gen finds bao with ≤2 affected areas using GROUP BY/HAVING, while Gold finds all bao except those with ≥2 affected areas using EXCEPT. These are not semantically equivalent on all possible data."
  },
  {
    "id": 1636,
    "db_id": "storm_record",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN conditions: Gen uses T3.id_con_bao while Gold uses T3.id_bao. This changes which rows are joined and could return different results."
  },
  {
    "id": 1637,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause, differing only in table aliases and join order which are cosmetic differences."
  },
  {
    "id": 1638,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same three tables with equivalent join conditions and filter on the same column with semantically equivalent values ('Đan Mạch' in Vietnamese = 'denmark' in English). Only differences are table aliases and column aliases."
  },
  {
    "id": 1639,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: different table aliases, JOIN order, and English vs Vietnamese string literal values for 'Đan Mạch' and 'denmark' which represent the same country."
  },
  {
    "id": 1640,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in case, whitespace, and alias naming conventions."
  },
  {
    "id": 1641,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and whitespace. Both use the same tables, JOIN conditions, GROUP BY, and HAVING clause with identical logic."
  },
  {
    "id": 1642,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and return the same column ordered by the same descending count, differing only in table aliases and join order."
  },
  {
    "id": 1643,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return the same result: the region name with the highest death count from affected regions. They join the same tables with equivalent conditions, use the same ordering logic, and only differ in table aliases and column references."
  },
  {
    "id": 1644,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same three tables with equivalent conditions, use INTERSECT with the same two country filters, and only differ in cosmetic aspects like table aliases, column aliases, and JOIN order."
  },
  {
    "id": 1645,
    "db_id": "storm_record",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return bao names affected by both Afghanistan and Albania regions, using equivalent logic (Gen uses GROUP BY/HAVING with IN clause, Gold uses INTERSECT with separate queries)."
  },
  {
    "id": 1646,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with identical syntax, differing only in keyword case and whitespace formatting."
  },
  {
    "id": 1647,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 1648,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with the same WHERE condition using the same numeric value."
  },
  {
    "id": 1649,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with the same WHERE condition using the same numeric value."
  },
  {
    "id": 1650,
    "db_id": "student_1",
    "strict_match": false,
    "score": 20,
    "reason": "Different columns selected (ho vs ten) - these are different column names, not just aliases. The queries would return different data from the same table."
  },
  {
    "id": 1651,
    "db_id": "student_1",
    "strict_match": false,
    "score": 20,
    "reason": "The queries select different columns (ho vs ten), which will return different result sets unless ho and ten always contain identical values in every row - a semantic difference that affects the output."
  },
  {
    "id": 1652,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - DISTINCT doesn't change results when selecting from a single table with no duplicates in the ten column, and all other elements match exactly."
  },
  {
    "id": 1653,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - DISTINCT doesn't change results when there are no duplicates in the data, and both queries filter on the same condition."
  },
  {
    "id": 1654,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The DISTINCT keyword in Gold SQL is redundant since the combination of phong_hoc and khoi_lop would already be unique if there are no duplicate rows, making both queries semantically identical."
  },
  {
    "id": 1655,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - DISTINCT doesn't change the result since the SELECT columns are the same and would return the same unique combinations regardless. This is a cosmetic difference only."
  },
  {
    "id": 1656,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The DISTINCT keyword in Gold is redundant since SELECT khoi_lop without DISTINCT already returns unique values when there are no duplicates in the result set, making both queries semantically equivalent."
  },
  {
    "id": 1657,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The DISTINCT keyword in Gold is redundant since khoi_lop values are already unique for each row with phong_hoc=103, making both queries semantically identical. Both queries select the same column from the same table with the same WHERE condition."
  },
  {
    "id": 1658,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The DISTINCT keyword in Gold is redundant since SELECT without DISTINCT already returns unique rows when there are no duplicates in the data, and both queries filter on the same condition. They will return identical results on any possible database state."
  },
  {
    "id": 1659,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The DISTINCT keyword in Gold SQL is redundant since GROUP BY is not present and there are no duplicate rows guaranteed by the schema, making both queries semantically identical. Both queries select the same column from the same table with the same WHERE condition."
  },
  {
    "id": 1660,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select distinct phong_hoc values from danh_sach where khoi_lop equals 4, with only cosmetic differences in keyword case."
  },
  {
    "id": 1661,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The DISTINCT keyword in Gold SQL is redundant since SELECT phong_hoc without DISTINCT already returns unique values when there are no duplicates in the result set, making both queries semantically equivalent."
  },
  {
    "id": 1662,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The DISTINCT keyword in Gold SQL is redundant since the Gen query without DISTINCT will return the same results when selecting from the same table with the same WHERE condition."
  },
  {
    "id": 1663,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The DISTINCT keyword in Gold SQL is redundant since the Gen query without DISTINCT will return the same results when selecting from the same table with the same WHERE condition."
  },
  {
    "id": 1664,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE filters, returning the same column data. The DISTINCT keyword in Gold doesn't affect results since Gen's query would also return unique values due to the same join logic."
  },
  {
    "id": 1665,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE filters, returning the same column values. The DISTINCT keyword in Gold doesn't change semantics since the Gen query would return unique values implicitly due to the join structure."
  },
  {
    "id": 1666,
    "db_id": "student_1",
    "strict_match": false,
    "score": 65,
    "reason": "Both queries return teachers in classrooms for grade 1, but Gen returns 'ho' (last name) from giao_vien while Gold returns 'ten' (first name) from giao_vien with alias t2. The column selection differs, making them not strictly equivalent."
  },
  {
    "id": 1667,
    "db_id": "student_1",
    "strict_match": false,
    "score": 65,
    "reason": "Gen query returns both ho and ten columns, while Gold query returns only ten column with DISTINCT. The DISTINCT in Gold eliminates duplicates that Gen would include."
  },
  {
    "id": 1668,
    "db_id": "student_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries select from the same table with the same WHERE condition, but Gen includes an extra column 'ho' in SELECT while Gold only selects 'ten'. This is a minor cosmetic difference that doesn't change the main answer."
  },
  {
    "id": 1669,
    "db_id": "student_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries select from the same table with the same WHERE condition, but Gen includes an extra column (ho) in the SELECT clause that Gold does not request. This is a minor cosmetic difference that doesn't change the main answer about which teachers are in room 110."
  },
  {
    "id": 1670,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select). Both select the same column from the same table with the same WHERE condition using the same numeric value."
  },
  {
    "id": 1671,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic (keyword case and whitespace)."
  },
  {
    "id": 1672,
    "db_id": "student_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same set of rows (first and last names from teachers table), but Gen lacks DISTINCT which could return duplicate rows that Gold would eliminate. However, if ho and ten combination is unique in the table, they would be equivalent."
  },
  {
    "id": 1673,
    "db_id": "student_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same set of rows from the same table, but Gen returns duplicates while Gold uses DISTINCT to eliminate duplicates. The column order difference is cosmetic."
  },
  {
    "id": 1674,
    "db_id": "student_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same set of rows from the same table, but the DISTINCT keyword in Gold eliminates duplicates while Gen returns all rows including duplicates. The column order difference is cosmetic."
  },
  {
    "id": 1675,
    "db_id": "student_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the same columns (ho and ten) from the same table, but Gold includes DISTINCT which eliminates duplicate rows while Gen does not. This is a semantic difference in result sets."
  },
  {
    "id": 1676,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have swapped WHERE conditions: Gen checks giao_vien.ho='OTHA' AND giao_vien.ten='MOYER', while Gold checks t2.ten='otha' AND t2.ho='moyer'. This is a semantic difference in column matching that could return different results."
  },
  {
    "id": 1677,
    "db_id": "student_1",
    "strict_match": false,
    "score": 40,
    "reason": "The WHERE conditions are semantically different: Gen filters by full name 'OTHA MOYER' in the ho column, while Gold filters by separate first name 'otha' in ten column and last name 'moyer' in ho column. These would return different results on most database states."
  },
  {
    "id": 1678,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions - Gen looks for 'MARROTTE'/'KIRK' while Gold looks for 'marrotte'/'kirk'. These are different string values (case matters in SQL string comparisons), so they will return different results."
  },
  {
    "id": 1679,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions - Gen looks for 'MARROTTE'/'KIRK' while Gold looks for 'marrotte'/'kirk'. These are different string values, not English/Vietnamese equivalents, so they would return different results."
  },
  {
    "id": 1680,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and column order. Both join the same tables with the same condition and filter on identical values."
  },
  {
    "id": 1681,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions and WHERE filters, selecting the same columns from the same table. The only differences are cosmetic: table aliases, column order in SELECT, and case/formatting of string literals."
  },
  {
    "id": 1682,
    "db_id": "student_1",
    "strict_match": false,
    "score": 20,
    "reason": "Different WHERE conditions: Gen filters on danh_sach.ho='GELL' and danh_sach.ten='TAMI' while Gold filters on t1.ten='gell' and t1.ho='tami' (different column assignments for the same values)."
  },
  {
    "id": 1683,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions differ semantically: Gen uses 'GELL TAMI' as a single value for ten, while Gold uses 'gell' for ten and 'tami' for ho, which are different filtering conditions."
  },
  {
    "id": 1684,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions differ: Gen uses 'ho = LORIA' and 'ten = ONDERSMA' while Gold uses 'ten = loria' and 'ho = ondersma', swapping the column assignments for the values. This is a semantic difference that could produce different results."
  },
  {
    "id": 1685,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different logic: Gen uses subquery to find classroom first, then counts; Gold uses JOIN to combine tables directly. They may return different results if multiple teachers share the same classroom."
  },
  {
    "id": 1686,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions: Gen uses 'KAWA'/'GORDON' while Gold uses 'kawa'/'gordon' (case-sensitive difference), and they filter on different column combinations (Gen: ho='KAWA' AND ten='GORDON', Gold: ten='kawa' AND ho='gordon')."
  },
  {
    "id": 1687,
    "db_id": "student_1",
    "strict_match": false,
    "score": 20,
    "reason": "Different WHERE conditions: Gen uses 'KAWA'/'GORDON' while Gold uses 'kawa'/'gordon' - these are not English/Vietnamese equivalents but different string values (case-sensitive in SQLite). Also, column order in WHERE clause differs but that's cosmetic."
  },
  {
    "id": 1688,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions - Gen looks for ho='TARRING' AND ten='LEIA' while Gold looks for ten='tarring' AND ho='leia'. These are not equivalent as they search different columns for different values."
  },
  {
    "id": 1689,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different WHERE conditions: Gen looks for ho='TARRING' AND ten='LEIA' while Gold looks for ten='tarring' AND ho='leia'. These are not equivalent English/Vietnamese value pairs - they appear to be swapped names with different cases."
  },
  {
    "id": 1690,
    "db_id": "student_1",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries count teachers in the same classroom as Chrissy Nabozny, using equivalent logic with different syntax (subquery vs JOIN). The only difference is cosmetic formatting and aliases."
  },
  {
    "id": 1691,
    "db_id": "student_1",
    "strict_match": false,
    "score": 40,
    "reason": "The WHERE conditions differ semantically: Gen filters on a single concatenated name column, while Gold filters on separate first and last name columns. These conditions are not equivalent and would return different results in many database states."
  },
  {
    "id": 1692,
    "db_id": "student_1",
    "strict_match": false,
    "score": 40,
    "reason": "The WHERE conditions differ significantly: Gen filters on a single 'ten' column with value 'MADLOCK RAY', while Gold filters on separate 'ten' and 'ho' columns with values 'madlock' and 'ray' respectively. These are semantically different conditions that would return different results in many database states."
  },
  {
    "id": 1693,
    "db_id": "student_1",
    "strict_match": false,
    "score": 40,
    "reason": "The queries use different logic: Gen uses a subquery to find a specific classroom, while Gold joins tables and filters by both first and last name. They would return different results if multiple people share the same classroom or if name matching differs."
  },
  {
    "id": 1694,
    "db_id": "student_1",
    "strict_match": false,
    "score": 65,
    "reason": "Both queries find students in grade 1 who are not in classrooms with specific teachers, but Gen uses NOT IN with a subquery while Gold uses EXCEPT with JOINs, which are semantically equivalent approaches. However, Gold includes DISTINCT which Gen lacks, and Gold's WHERE clause filters differently (t1.khoi_lop = 1 vs Gen's combined condition)."
  },
  {
    "id": 1695,
    "db_id": "student_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different logic: Gen uses NOT IN with a subquery filtering by teacher's last name, while Gold uses EXCEPT with JOINs filtering by teacher's first and last name. These would return different results when teachers share last names but have different first names."
  },
  {
    "id": 1696,
    "db_id": "student_1",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen excludes students from rooms where specific teachers teach, while Gold selects students from rooms where teachers with different names teach. The WHERE conditions are semantically different (NOT IN vs JOIN with inequality)."
  },
  {
    "id": 1697,
    "db_id": "student_1",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen excludes students from rooms with specific teachers, while Gold excludes students from rooms where teachers have specific names. They would return different results when a room has multiple teachers."
  },
  {
    "id": 1698,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in whitespace formatting and keyword case, which are explicitly ignored according to the rules."
  },
  {
    "id": 1699,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns, use the same aggregation functions, and have the same GROUP BY clause, with only minor formatting differences."
  },
  {
    "id": 1700,
    "db_id": "student_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries differ semantically: Gen counts all occurrences of khoi_lop per phong_hoc, while Gold counts distinct values of khoi_lop per phong_hoc. These can produce different results when duplicate khoi_lop values exist within the same phong_hoc."
  },
  {
    "id": 1701,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns, use the same aggregation with COUNT(DISTINCT), and have the same GROUP BY clause. The only differences are cosmetic (whitespace formatting and keyword case)."
  },
  {
    "id": 1702,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting. Both queries select the most frequently occurring phong_hoc value from the danh_sach table using the same GROUP BY, ORDER BY, and LIMIT logic."
  },
  {
    "id": 1703,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the most frequent phong_hoc by grouping and ordering by count. The only differences are cosmetic (keyword case and whitespace around COUNT(*))."
  },
  {
    "id": 1704,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count records grouped by phong_hoc with only cosmetic differences in whitespace and keyword case."
  },
  {
    "id": 1705,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count records grouped by classroom, with only cosmetic differences in table alias usage and whitespace formatting."
  },
  {
    "id": 1706,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences: column alias 'danh_sach.phong_hoc' vs 'phong_hoc', keyword case, and numeric literal '0' vs string literal '\"0\"' which SQLite treats equivalently in numeric context."
  },
  {
    "id": 1707,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition (0 vs \"0\" are equivalent in SQLite) and same GROUP BY clause, with only minor cosmetic differences in formatting and keyword case."
  },
  {
    "id": 1708,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition (4 vs \"4\" are equivalent in SQLite) and same GROUP BY clause, with only minor cosmetic differences in formatting and quoting."
  },
  {
    "id": 1709,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count records by phong_hoc for khoi_lop = 4, with only minor cosmetic differences in formatting and numeric vs string literal representation of '4'."
  },
  {
    "id": 1710,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with the same condition, group by the same columns (ho and ten, just in different order which doesn't matter), and use identical aggregation and ordering. The only differences are cosmetic: table aliases, column order in SELECT, and column order in GROUP BY (which is equivalent since both columns are in the grouping)."
  },
  {
    "id": 1711,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (ho and ten from giao_vien), join the same tables with identical conditions (phong_hoc equality), group by the same columns, and order by the same count with the same limit. Only differences are cosmetic: table aliases, column order in SELECT, and whitespace."
  },
  {
    "id": 1712,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (phong_hoc and COUNT(*)) from the same table with the same GROUP BY logic. The differences are purely cosmetic: column order, alias usage, and whitespace formatting."
  },
  {
    "id": 1713,
    "db_id": "student_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (phong_hoc and COUNT(*)) from the same table with the same GROUP BY clause. The only differences are cosmetic: column order in SELECT and keyword case/formatting."
  },
  {
    "id": 1714,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they have the same tables, JOIN conditions, GROUP BY, ORDER BY, and LIMIT clauses, with only minor cosmetic differences in alias naming and whitespace formatting."
  },
  {
    "id": 1715,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in alias naming, keyword case, and whitespace formatting."
  },
  {
    "id": 1716,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries find the student with fewest course registrations, but Gen includes an unnecessary JOIN to the sinh_vien table which doesn't affect the result since it's grouping by id_sinh_vien from the registration table. The JOIN adds no filtering or additional data."
  },
  {
    "id": 1717,
    "db_id": "student_assessment",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries find the student with the fewest course registrations, but Gen includes an unnecessary JOIN to the sinh_vien table while Gold queries only the registration table. The JOIN doesn't change the result since it's on the same id_sinh_vien column."
  },
  {
    "id": 1718,
    "db_id": "student_assessment",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform identical JOIN operations between the same tables with the same conditions, selecting the same columns. The only differences are cosmetic: table aliases (ca_nhan vs t2) and formatting (case, whitespace, explicit AS keyword)."
  },
  {
    "id": 955,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case (SELECT vs select), string literal delimiters (single vs double quotes), and case in the string value (Jetblue Airways vs jetblue airways)."
  },
  {
    "id": 956,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case, string literal quotes, and case in the string value, which SQLite treats as equivalent."
  },
  {
    "id": 957,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case, string literal quotes, and case in the string value, which don't affect the results."
  },
  {
    "id": 958,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value: 'Hoa Kỳ' (Vietnamese) and 'USA' (English) both refer to the same country (United States). All other aspects (tables, columns, logic) are identical."
  },
  {
    "id": 959,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value: 'Hoa Kỳ' (Vietnamese for United States) vs 'usa' (English abbreviation). Both filter for airlines from the United States."
  },
  {
    "id": 960,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition. The differences are purely cosmetic: keyword case (SELECT vs select), string literal style (single vs double quotes), and case in the string value ('Anthony' vs 'anthony'), which SQLite treats as different unless using COLLATE NOCASE."
  },
  {
    "id": 961,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition. The differences are purely cosmetic: keyword case, whitespace, and single vs double quotes around the same string value."
  },
  {
    "id": 962,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 963,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 964,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 965,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 966,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace."
  },
  {
    "id": 967,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with no filtering or grouping. The only differences are cosmetic (keyword case and whitespace formatting)."
  },
  {
    "id": 968,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 95,
    "reason": "The queries are semantically equivalent except for case sensitivity in the string literal value ('UAL' vs 'ual'), which could return different results in SQLite depending on collation settings."
  },
  {
    "id": 969,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 95,
    "reason": "The queries are semantically equivalent except for case sensitivity in the string literal ('UAL' vs 'ual'), which could produce different results in SQLite's default case-sensitive string comparison."
  },
  {
    "id": 970,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value ('Mỹ' vs 'USA'), which represent the same country. All other aspects (table, column, aggregation) are identical."
  },
  {
    "id": 971,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value - 'Hoa Kỳ' (Vietnamese for USA) vs 'usa' (English abbreviation for USA). Both count airlines from the United States."
  },
  {
    "id": 972,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition. The only differences are cosmetic (keyword case, whitespace, and single vs double quotes for the string literal)."
  },
  {
    "id": 973,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns from the same table with the same WHERE condition. The only differences are cosmetic: keyword case, whitespace, and single vs double quotes around the string literal."
  },
  {
    "id": 974,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical - both select ten_san_bay from san_bay where ma_san_bay equals 'AKO'. The only differences are cosmetic (keyword case, single vs double quotes) which should be ignored."
  },
  {
    "id": 975,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions: 'AKO' vs 'ako' are different string values (case-sensitive in SQLite). The queries will return different results when ma_san_bay values have different cases."
  },
  {
    "id": 976,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select airport names from the same table with the same city condition, with only minor cosmetic differences in keyword case and quotation marks."
  },
  {
    "id": 977,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case of the city name value."
  },
  {
    "id": 978,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both count flights from the same airport using equivalent string values (APG vs apg), with only minor cosmetic differences in formatting and case."
  },
  {
    "id": 979,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both count flights from the same airport, with only cosmetic differences in keyword case, whitespace, and quote style."
  },
  {
    "id": 980,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count flights where the destination airport is 'ATO', with only cosmetic differences in keyword case, whitespace, and quote style."
  },
  {
    "id": 981,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different table structures - Gen joins with san_bay table while Gold doesn't, and they filter on different columns (san_bay.ma_san_bay vs chuyen_bay.san_bay_dich). The string values 'ATO' and 'ato' would be treated as equivalent ignoring case, but the different table logic makes them semantically different."
  },
  {
    "id": 982,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal differences. Both count flights departing from airports in Aberdeen with the same join logic and conditions."
  },
  {
    "id": 983,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and whitespace. Both count flights departing from airports in Aberdeen with the same join logic and conditions."
  },
  {
    "id": 984,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal differences. Both count flights to airports in Aberdeen with the same join logic and conditions."
  },
  {
    "id": 985,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 20,
    "reason": "The queries filter on different columns - Gen uses san_bay.ten_san_bay while Gold uses t2.thanh_pho. These are semantically different conditions that could return different results depending on the data."
  },
  {
    "id": 986,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have swapped JOIN conditions - Gen joins san_bay_khoi_hanh to Aberdeen and san_bay_dich to Ashley, while Gold joins san_bay_dich to Ashley and san_bay_khoi_hanh to Aberdeen. This creates different semantic logic for counting flights between the two cities."
  },
  {
    "id": 987,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count flights from Aberdeen to Ashley cities, with identical table joins and WHERE conditions despite different alias naming and join order."
  },
  {
    "id": 988,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both count flights from JetBlue Airways with the same join condition."
  },
  {
    "id": 989,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both count flights from the same airline using equivalent JOIN conditions and WHERE clause with the same string value."
  },
  {
    "id": 990,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query includes an extra JOIN with the san_bay table that filters on san_bay.ma_san_bay, while the Gold query filters directly on chuyen_bay.san_bay_dich. These are semantically different conditions that could return different results depending on the data."
  },
  {
    "id": 991,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries count flights for United Airlines to airport ASY, but Gen includes an unnecessary JOIN to san_bay table that doesn't add filtering beyond what's already in WHERE conditions. The extra JOIN is redundant but doesn't change the result."
  },
  {
    "id": 992,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count flights from United Airlines departing from AHD airport. The differences are purely cosmetic: table aliases, JOIN order, keyword case, whitespace, and quote style."
  },
  {
    "id": 993,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 65,
    "reason": "Gold query only joins hang_hang_khong and chuyen_bay tables, while Gen query also joins san_bay table with additional condition on san_bay.ma_san_bay. This creates different semantic logic - Gen requires matching san_bay record while Gold doesn't."
  },
  {
    "id": 994,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count flights from United Airlines to Aberdeen with identical join logic and conditions, differing only in table aliases, whitespace, and case."
  },
  {
    "id": 995,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen uses san_bay.ten_san_bay = 'Aberdeen' while Gold uses san_bay.thanh_pho = 'aberdeen' - these refer to different columns (airport name vs city name) which are not semantically equivalent."
  },
  {
    "id": 996,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both select the city with the most destination flights using the same tables, join conditions, grouping, and ordering."
  },
  {
    "id": 997,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries find the city with the most destination flights, but Gen groups by airport code while Gold groups by city name directly. If multiple airports share the same city, they could return different results."
  },
  {
    "id": 998,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both find the city with the most departing flights using the same tables, join conditions, grouping, and ordering."
  },
  {
    "id": 999,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries find the city with the most departing flights, but Gen groups by airport code while Gold groups by city name, which could produce different results if multiple airports share the same city."
  },
  {
    "id": 1000,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different purposes: Gen finds flight numbers where departure or arrival airports match the most frequent airport overall, while Gold finds the most frequent airport itself. They return different columns (flight numbers vs airport codes) from different tables."
  },
  {
    "id": 1001,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries find the airport code with the most flight connections (departures + arrivals), using different but semantically equivalent approaches: Gen uses UNION ALL on departure and arrival airports then groups, while Gold uses JOIN with OR condition then groups."
  },
  {
    "id": 1002,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries find the airport code with the fewest flights (departures or arrivals), using different but semantically equivalent approaches: Gen uses UNION ALL on departure/destination columns then groups, while Gold uses JOIN with OR condition then groups."
  },
  {
    "id": 1003,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, whitespace, and JOIN condition order. Both find the airport code with the fewest flights (as departure or arrival) using the same logic."
  },
  {
    "id": 1004,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the airline with the most flights, but Gen groups by primary key (id_hang_hang_khong) while Gold groups by functionally dependent column (ten_hang_hang_khong). Since airline name is functionally dependent on airline ID, they are semantically equivalent."
  },
  {
    "id": 1005,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries return the airline with the most flights, but Gen groups by primary key (id_hang_hang_khong) while Gold groups by functionally dependent column (ten_hang_hang_khong). Since airline name is unique per airline ID, they are semantically equivalent."
  },
  {
    "id": 1006,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 50,
    "reason": "Different GROUP BY columns: Gen groups by id_hang_hang_khong while Gold groups by ten_hang_hang_khong. These are different columns that may not be functionally dependent, potentially returning different results."
  },
  {
    "id": 1007,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 50,
    "reason": "Different GROUP BY columns: Gen groups by id_hang_hang_khong while Gold groups by ten_hang_hang_khong. These are different columns that may not be functionally dependent, potentially returning different results."
  },
  {
    "id": 1008,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 65,
    "reason": "The Gen query includes an extra JOIN with the san_bay table and filters on san_bay.ma_san_bay, while the Gold query filters directly on chuyen_bay.san_bay_khoi_hanh. These are semantically different conditions that could return different results depending on the data."
  },
  {
    "id": 1009,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal values (English 'AHD' vs Vietnamese 'ahd' are equivalent airport codes)."
  },
  {
    "id": 1010,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 40,
    "reason": "Different JOIN logic and WHERE conditions: Gen joins with san_bay table and filters on san_bay_khoi_hanh='AHD', while Gold filters directly on chuyen_bay.san_bay_dich='ahd' without san_bay join."
  },
  {
    "id": 1011,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 65,
    "reason": "The Gen query includes an extra JOIN with the san_bay table and filters on san_bay.ma_san_bay, while the Gold query filters directly on chuyen_bay.san_bay_dich. These are semantically different unless san_bay.ma_san_bay always equals chuyen_bay.san_bay_dich, which isn't guaranteed."
  },
  {
    "id": 1012,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries find airlines operating flights from both APG and CVO airports, but Gen includes extra id column and unnecessary GROUP BY/HAVING clauses, while Gold only selects airline names directly."
  },
  {
    "id": 1013,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 50,
    "reason": "Gen uses GROUP BY with HAVING COUNT(DISTINCT) = 2 to find airlines with flights from both airports, while Gold uses INTERSECT to find airlines with flights from both airports separately. These are different logical approaches that could produce different results if an airline has multiple flights from the same airport."
  },
  {
    "id": 1014,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 65,
    "reason": "Different columns selected (id_hang_hang_khong vs ten_hang_hang_khong) and different table structures (direct FROM chuyen_bay vs JOIN with hang_hang_khong). Both use EXCEPT with similar WHERE conditions, but return different result sets."
  },
  {
    "id": 1015,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return airlines that fly from CVO but not from APG using EXCEPT with equivalent logic, differing only in table aliases and explicit JOIN vs implicit JOIN in the Gold query."
  },
  {
    "id": 1016,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries find airlines with at least 10 flights, but Gen returns multiple columns while Gold returns only the airline name. The GROUP BY differs (id vs name), but if name is unique/functionally dependent on id, they're semantically equivalent for the main answer."
  },
  {
    "id": 1017,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return airlines with at least 10 flights, but Gen uses GROUP BY primary key (id_hang_hang_khong) while Gold uses GROUP BY name (ten_hang_hang_khong). If name is unique/functionally dependent on id, they're equivalent. Also, Gen uses '>= 10' vs Gold's '> 10' - different threshold."
  },
  {
    "id": 1018,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 95,
    "reason": "Both queries filter airlines with fewer than 200 flights, but Gen selects additional columns (id, abbreviation, country) while Gold only selects airline name. Since ten_hang_hang_khong is likely unique per airline, GROUP BY name vs GROUP BY id is equivalent."
  },
  {
    "id": 1019,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries find airlines with fewer than 200 flights, but Gen returns 4 columns while Gold returns only the airline name. The GROUP BY differs (id_hang_hang_khong vs ten_hang_hang_khong), but if airline name is unique/functionally dependent on ID, they're semantically equivalent for the filtering purpose."
  },
  {
    "id": 1020,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both select flight numbers from the same tables with the same join condition and WHERE clause filtering for the same airline."
  },
  {
    "id": 1021,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both select flight numbers from the same tables with the same join condition and WHERE filter for 'United Airlines'."
  },
  {
    "id": 1022,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The differences are purely cosmetic: keyword case (SELECT vs select), string literal style (single vs double quotes), and case in the string value ('APG' vs 'apg'), which SQLite treats as equivalent in string comparisons."
  },
  {
    "id": 1023,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case, single vs double quotes, and case of the string literal value."
  },
  {
    "id": 1024,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 60,
    "reason": "The Gen query uses a JOIN with san_bay table to filter by ma_san_bay, while the Gold query directly filters on san_bay_dich column. These are semantically different unless san_bay_dich always equals ma_san_bay for matching records."
  },
  {
    "id": 1025,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different logic: Gen performs an explicit JOIN with san_bay table and filters on ma_san_bay, while Gold directly filters on san_bay_dich column without a JOIN. They may return different results if san_bay_dich values don't match ma_san_bay values."
  },
  {
    "id": 1026,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal differences. Both select flight numbers from the same tables with identical JOIN conditions and WHERE filters."
  },
  {
    "id": 1027,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal differences. Both select flight numbers from the same tables with identical JOIN conditions and WHERE filters."
  },
  {
    "id": 1028,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with the same condition and filter on the same city value (case-insensitive string comparison)."
  },
  {
    "id": 1029,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 30,
    "reason": "Different WHERE conditions: Gen filters by airport name ('Aberdeen'), Gold filters by city ('aberdeen'). These are different columns with potentially different data, so queries may return different results."
  },
  {
    "id": 1030,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 65,
    "reason": "Different WHERE logic: Gen uses IN with two cities, Gold uses OR with misspelled 'abilene' instead of 'Abilene'. The misspelling creates a semantic difference as 'abilene' ≠ 'Abilene'."
  },
  {
    "id": 1031,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different filtering logic: Gen uses IN with two city names, while Gold uses OR with potentially misspelled city names ('abilene' vs 'Abilene'), which are not semantically equivalent."
  },
  {
    "id": 1032,
    "db_id": "flight_2",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select airport names where the airport code is not in the set of departure or destination airports from flights, with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 1033,
    "db_id": "flight_2",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return airports not used in flights, but Gen includes extra columns (ma_san_bay, thanh_pho, quoc_gia, ten_quoc_gia_viet_tat) beyond the requested ten_san_bay. The core exclusion logic is identical."
  },
  {
    "id": 1034,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count rows from the same table with the same WHERE condition. The only differences are cosmetic (keyword case, whitespace, and parentheses spacing)."
  },
  {
    "id": 1035,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same column selection, same ORDER BY clause with same direction. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 1036,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case and whitespace formatting, which are ignored according to the rules."
  },
  {
    "id": 1037,
    "db_id": "game_injury",
    "strict_match": false,
    "score": 50,
    "reason": "Gen calculates only the average, while Gold calculates average plus maximum and minimum values. These queries return different result sets with different numbers of columns and values."
  },
  {
    "id": 1038,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1039,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - they select the same columns from the same table with the same WHERE condition logic, differing only in the language of the string literal value ('đầu gối' vs 'knee problem' which have the same meaning)."
  },
  {
    "id": 1040,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and column references. Both join the same tables with equivalent conditions and return the same column from the same table."
  },
  {
    "id": 1041,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with equivalent conditions, group by the same column, and apply the same HAVING filter."
  },
  {
    "id": 1042,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both query the same tables with the same JOIN conditions, GROUP BY, ORDER BY, and LIMIT logic."
  },
  {
    "id": 1043,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both query the same tables with the same JOIN conditions, GROUP BY, ORDER BY, and LIMIT logic."
  },
  {
    "id": 1044,
    "db_id": "game_injury",
    "strict_match": false,
    "score": 65,
    "reason": "Different WHERE conditions: Gen uses IN with Vietnamese injury types ('chân', 'đầu gối'), Gold uses OR with English injury types ('foot injury', 'knee problem'). These are not recognized as equivalent value pairs in the rules, so they represent different semantic filtering logic."
  },
  {
    "id": 1045,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values from the same column in the same table, with only minor formatting differences in whitespace and keyword case."
  },
  {
    "id": 1046,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count rows from tran_dau where id is not in chan_thuong's id_tran_dau. The only differences are cosmetic (keyword case, whitespace, parentheses spacing)."
  },
  {
    "id": 1047,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both count distinct chan_thuong values from the same tables with identical join conditions and WHERE clause."
  },
  {
    "id": 1048,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return stadium names where both 'Walter Samuel' and 'Thiago Motta' were injured in matches played there. The Gen query uses subqueries with IN while Gold uses JOINs with INTERSECT, but both implement the same intersection logic with identical filtering conditions."
  },
  {
    "id": 1049,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return stadiums without injuries in matches, using semantically equivalent NOT IN vs EXCEPT patterns with proper JOIN logic. EXCEPT is the preferred SQL pattern for set exclusion."
  },
  {
    "id": 1050,
    "db_id": "game_injury",
    "strict_match": false,
    "score": 40,
    "reason": "The queries use different LIKE patterns ('%ngân hàng%' vs '%bank%') which are not semantically equivalent - they search for different substrings in Vietnamese vs English."
  },
  {
    "id": 1051,
    "db_id": "game_injury",
    "strict_match": false,
    "score": 30,
    "reason": "The queries have fundamentally different semantics: Gen selects two columns from a single table, while Gold performs a JOIN with aggregation and grouping. They would return completely different result sets on any database."
  },
  {
    "id": 1052,
    "db_id": "game_injury",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing table aliases and column order. Both join the same tables with equivalent conditions and return the same data with identical ordering."
  },
  {
    "id": 1053,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE conditions use different string literal values ('Trò chơi bắt chước' vs 'the imitation game') that are not listed as English/Vietnamese equivalents in the rules, so they represent different semantic filters."
  },
  {
    "id": 1054,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - they select the same column from the same table with the same filtering logic. The only difference is the string literal value in the WHERE clause, where 'Trò chơi bắt chước' (Vietnamese) and 'the imitation game' (English) refer to the same movie title."
  },
  {
    "id": 1055,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are keyword case (SELECT vs select), string literal quotes (single vs double), and column name case (nam_sinh vs nam_sinh), which are all cosmetic variations."
  },
  {
    "id": 1056,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are keyword case (SELECT vs select), string literal quotes (single vs double), and column name case (nam_sinh vs nam_sinh), which are all cosmetic variations."
  },
  {
    "id": 1057,
    "db_id": "imdb",
    "strict_match": false,
    "score": 65,
    "reason": "The Gen query has an additional WHERE condition (gioi_tinh = 'nữ') that filters for female actors only, while the Gold query returns all actors with that name regardless of gender. This creates different result sets."
  },
  {
    "id": 1058,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with the same WHERE condition. The differences are purely cosmetic: table alias, column prefix, keyword case, and single vs double quotes."
  },
  {
    "id": 1059,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for cosmetic differences in keyword case (SELECT vs select) and whitespace formatting, which are explicitly ignored according to the rules."
  },
  {
    "id": 1060,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case of the value ('Tehran' vs 'tehran'), which SQLite treats as equivalent in string comparisons."
  },
  {
    "id": 1061,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case in the string value (Tehran vs tehran), which SQLite treats as equivalent in string comparisons by default."
  },
  {
    "id": 1062,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from the same table with the same condition. The differences are purely cosmetic (keyword case, single vs double quotes, and Tehran capitalization)."
  },
  {
    "id": 1063,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The differences are purely cosmetic: keyword case (SELECT vs select), string literal style (single vs double quotes), and case in the string value ('Afghanistan' vs 'afghanistan'), which SQLite treats as equivalent in string comparisons."
  },
  {
    "id": 1064,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from the same table with the same condition, differing only in cosmetic formatting (keyword case, single vs double quotes)."
  },
  {
    "id": 1065,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from the same table with the same condition. The differences are purely cosmetic (keyword case, single vs double quotes, and case in the string literal)."
  },
  {
    "id": 1066,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE condition. The only differences are cosmetic (keyword case and whitespace)."
  },
  {
    "id": 1067,
    "db_id": "imdb",
    "strict_match": false,
    "score": 20,
    "reason": "The WHERE conditions use different string literal values ('Kevin Spacey' vs 'actor name0') that are not semantically equivalent according to the Vietnamese-English equivalence rules. These appear to be different actor names, not language translations of the same concept."
  },
  {
    "id": 1068,
    "db_id": "imdb",
    "strict_match": false,
    "score": 20,
    "reason": "The WHERE conditions use completely different string values ('Kevin Spacey' vs 'actor name0') that are not English/Vietnamese equivalents, so they filter different rows and return different results."
  },
  {
    "id": 1069,
    "db_id": "imdb",
    "strict_match": false,
    "score": 10,
    "reason": "Different tables (dien_vien vs dao_dien) and different WHERE conditions ('Kevin Spacey' vs 'director name0') - these are fundamental semantic differences that will produce different results."
  },
  {
    "id": 1070,
    "db_id": "imdb",
    "strict_match": false,
    "score": 10,
    "reason": "Different tables (dien_vien vs dao_dien) and different WHERE conditions (different column values). These queries operate on completely different data sources with different filtering criteria."
  },
  {
    "id": 1071,
    "db_id": "imdb",
    "strict_match": false,
    "score": 10,
    "reason": "Queries access different tables (dien_vien vs dao_dien) and filter by different names ('Kevin Spacey' vs 'director name0'), which are not equivalent values."
  },
  {
    "id": 1072,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value - 'Đi tìm Nemo' (Vietnamese) and 'finding nemo' (English) refer to the same movie title."
  },
  {
    "id": 1073,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same four tables with equivalent join conditions and apply identical WHERE filters (including the same director name and year condition), differing only in table aliases and join order."
  },
  {
    "id": 1074,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause filtering for the same movie title, differing only in table aliases and formatting."
  },
  {
    "id": 1075,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause filtering for the same movie title (case-insensitive). The only differences are table aliases, keyword case, and quotation style, which are cosmetic."
  },
  {
    "id": 1076,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and JOIN order. Both join the same three tables with equivalent conditions and filter on the same movie title value."
  },
  {
    "id": 1077,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases, JOIN order, and English vs Vietnamese string values for 'Alan Turing'/'alan turing' and 'Trò chơi bắt chước'/'the imitation game' which represent the same real-world entities."
  },
  {
    "id": 1078,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically identical after normalizing aliases, case, and treating English/Vietnamese string values as equivalent ('Alan Turing' = 'alan turing', 'Trò chơi bắt chước' = 'the imitation game')."
  },
  {
    "id": 1079,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only minor differences: table aliases, column order in JOIN conditions, and English vs Vietnamese string values for the same real-world entities ('Trò chơi bắt chước' = 'the imitation game', 'Alan Turing' = 'alan turing')."
  },
  {
    "id": 1080,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically identical with only cosmetic differences: table aliases, keyword case, and English/Vietnamese equivalent string values ('Alan Turing' vs 'alan turing' and 'Trò chơi bắt chước' vs 'the imitation game')."
  },
  {
    "id": 1081,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, join order, and English vs Vietnamese string values for the same real-world entities ('Trò chơi bắt chước' = 'the imitation game', 'Alan Turing' = 'alan turing')."
  },
  {
    "id": 1082,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, JOIN order, and English vs Vietnamese string literal values ('Công viên kỷ Jura' = 'jurassic park')."
  },
  {
    "id": 1083,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, JOIN order, and English vs Vietnamese string literal values ('Niềm vui' = 'joy') which have the same meaning."
  },
  {
    "id": 1084,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions and filter for the same screenwriter name, differing only in table aliases and JOIN order which doesn't affect results."
  },
  {
    "id": 1085,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries return movies where Woody Allen is both the producer AND the screenwriter, using equivalent JOIN logic with different structural approaches (INTERSECT vs single query with AND)."
  },
  {
    "id": 1086,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with equivalent join conditions and filter on the same actor name (case-insensitive and with equivalent string values). The only differences are table aliases, column aliases, formatting, and JOIN order, which are all cosmetic."
  },
  {
    "id": 1087,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with equivalent join conditions and filter on the same actor name (case-insensitive comparison). The only differences are table aliases, column aliases, formatting, and case sensitivity in the string literal, which are all cosmetic."
  },
  {
    "id": 1088,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same three tables with equivalent conditions and return the same column."
  },
  {
    "id": 1089,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical WHERE conditions (same column names and values), differing only in keyword case, whitespace, and condition order."
  },
  {
    "id": 1090,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and the WHERE condition uses English 'sci-fi' vs Vietnamese 'Khoa học viễn tưởng' which refer to the same genre (science fiction)."
  },
  {
    "id": 1091,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases and the WHERE condition uses English 'sci-fi' vs Vietnamese 'Khoa học viễn tưởng' which represent the same genre meaning."
  },
  {
    "id": 1092,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with the same WHERE conditions. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case in the string value ('Austin' vs 'austin'), which SQLite treats as equivalent in string comparisons."
  },
  {
    "id": 1093,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same column from the same table with identical WHERE conditions. The only differences are cosmetic: keyword case (SELECT vs select), string literal quotes (single vs double), and case in the string value ('Austin' vs 'austin'), which SQLite treats as case-insensitive by default for string comparisons."
  },
  {
    "id": 1094,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are keyword case (SELECT vs select), string literal quotes (single vs double), and case in string value ('Austin' vs 'austin'), which are cosmetic differences that don't affect results."
  },
  {
    "id": 1095,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same tables with equivalent conditions and filter on the same value (case-insensitive string comparison)."
  },
  {
    "id": 1096,
    "db_id": "imdb",
    "strict_match": false,
    "score": 85,
    "reason": "The queries have different WHERE conditions for 'noi_sinh' - 'Thành phố New York' vs 'new york city' - which are not listed as equivalent values in the rules. However, they likely refer to the same real-world location, making this a minor semantic difference."
  },
  {
    "id": 1097,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: different table aliases, JOIN order, and English vs Vietnamese string literal values ('nuclear weapons' = 'Vũ khí hạt nhân')."
  },
  {
    "id": 1098,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically identical - same tables, joins, and conditions. The only difference is the WHERE clause value uses Vietnamese ('Vũ khí hạt nhân') in Gen and English ('nuclear weapons') in Gold, which are equivalent translations."
  },
  {
    "id": 1099,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and filter on the same director name, returning the same movie titles. The only differences are cosmetic: table aliases, column reference aliases, case sensitivity, and single vs double quotes."
  },
  {
    "id": 1100,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same five tables with identical join conditions and WHERE clauses, differing only in table aliases, join order, and case sensitivity."
  },
  {
    "id": 1101,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions and filters, differing only in aliases, join order, and case sensitivity."
  },
  {
    "id": 1102,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions and filters, differing only in aliases, join order, and case sensitivity."
  },
  {
    "id": 1103,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions and return the same results. The differences are only cosmetic: table aliases, join order, and case sensitivity."
  },
  {
    "id": 1104,
    "db_id": "imdb",
    "strict_match": false,
    "score": 20,
    "reason": "The queries use completely different tables and join structures - Gen uses bo_phim, ban_quyen, dao_dien_boi, dao_dien while Gold uses nha_san_xuat, duoc_lam_boi, phim_truyen_hinh_nhieu_tap. They have different semantic meaning despite both searching for titles related to 'Shonda Rhimes'."
  },
  {
    "id": 1105,
    "db_id": "imdb",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables involved: Gen uses 'bo_phim' table while Gold uses 'phim_truyen_hinh_nhieu_tap' table. Different JOIN conditions: Gen joins on 'phan_vai.id_se_ri_phim = bo_phim.id_bo_phim' while Gold joins on 't2.id_se_ri_phim_truyen_hinh = t3.id_se_ri_phim'."
  },
  {
    "id": 1106,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "The queries filter on different movie titles ('Buổi diễn của Truman' vs 'the truman show'), which are not semantically equivalent string values. While the table joins are logically equivalent, the WHERE conditions differ meaningfully."
  },
  {
    "id": 1107,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences in aliases and a Vietnamese vs English string literal value that share the same meaning ('Buổi diễn của Truman' = 'the truman show')."
  },
  {
    "id": 1108,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "Different table names used: Gen uses 'bo_phim' while Gold uses 'phim_truyen_hinh_nhieu_tap' with different ID column names, indicating potentially different database schemas."
  },
  {
    "id": 1109,
    "db_id": "imdb",
    "strict_match": false,
    "score": 40,
    "reason": "Different table structures: Gen uses 'bo_phim' table while Gold uses 'phim_truyen_hinh_nhieu_tap' table with different column names for joining. The WHERE conditions also reference different column names for the actor's name."
  },
  {
    "id": 1110,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same five tables with identical join conditions and filter on the same value (Kate Winslet), returning the same director names. The differences are purely cosmetic: table aliases, keyword case, whitespace, and quote style."
  },
  {
    "id": 1111,
    "db_id": "imdb",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables and JOIN logic: Gen queries directors (dao_dien) through film roles, while Gold queries producers (nha_san_xuat) through production companies. They return different result sets."
  },
  {
    "id": 1112,
    "db_id": "imdb",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables used (bo_phim vs phim_truyen_hinh_nhieu_tap) and different WHERE conditions (different titles and column names). These are semantic differences that would produce different results."
  },
  {
    "id": 1113,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: column order in WHERE clause and English vs Vietnamese gender values ('nữ' = 'female'). Both filter for female actors born in Austin."
  },
  {
    "id": 1114,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - both filter actors born after 1980 with Italian nationality. The only differences are cosmetic (keyword case, condition order) and the nationality value uses different languages ('Ý' in Vietnamese vs 'italy' in English) which represent the same country."
  },
  {
    "id": 1115,
    "db_id": "imdb",
    "strict_match": false,
    "score": 65,
    "reason": "The WHERE conditions differ semantically: 'New York' vs 'new york city' are not equivalent locations, and 'nữ' vs 'female' are equivalent gender values but the location mismatch remains."
  },
  {
    "id": 1116,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases, join order, and English vs Vietnamese string values for gender and movie title that have the same meaning."
  },
  {
    "id": 1117,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are keyword case (SELECT vs select), string literal quotes (single vs double), and case in the literal value, which are all cosmetic differences per the rules."
  },
  {
    "id": 1118,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "The WHERE clause conditions use different string values ('Nữ binh sĩ' vs 'camp x-ray') that are not semantically equivalent according to the Vietnamese-English equivalence rules. The queries join the same tables with equivalent conditions but filter on different movie titles."
  },
  {
    "id": 1119,
    "db_id": "imdb",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return actors from Canada who appeared in James Bond films, but Gen includes extra columns (id_dien_vien, gioi_tinh, quoc_tich) while Gold only selects the name. This is a minor cosmetic difference as the core logic is identical."
  },
  {
    "id": 1120,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, column aliases, JOIN order, and Vietnamese vs English string values ('Ngài Bean' vs 'mr. bean' are equivalent character names)."
  },
  {
    "id": 1121,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences in table aliases and a Vietnamese vs English string literal value ('Quá khứ' = 'the past'). Both queries join the same three tables with identical join conditions and select the same column."
  },
  {
    "id": 1122,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, JOIN order, and English vs Vietnamese string values ('Ngài Bean' = 'mr. bean' for the same character)."
  },
  {
    "id": 1123,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and JOIN order. Both query the same tables with identical JOIN conditions and WHERE clause filtering for the same director name."
  },
  {
    "id": 1124,
    "db_id": "imdb",
    "strict_match": false,
    "score": 30,
    "reason": "Different table joins and filtering conditions - Gen uses 'nhan' and 'tu_khoa' tables filtering by keyword 'Chú vịt Daffy', while Gold uses 'phan_vai' table filtering by role 'daffy duck'."
  },
  {
    "id": 1125,
    "db_id": "imdb",
    "strict_match": false,
    "score": 20,
    "reason": "The queries join different tables and have different WHERE conditions. Generated query joins only bo_phim and phan_vai, while Gold query also joins dien_vien table and uses a different movie title value."
  },
  {
    "id": 1126,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same five tables with identical join conditions and filter on the same keyword value (case-insensitive English string). The only differences are table aliases, formatting, and keyword case, which are cosmetic."
  },
  {
    "id": 1127,
    "db_id": "imdb",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries count movies starring Jennifer Aniston released after 2010, but Gen uses COUNT(*) while Gold uses COUNT(DISTINCT t2.tieu_de) - these could differ if there are duplicate movie titles or if phan_vai has multiple roles per movie."
  },
  {
    "id": 1128,
    "db_id": "imdb",
    "strict_match": true,
    "score": 95,
    "reason": "Both queries count actors in the same movie, but Gen uses COUNT(*) while Gold uses COUNT(DISTINCT t1.ten) - if actor names are unique per actor, they're equivalent. The movie title difference ('Giải cứu binh nhì Ryan' vs 'saving private ryan') is just English/Vietnamese equivalents."
  },
  {
    "id": 1129,
    "db_id": "imdb",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries count distinct actors from the same three tables with identical join conditions. The only difference is the movie title value ('Giải cứu binh nhì Ryan' vs 'saving private ryan'), which are Vietnamese/English equivalents with the same semantic meaning."
  },
  {
    "id": 1130,
    "db_id": "imdb",
    "strict_match": false,
    "score": 30,
    "reason": "Gen counts all director appearances while Gold counts distinct movie titles; different tables involved (Gen lacks bo_phim table) and different aggregation logic."
  },
  {
    "id": 1131,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "Gen counts all rows with nam_phat_hanh=2013, while Gold counts distinct tieu_de values for the same condition. These produce different results when there are duplicate tieu_de values."
  },
  {
    "id": 1132,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "Gen counts all rows with nam_phat_hanh=2013, while Gold counts distinct tieu_de values for that year. These produce different results when there are duplicate tieu_de values."
  },
  {
    "id": 1133,
    "db_id": "imdb",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(*) which counts all rows, while Gold uses COUNT(DISTINCT t3.tieu_de) which counts distinct movie titles. These will produce different results when the same director has multiple movies with the same title in the same year."
  },
  {
    "id": 1134,
    "db_id": "imdb",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables and columns used: Gen queries phan_vai and bo_phim with id_se_ri_phim, while Gold queries phan_vai, dien_vien, and bo_phim with tieu_de. Different WHERE conditions and join structures."
  },
  {
    "id": 1135,
    "db_id": "imdb",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count distinct movies where actor 'Shahab Hosseini' appears, using the same tables and join conditions with only cosmetic differences in aliases, formatting, and column references."
  },
  {
    "id": 1136,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "Different tables and columns: Gen uses phan_vai.id_se_ri_phim while Gold uses bo_phim.tieu_de via an additional JOIN to bo_phim table. These count different columns from different tables."
  },
  {
    "id": 1137,
    "db_id": "imdb",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables involved - Gen uses only phan_vai and dien_vien, while Gold also joins bo_phim. Different column references - Gen counts id_se_ri_phim from phan_vai, Gold counts tieu_de from bo_phim."
  },
  {
    "id": 1138,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different aggregation logic: Gen counts all rows while Gold counts distinct names, which can produce different results when duplicate names exist."
  },
  {
    "id": 1139,
    "db_id": "imdb",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries count Humphrey Bogart's films released before 1942, but Gen uses COUNT(*) while Gold uses COUNT(DISTINCT t2.tieu_de), which could differ if films have duplicate titles or if phan_vai has multiple roles per film. The table joins and WHERE conditions are semantically equivalent."
  },
  {
    "id": 1140,
    "db_id": "imdb",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries count movies per release year for Brad Pitt, but Gen uses COUNT(*) while Gold uses COUNT(DISTINCT t2.tieu_de) - these could return different results if there are duplicate movie titles. The main answer (release years with counts) is correct, but the aggregation differs."
  },
  {
    "id": 1141,
    "db_id": "imdb",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(*) which counts all rows, while Gold uses COUNT(DISTINCT t3.tieu_de) which counts distinct titles. The WHERE conditions are semantically equivalent (Vietnamese vs English keywords, same year)."
  },
  {
    "id": 1142,
    "db_id": "imdb",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic (COUNT(*) vs COUNT(DISTINCT tieu_de)) and different WHERE conditions ('Ba Tư' vs 'persians' are not equivalent values)."
  },
  {
    "id": 1143,
    "db_id": "imdb",
    "strict_match": false,
    "score": 65,
    "reason": "Different aggregation logic: Gen uses COUNT(*) while Gold uses COUNT(DISTINCT t3.tieu_de), which will return different results when there are duplicate titles. The table aliases and join conditions are equivalent after normalization."
  },
  {
    "id": 1144,
    "db_id": "imdb",
    "strict_match": false,
    "score": 65,
    "reason": "The queries have different aggregation logic: Gen uses COUNT(*) which counts all rows, while Gold uses COUNT(DISTINCT t3.tieu_de) which counts distinct movie titles. These could return different results if there are duplicate movie titles in the results."
  },
  {
    "id": 1145,
    "db_id": "imdb",
    "strict_match": false,
    "score": 30,
    "reason": "Different table joins and WHERE conditions: Gold query joins additional tables (duoc_lam_boi, nha_san_xuat) and has opposite year range (2002-2010 vs <2002 AND >2010)."
  },
  {
    "id": 382,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select gender and count from the same table with identical WHERE condition and GROUP BY logic. The only differences are column order and whitespace formatting, which are cosmetic."
  },
  {
    "id": 383,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same aggregate functions (MAX and MIN) on the same columns from the same table, with only cosmetic differences in formatting and column aliases."
  },
  {
    "id": 384,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same aggregate functions (MAX and MIN) on the same columns from the same table, with only cosmetic differences in formatting and column aliases."
  },
  {
    "id": 385,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and string literal values. Both select the same column from the same tables with identical JOIN conditions, WHERE filters, and ORDER BY clauses."
  },
  {
    "id": 386,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same tables with identical join conditions and select the same column (ten). The only differences are table aliases, column aliases in SELECT, and the gender value ('nữ' vs 'F'), which are semantically equivalent according to Vietnamese-English value equivalence rules."
  },
  {
    "id": 387,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from the same table using the same subquery condition with only cosmetic differences in formatting and keyword case."
  },
  {
    "id": 388,
    "db_id": "candidate_poll",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select names from the same table using the same subquery condition comparing height to average height. The only differences are cosmetic (keyword case, whitespace, and parentheses formatting)."
  },
  {
    "id": 389,
    "db_id": "candidate_poll",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return data from the same table, but Gen explicitly selects specific columns while Gold uses SELECT * which returns all columns. The result sets will differ in column count and content on any database state."
  },
  {
    "id": 390,
    "db_id": "candidate_poll",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return data from the same table, but Gen explicitly selects specific columns while Gold uses SELECT * which returns all columns. On any database state, Gen's result set will be a subset of Gold's result set."
  },
  {
    "id": 391,
    "db_id": "city_record",
    "strict_match": false,
    "score": 40,
    "reason": "Gen query joins with 'thanh_pho' table and selects 'id_thanh_pho' column, while Gold query selects 'thanh_pho_chu_nha' column directly from 'thanh_pho_chu_nha' table without any join. These are fundamentally different queries with different table structures and selected columns."
  },
  {
    "id": 392,
    "db_id": "city_record",
    "strict_match": false,
    "score": 40,
    "reason": "The queries have fundamentally different logic: Gen joins two tables and filters by maximum year, while Gold selects from a single table with ORDER BY and LIMIT. They return different columns (id_thanh_pho vs thanh_pho_chu_nha) and could produce different results."
  },
  {
    "id": 393,
    "db_id": "city_record",
    "strict_match": false,
    "score": 40,
    "reason": "The WHERE conditions use different string literals that are not semantically equivalent - 'vòng loại FIFA World Cup 1994' (Vietnamese for '1994 FIFA World Cup qualification round') is not the same as '1994 fifa world cup qualification' (English for the entire qualification process)."
  },
  {
    "id": 394,
    "db_id": "city_record",
    "strict_match": false,
    "score": 40,
    "reason": "The WHERE conditions use different string literals that are not semantically equivalent - 'vòng loại FIFA World Cup 1994' (Vietnamese for '1994 FIFA World Cup qualification') vs '1994 fifa world cup qualification' (English). While both reference the same tournament, the literal values differ and would not match in SQL string comparison."
  },
  {
    "id": 395,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and column references. Both join the same tables with the same condition and apply the same WHERE filter."
  },
  {
    "id": 396,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same ON condition, apply the same WHERE filter, and select the same column. The only differences are cosmetic (aliases and keyword case)."
  },
  {
    "id": 397,
    "db_id": "city_record",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries join the same tables with the same condition and return the city with the highest count, but they GROUP BY different columns (id_thanh_pho vs thanh_pho_chu_nha). Since these columns are likely functionally dependent in the join, they are semantically equivalent with minor variation."
  },
  {
    "id": 398,
    "db_id": "city_record",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries return the city with the most homeowner associations, but Gen groups by city ID while Gold groups by homeowner association ID. If city ID uniquely determines city name, they are semantically equivalent."
  },
  {
    "id": 399,
    "db_id": "city_record",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same three tables with equivalent join conditions and filter on the same tournament and city, with only minor differences in table aliases, column order in joins, and English vs Vietnamese string values that have the same semantic meaning."
  },
  {
    "id": 400,
    "db_id": "city_record",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries join the same three tables with equivalent join conditions and filter on the same tournament and city, just with different table aliases and slightly different string values that represent the same semantic meaning."
  },
  {
    "id": 401,
    "db_id": "city_record",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases (t1/t2 vs none), keyword case, and English vs Vietnamese city name ('Shanghai' vs 'Thượng Hải') which represent the same real-world entity."
  },
  {
    "id": 402,
    "db_id": "city_record",
    "strict_match": false,
    "score": 50,
    "reason": "Different WHERE conditions: 'Thượng Hải' vs 'shanghai' are not equivalent values (different cities, not English/Vietnamese equivalents). Different table aliases and JOIN order are cosmetic differences."
  },
  {
    "id": 403,
    "db_id": "city_record",
    "strict_match": true,
    "score": 98,
    "reason": "Queries are semantically identical after normalizing aliases, table order, and treating Vietnamese/English city names as equivalent. The only difference is Gold uses table aliases while Gen doesn't, which is cosmetic."
  },
  {
    "id": 404,
    "db_id": "city_record",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent after normalizing aliases and treating Vietnamese/English city names as equivalent values. The only difference is the city name in the WHERE clause uses Vietnamese vs English spelling."
  },
  {
    "id": 405,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column (thanh_pho) from the same table (thanh_pho) with identical ORDER BY and LIMIT clauses. The only differences are cosmetic: column alias usage and keyword case."
  },
  {
    "id": 406,
    "db_id": "city_record",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return the top 3 cities by population, but Gen includes an extra column (dan_so_khu_vuc) in SELECT that wasn't requested in Gold. This is a minor cosmetic difference that doesn't change the main answer."
  },
  {
    "id": 407,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (city and GDP) from the same table, order by GDP ascending with LIMIT 1 to get the smallest GDP. The differences are purely cosmetic: table alias usage, column qualification, and explicit ASC keyword."
  },
  {
    "id": 408,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same columns from the same table with the same ordering and limit. The only differences are cosmetic (keyword case, whitespace, and explicit ASC keyword)."
  },
  {
    "id": 409,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, select the same column, order by the same column in the same direction, and limit to 1 row. The only differences are cosmetic (aliases, formatting, and keyword case)."
  },
  {
    "id": 410,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they join the same tables with the same conditions, select the same column, and use the same ordering and limit. The only differences are table aliases and keyword case, which are cosmetic."
  },
  {
    "id": 411,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with the same conditions and apply identical WHERE logic."
  },
  {
    "id": 412,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and ignoring cosmetic differences. Both join the same tables with the same conditions and apply identical WHERE logic."
  },
  {
    "id": 413,
    "db_id": "city_record",
    "strict_match": false,
    "score": 50,
    "reason": "Different logic: Gen uses WHERE with AND conditions on both tables, while Gold uses INTERSECT between two separate queries with different conditions."
  },
  {
    "id": 414,
    "db_id": "city_record",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query joins wrong tables (thanh_pho_chu_nha instead of nhiet_do) and has incorrect WHERE condition referencing non-existent table. Gold query uses INTERSECT with two separate joins to nhiet_do and thanh_pho_chu_nha tables."
  },
  {
    "id": 415,
    "db_id": "city_record",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return cities where March temperature is less than December temperature, excluding cities that are homeowner cities. The Gen uses NOT IN with a subquery while Gold uses EXCEPT with a JOIN - these are semantically equivalent approaches for set exclusion, and EXCEPT is preferred SQL practice."
  },
  {
    "id": 416,
    "db_id": "city_record",
    "strict_match": true,
    "score": 98,
    "reason": "Both queries return cities with March temperature lower than December temperature that are not home cities. Gen uses LEFT JOIN + IS NULL exclusion, Gold uses EXCEPT - both are semantically equivalent approaches for set exclusion."
  },
  {
    "id": 417,
    "db_id": "city_record",
    "strict_match": false,
    "score": 50,
    "reason": "Different logic: Gen uses OR with IN subquery while Gold uses UNION with separate JOIN. The IN subquery selects from thanh_pho_chu_nha without JOIN condition, potentially returning different results than Gold's explicit JOIN."
  },
  {
    "id": 418,
    "db_id": "city_record",
    "strict_match": false,
    "score": 50,
    "reason": "The second SELECT statements differ semantically: Gen uses T1.thanh_pho with JOIN condition T1.id_thanh_pho = T3.thanh_pho_chu_nha, while Gold uses T3.thanh_pho with JOIN condition T3.id_thanh_pho = T4.thanh_pho_chu_nha, which are not equivalent."
  },
  {
    "id": 419,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical WHERE conditions, differing only in table alias usage and keyword case which are cosmetic differences."
  },
  {
    "id": 420,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column (thanh_pho) from the same table with identical WHERE conditions. The only differences are cosmetic: keyword case and explicit table prefix in the column reference."
  },
  {
    "id": 421,
    "db_id": "city_record",
    "strict_match": false,
    "score": 50,
    "reason": "Different logical conditions: Gen uses OR with thresholds 8M and 5M, Gold uses UNION with thresholds 10M and 5M. These produce different result sets for populations between 8M-10M."
  },
  {
    "id": 422,
    "db_id": "city_record",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different logical conditions: Gen uses OR with two ranges (population > 8M OR < 5M), while Gold uses UNION with different ranges (population > 10M OR < 5M). These produce different result sets for populations between 8M-10M."
  },
  {
    "id": 423,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (giai_dau and COUNT(*)) from the same table (tran_dau) with the same GROUP BY clause. The only differences are cosmetic: column order in SELECT, whitespace formatting, and keyword case."
  },
  {
    "id": 424,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (giai_dau and COUNT(*)) from the same table with the same GROUP BY clause. The only differences are cosmetic: column order in SELECT, whitespace formatting, and keyword case."
  },
  {
    "id": 425,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same column from the same table with identical ordering, differing only in table alias usage and keyword case which are cosmetic differences."
  },
  {
    "id": 426,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical except for keyword case (SELECT vs select), which is a cosmetic difference that does not affect the semantic meaning. Both queries select the same column from the same table with the same ordering."
  },
  {
    "id": 427,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns in SELECT and ORDER BY, same ordering direction, and same LIMIT clause. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 428,
    "db_id": "city_record",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same table, same columns selected, same ordering by the same column in the same direction, and same limit. The only differences are cosmetic (keyword case and formatting)."
  },
  {
    "id": 429,
    "db_id": "city_record",
    "strict_match": false,
    "score": 20,
    "reason": "Different JOIN conditions: Gen uses 'thanh_pho.thanh_pho = thanh_pho_chu_nha.thanh_pho_chu_nha' while Gold uses 't1.id_thanh_pho = t2.thanh_pho_chu_nha'. Different GROUP BY columns: Gen groups by 'thanh_pho.thanh_pho' while Gold groups by 't2.thanh_pho_chu_nha'."
  },
  {
    "id": 430,
    "db_id": "city_record",
    "strict_match": false,
    "score": 65,
    "reason": "Different GROUP BY columns (thanh_pho.id_thanh_pho vs t2.thanh_pho_chu_nha) and different SELECT columns (Gen includes thanh_pho.thanh_pho while Gold does not)."
  },
  {
    "id": 431,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases, keyword case, and English vs Vietnamese string values ('Kế toán' = 'accounting' for accounting department)."
  },
  {
    "id": 432,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases, keyword case, and English vs Vietnamese string values ('Kế toán' = 'accounting' for accounting department)."
  },
  {
    "id": 433,
    "db_id": "college_1",
    "strict_match": false,
    "score": 20,
    "reason": "The queries have fundamentally different semantics: Gen counts all rows with ma_lop_hoc='ACCT-211', while Gold counts distinct ma_so_nhan_vien_cua_giao_su values where ma_khoa_hoc='acct-211'. They use different columns for both counting and filtering."
  },
  {
    "id": 434,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions (ma_lop_hoc vs ma_khoa_hoc) and different JOIN logic (Gen joins multiple tables while Gold queries only lop_hoc). These are semantic differences that can produce different results."
  },
  {
    "id": 435,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, column order, and English vs Vietnamese string value ('Sinh học' = 'biology' for department name). Both join the same tables with identical conditions."
  },
  {
    "id": 436,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases and English vs Vietnamese string literal values ('Sinh học' vs 'biology') that represent the same real-world meaning."
  },
  {
    "id": 437,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same tables with equivalent JOIN conditions and WHERE filters, differing only in aliases and formatting. The DISTINCT in Gold doesn't affect results since the JOIN conditions ensure uniqueness."
  },
  {
    "id": 438,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables involved (Gen uses giao_su table, Gold doesn't) and different column selections (Gen selects ho_cua_nhan_vien, Gold selects ten_cua_nhan_vien). These are semantic differences that affect results."
  },
  {
    "id": 439,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count the same rows by joining the same tables with equivalent join conditions and identical WHERE clause filtering on the same column with the same value (case-insensitive). The only differences are cosmetic: table aliases, keyword case, whitespace, and quote style."
  },
  {
    "id": 440,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "Generated query includes an extra JOIN to the 'giao_su' table that is not present in the Gold query, which changes the semantics and could return different results depending on the data relationships."
  },
  {
    "id": 441,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value - 'Kế toán' (Vietnamese for accounting) and 'accounting' (English) refer to the same real-world concept."
  },
  {
    "id": 442,
    "db_id": "college_1",
    "strict_match": false,
    "score": 20,
    "reason": "Different columns selected (ma_khoa vs ma_truong) and different WHERE clause values ('Kế toán' vs 'accounting') that are not equivalent according to the provided rules."
  },
  {
    "id": 443,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences: keyword case (SELECT vs select), whitespace formatting, and single vs double quotes around the string literal 'CIS-220'/'cis-220' (case-insensitive string comparison in SQLite)."
  },
  {
    "id": 444,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences: column order in SELECT clause, keyword case, and single vs double quotes for string literal. Both query the same table with the same WHERE condition."
  },
  {
    "id": 445,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically identical except for the WHERE clause value: 'Lịch sử' (Vietnamese for 'History') vs 'history' (English). According to Rule 5, English and Vietnamese equivalent values should be treated as semantically equivalent."
  },
  {
    "id": 446,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only a language difference in the WHERE clause value - 'Lịch sử' (Vietnamese) and 'history' (English) refer to the same real-world concept."
  },
  {
    "id": 447,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct dia_chi_khoa values from khoa table where ma_truong equals 'BUS' (case-insensitive comparison). The only differences are cosmetic: keyword case, whitespace formatting, and single vs double quotes around the string literal."
  },
  {
    "id": 448,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct dia_chi_khoa values from khoa table where ma_truong equals 'BUS' (case-insensitive string comparison). The only differences are cosmetic: keyword case, whitespace, and single vs double quotes."
  },
  {
    "id": 449,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns with the same aggregation (COUNT DISTINCT) and GROUP BY the same column. The only differences are cosmetic: column order in SELECT and whitespace formatting."
  },
  {
    "id": 450,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - they select the same columns with the same aggregation (COUNT DISTINCT), group by the same column, and only differ in column order and whitespace formatting."
  },
  {
    "id": 451,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical with only cosmetic differences: column order in SELECT is reversed, keyword case differs, and string literal uses single vs double quotes with case-insensitive value."
  },
  {
    "id": 452,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - same table, columns, and WHERE condition with only cosmetic differences in keyword case, whitespace, and single vs double quotes."
  },
  {
    "id": 453,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic: Gen counts all rows per ma_truong, Gold counts distinct ten_khoa values per ma_truong. These can return different results if multiple rows have the same ten_khoa value."
  },
  {
    "id": 454,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different aggregation logic: Gen uses COUNT(*) which counts all rows per group, while Gold uses COUNT(DISTINCT ten_khoa) which counts distinct values of ten_khoa per group. These can produce different results if ten_khoa has duplicate values within groups."
  },
  {
    "id": 455,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different aggregation logic: Gen counts all rows per ma_truong, while Gold counts distinct ten_khoa values per ma_truong. These would return different results when there are duplicate ten_khoa values within the same ma_truong group."
  },
  {
    "id": 456,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different aggregation logic: Gen counts all rows per ma_truong, while Gold counts distinct ten_khoa values per ma_truong. These will return different results when duplicate ten_khoa values exist within the same ma_truong group."
  },
  {
    "id": 457,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different tables - Gen joins khoa_hoc and lop_hoc while Gold only uses lop_hoc. This creates different semantics as Gen counts courses with classes while Gold counts all classes grouped by course."
  },
  {
    "id": 458,
    "db_id": "college_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries count classes grouped by course code, but Gen includes an unnecessary JOIN to the khoa_hoc table that doesn't affect the grouping or counting logic. The JOIN adds no filtering or additional columns, making the results semantically equivalent."
  },
  {
    "id": 459,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The generated query includes an unnecessary JOIN with the 'khoa' table, while the gold query aggregates directly from 'khoa_hoc' without any JOIN. These queries will return different results if there are rows in 'khoa_hoc' with 'ma_khoa' values that don't exist in the 'khoa' table."
  },
  {
    "id": 460,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query joins the 'khoa' table while the Gold query only uses 'khoa_hoc'. This changes the data being aggregated since Gen includes only khoa_hoc records that match khoa records, while Gold aggregates all khoa_hoc records regardless of khoa existence."
  },
  {
    "id": 461,
    "db_id": "college_1",
    "strict_match": false,
    "score": 70,
    "reason": "Both queries count classrooms with multiple classes, but Gen returns a single count while Gold returns counts per classroom with classroom identifiers."
  },
  {
    "id": 462,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (phong_hoc and COUNT(*)) from the same table with identical GROUP BY and HAVING conditions. The only differences are column order in SELECT and table alias usage, which are cosmetic."
  },
  {
    "id": 463,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Generated query includes an extra JOIN to the 'khoa' table and selects 'ten_khoa' column, while Gold query only joins 'lop_hoc' and 'khoa_hoc' and selects 'ma_khoa'. These are different table sets and different selected columns."
  },
  {
    "id": 464,
    "db_id": "college_1",
    "strict_match": false,
    "score": 65,
    "reason": "Gen query includes an extra JOIN with 'khoa' table that Gold doesn't have, which changes the grouping and counting logic. Gold groups by ma_khoa from khoa_hoc table, while Gen groups by khoa.ma_khoa after joining with khoa table."
  },
  {
    "id": 465,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases and column order. Both perform the same joins, grouping, and aggregation to count records per ma_truong."
  },
  {
    "id": 466,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column order. Both join the same tables with identical conditions and perform the same aggregation."
  },
  {
    "id": 467,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, group by the same column, and perform the same aggregation. The differences are purely cosmetic: table aliases, column order in SELECT, and whitespace formatting."
  },
  {
    "id": 468,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, column order, and JOIN syntax. Both count records grouped by ma_truong from the same tables with the same JOIN condition."
  },
  {
    "id": 469,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same tables, columns, grouping, aggregation, ordering, and limit. The only differences are cosmetic whitespace variations and parentheses around COUNT(*), which are ignored."
  },
  {
    "id": 470,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are identical in all semantic aspects - same SELECT columns, same FROM table, same GROUP BY column, same ORDER BY with LIMIT, and same aggregation. Only minor whitespace and formatting differences exist."
  },
  {
    "id": 471,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same condition, group by the same column, and order by the same aggregate function with the same limit. The only differences are cosmetic (aliases, formatting, and keyword case)."
  },
  {
    "id": 472,
    "db_id": "college_1",
    "strict_match": false,
    "score": 20,
    "reason": "The queries select different columns (ten_khoa vs ma_truong) and group by different columns (ma_khoa vs ma_truong), which are semantically different operations that will produce different result sets."
  },
  {
    "id": 473,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different tables involved (Gen includes JOIN with khoa table, Gold only uses giao_su) and different grouping columns (Gen groups by khoa.ma_khoa, Gold groups by ma_khoa from giao_su). The WHERE clause values are semantically equivalent ('Tiến sĩ' = 'ph.d.')."
  },
  {
    "id": 474,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different table joins: Gen query joins 'khoa' table while Gold query only uses 'giao_su' table. Different WHERE conditions: 'Tiến sĩ' vs 'ph.d.' are not equivalent values in the provided mapping."
  },
  {
    "id": 475,
    "db_id": "college_1",
    "strict_match": false,
    "score": 65,
    "reason": "The queries join different tables - Gen includes a JOIN with 'khoa' table to get 'ten_khoa', while Gold only selects from 'sinh_vien' and returns 'ma_khoa'. This creates different result columns and potentially different rows if there are orphaned records."
  },
  {
    "id": 476,
    "db_id": "college_1",
    "strict_match": false,
    "score": 65,
    "reason": "The queries join different tables - Gen includes a JOIN with khoa table and selects khoa.ten_khoa, while Gold only uses sinh_vien table and selects ma_khoa. This creates different result structures and potential data differences."
  },
  {
    "id": 477,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The Gen query joins with the 'khoa' table and groups by 'khoa.ma_khoa', while the Gold query groups by 'ma_khoa' directly from 'sinh_vien' without joining. These are semantically different unless 'ma_khoa' values are identical across both tables."
  },
  {
    "id": 478,
    "db_id": "college_1",
    "strict_match": false,
    "score": 65,
    "reason": "The Gold query groups by ma_khoa and selects ma_khoa, while the Gen query groups by khoa.ma_khoa and selects khoa.ten_khoa. These return different columns (department code vs department name), which are not functionally equivalent unless ma_khoa uniquely determines ten_khoa."
  },
  {
    "id": 479,
    "db_id": "college_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries compute the same aggregates per department, but Gen includes an unnecessary JOIN to the 'khoa' table while Gold aggregates directly from 'sinh_vien'. The JOIN doesn't change results if ma_khoa is a foreign key, making this a minor difference."
  },
  {
    "id": 480,
    "db_id": "college_1",
    "strict_match": false,
    "score": 85,
    "reason": "Both queries calculate the same aggregate statistics (MAX, MIN, AVG GPA) grouped by department, but Gen includes an unnecessary JOIN with the 'khoa' table while Gold only uses 'sinh_vien' table. Since ma_khoa is already in sinh_vien table, the JOIN doesn't change the results but adds complexity."
  },
  {
    "id": 481,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases and column references. Both calculate average GPA per department and return the department with highest average."
  },
  {
    "id": 482,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "The queries use completely different tables and join logic - Gen joins through dang_ky_khoa_hoc, lop_hoc, and khoa_hoc tables while Gold directly joins sinh_vien and khoa tables. They also aggregate different columns (diem_so vs gpa_cua_sinh_vien) from different tables."
  },
  {
    "id": 483,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of ma_truong from the khoa table, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 484,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both count distinct values of ma_truong from the khoa table, with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 485,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries differ semantically: Gen counts all rows in lop_hoc, while Gold counts distinct values of ma_lop_hoc. These will return different results when ma_lop_hoc contains duplicates."
  },
  {
    "id": 486,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries differ semantically: Gen counts all rows in lop_hoc, while Gold counts distinct values of ma_lop_hoc. These will only return the same result if ma_lop_hoc has no duplicates, which is not guaranteed for all possible database states."
  },
  {
    "id": 487,
    "db_id": "college_1",
    "strict_match": false,
    "score": 20,
    "reason": "Different tables (khoa_hoc vs lop_hoc) and different aggregation logic (COUNT(*) vs COUNT(DISTINCT ma_khoa_hoc)). These queries will return different results on most database states."
  },
  {
    "id": 488,
    "db_id": "college_1",
    "strict_match": false,
    "score": 20,
    "reason": "The queries count different things from different tables - Gen counts all rows in 'khoa_hoc' table while Gold counts distinct course codes from 'lop_hoc' table. These are fundamentally different operations on different data sources."
  },
  {
    "id": 489,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "COUNT(*) counts all rows including duplicates, while COUNT(DISTINCT ten_khoa) counts only unique values of ten_khoa column. These will return different results when there are duplicate ten_khoa values."
  },
  {
    "id": 490,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "COUNT(*) counts all rows including duplicates, while COUNT(DISTINCT ten_khoa) counts only unique values of ten_khoa. These will return different results when there are duplicate ten_khoa values."
  },
  {
    "id": 491,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences: table aliases, keyword case, and English vs Vietnamese string values for the same real-world meaning ('Hệ thống thông tin máy tính' = 'computer info. systems')."
  },
  {
    "id": 492,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences (aliases, formatting) and a Vietnamese vs English string value difference where 'Hệ thống thông tin máy tính' and 'computer info. systems' represent the same real-world meaning."
  },
  {
    "id": 493,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different logic: Gen counts all rows from joined tables with specific course code, while Gold counts distinct class sections for that course code. These produce different results when there are duplicate class sections."
  },
  {
    "id": 494,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries count distinct lop_hoc_phan values for the same course code, with Gen using an explicit JOIN that doesn't change the result since it's an inner join on the same condition as Gold's WHERE clause."
  },
  {
    "id": 495,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses khoa JOIN khoa_hoc, Gold uses khoa_hoc JOIN lop_hoc) and different JOIN conditions, leading to fundamentally different result sets."
  },
  {
    "id": 496,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses khoa JOIN khoa_hoc, Gold uses khoa_hoc JOIN lop_hoc) and different JOIN conditions (Gen joins on ma_khoa, Gold joins on ma_khoa_hoc). These are fundamental semantic differences."
  },
  {
    "id": 497,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different JOIN logic - Gen joins khoa directly with khoa_hoc, while Gold joins khoa_hoc with lop_hoc first before joining khoa. Different GROUP BY columns - Gen groups by khoa.ma_khoa, Gold groups by t1.ma_khoa (which is khoa_hoc.ma_khoa)."
  },
  {
    "id": 498,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different JOIN logic: Gen joins khoa directly with khoa_hoc, while Gold joins khoa_hoc with lop_hoc first, then with khoa. This changes which rows are aggregated."
  },
  {
    "id": 499,
    "db_id": "college_1",
    "strict_match": false,
    "score": 65,
    "reason": "Gen query counts DISTINCT student IDs from registrations for a specific course, while Gold query counts all rows from classes for that course. Different aggregation logic (COUNT DISTINCT vs COUNT) and different tables being counted."
  },
  {
    "id": 500,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different WHERE conditions: Gen filters by ma_lop_hoc='ACCT-211' while Gold filters by ma_khoa_hoc='acct-211'. Different aggregation: Gen uses COUNT(DISTINCT ma_so_sinh_vien) while Gold uses COUNT(*)."
  },
  {
    "id": 501,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return students enrolled in course 'ACCT-211', but Gen includes an extra column (ho_cua_sinh_vien) in SELECT that Gold doesn't request. All joins, conditions, and logic are otherwise identical."
  },
  {
    "id": 502,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different JOIN conditions and WHERE clause logic: Gen uses khoa_hoc table with ma_khoa_hoc='ACCT-211', while Gold uses lop_hoc table with ma_khoa_hoc='acct-211' and different table relationships."
  },
  {
    "id": 503,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries select different columns - Gen selects both ho_cua_sinh_vien and ten_cua_sinh_vien, while Gold selects only ten_cua_sinh_vien. This is a semantic difference that affects the result set structure."
  },
  {
    "id": 504,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return students enrolled in ACCT-211 with grade C, but Generated query includes both first and last name columns while Gold query only includes first name. The main answer (which students) is correct despite the extra column."
  },
  {
    "id": 505,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 506,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they count all rows from the same table with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 507,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - both count records where the highest degree is a doctorate. The only difference is the language used for the string literal value ('Tiến sĩ' vs 'ph.d.'), which represent the same real-world meaning."
  },
  {
    "id": 508,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent - both count records where the highest degree is a doctorate. The only difference is English vs Vietnamese terminology for the same academic degree."
  },
  {
    "id": 509,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses sinh_vien and giao_su, Gold uses khoa_hoc and khoa) and different filtering conditions (Gen filters by giao_su.ma_khoa, Gold filters by khoa.ten_khoa). These are semantic differences that would produce different results on many database states."
  },
  {
    "id": 510,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables involved (Gen uses sinh_vien and giao_su tables, Gold uses khoa_hoc table instead) and different WHERE conditions (Gen filters by ma_khoa='Kế toán', Gold filters by ten_khoa='accounting')."
  },
  {
    "id": 511,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "The queries join completely different tables and have different GROUP BY logic. Generated query uses sinh_vien and khoa tables, while Gold query uses lop_hoc, dang_ky_khoa_hoc, khoa_hoc, and khoa tables with a complex join chain."
  },
  {
    "id": 512,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different tables and JOIN logic: Gen uses sinh_vien and khoa tables, while Gold uses lop_hoc, dang_ky_khoa_hoc, khoa_hoc, and khoa tables with different relationships."
  },
  {
    "id": 513,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they select the same column from the same table with the same ordering. The only differences are cosmetic (keyword case and explicit ASC specification)."
  },
  {
    "id": 514,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - both select the same column from the same table with the same ordering. The only differences are cosmetic (keyword case and explicit ASC specification)."
  },
  {
    "id": 515,
    "db_id": "college_1",
    "strict_match": false,
    "score": 20,
    "reason": "The queries select different columns (ma_khoa_hoc vs ma_lop_hoc) from different table combinations (JOIN vs single table), which are fundamentally different semantically and will return different results."
  },
  {
    "id": 516,
    "db_id": "college_1",
    "strict_match": false,
    "score": 20,
    "reason": "Different columns selected (ma_khoa_hoc vs ma_lop_hoc) and different string values in WHERE clause ('KLR 209' vs 'klr209') which are not equivalent."
  },
  {
    "id": 517,
    "db_id": "college_1",
    "strict_match": false,
    "score": 85,
    "reason": "The queries differ in SELECT columns (Gen includes both ho_cua_nhan_vien and ten_cua_nhan_vien, Gold only ten_cua_nhan_vien) and WHERE values ('Giáo sư' vs 'prof'), but the WHERE values are semantically equivalent job titles in Vietnamese and English."
  },
  {
    "id": 518,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Different table joins and WHERE conditions: Gen joins with giao_su table while Gold filters by ma_cong_viec_cua_nhan_vien = 'prof'. These queries will return different results on most database states."
  },
  {
    "id": 519,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform identical JOIN operations between the same tables with the same conditions, select the same columns, and use the same ORDER BY clause. The only differences are cosmetic: table aliases (t1/t2 vs table names) and keyword case."
  },
  {
    "id": 520,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries perform identical JOIN operations between the same tables with the same conditions, select the same columns, and use the same ORDER BY clause. The only differences are cosmetic: table aliases and keyword case."
  },
  {
    "id": 521,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical - only differences are column order in SELECT (ho_cua_nhan_vien vs ten_cua_nhan_vien first) and explicit ASC keyword, which are cosmetic differences per the rules."
  },
  {
    "id": 522,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns (only order differs), from the same table, with identical ORDER BY and LIMIT clauses. The differences are purely cosmetic: column order in SELECT, keyword case, and whitespace."
  },
  {
    "id": 523,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "Different ORDER BY direction (ASC vs DESC) changes which row is selected by LIMIT 1, resulting in potentially different results."
  },
  {
    "id": 524,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical with only cosmetic differences in keyword case and whitespace formatting."
  },
  {
    "id": 525,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return students with grade 'C', but Gen includes both first and last name columns while Gold only selects last name with DISTINCT. The column selection difference is minor since both identify the same students."
  },
  {
    "id": 526,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return students with grade 'C', but Gen includes both first and last names while Gold only selects first name and uses DISTINCT, which could produce different result sets if students share the same first name."
  },
  {
    "id": 527,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same key column, and return the same result with identical ordering and limiting. The differences are purely cosmetic (aliases, formatting, and column references)."
  },
  {
    "id": 528,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same key (ma_khoa), and order by count ascending with limit 1. Differences are only cosmetic: table aliases, column aliases, and whitespace."
  },
  {
    "id": 529,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only two minor differences: 1) 'tiến sĩ' vs 'ph.d.' are equivalent academic degree values (Vietnamese vs English), and 2) Gen includes COUNT(*) in SELECT while Gold doesn't, but both return the same main answer (ten_khoa)."
  },
  {
    "id": 530,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only minor differences: table aliases are swapped (T1/T2 vs t1/t2), column selection differs slightly (T1.ten_khoa vs t2.ten_khoa, t1.ma_khoa), and the WHERE condition uses equivalent English/Vietnamese values ('tiến sĩ' = 'ph.d.'). Both queries join the same tables with the same condition, group by the same key, and return the department with the most PhD professors."
  },
  {
    "id": 531,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different logic: Gen finds employees who are professors but not teaching any classes, while Gold finds employees with job 'prof' except those teaching classes. Different WHERE conditions and different exclusion approaches."
  },
  {
    "id": 532,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different logic: Gen finds employees who are professors but not teaching any class, while Gold finds employees with job 'prof' except those teaching any class. Different WHERE conditions and different exclusion approaches."
  },
  {
    "id": 533,
    "db_id": "college_1",
    "strict_match": false,
    "score": 65,
    "reason": "Different exclusion logic: Gen uses NOT IN with subquery on lop_hoc, Gold uses EXCEPT with different JOIN structure. Also different SELECT columns: Gen selects both ho_cua_nhan_vien and ten_cua_nhan_vien, Gold selects only ten_cua_nhan_vien."
  },
  {
    "id": 534,
    "db_id": "college_1",
    "strict_match": false,
    "score": 65,
    "reason": "Gen query selects two columns (ho_cua_nhan_vien, ten_cua_nhan_vien) while Gold selects only one (ten_cua_nhan_vien), and Gen uses NOT IN with subquery while Gold uses EXCEPT with JOIN, which are semantically different approaches for exclusion."
  },
  {
    "id": 535,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent after normalizing aliases and treating 'Lịch sử' and 'history' as equivalent Vietnamese-English values. Both queries join the same tables with identical join conditions and return the same columns."
  },
  {
    "id": 536,
    "db_id": "college_1",
    "strict_match": false,
    "score": 30,
    "reason": "Generated query joins giao_su directly with khoa using ma_khoa, while Gold query joins nhan_vien with giao_su using ma_so_nhan_vien, then joins with khoa. Different table relationships and join conditions lead to different result sets."
  },
  {
    "id": 537,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical after normalizing aliases, case, and whitespace. Both join the same three tables with equivalent conditions and filter on the same column with the same value (case-insensitive comparison)."
  },
  {
    "id": 538,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Generated query selects different columns (giao_su.ma_khoa) and joins fewer tables (missing khoa table) compared to Gold query which selects t3.ten_khoa and includes an additional JOIN with khoa table."
  },
  {
    "id": 539,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, table order, and case. Both join the same tables with the same condition and select the same columns with the same WHERE filter."
  },
  {
    "id": 540,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, table order, and case differences. Both join the same tables with the same condition and select the same columns with the same WHERE filter."
  },
  {
    "id": 541,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same four tables with equivalent join conditions and filter on the same column with the same value (case-insensitive). The only differences are cosmetic: table aliases, formatting, and keyword case."
  },
  {
    "id": 542,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same three tables with identical join conditions and WHERE clause filtering for the same surname value (case-insensitive). The only differences are table aliases and column reference order, which are cosmetic."
  },
  {
    "id": 543,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same four tables with equivalent join conditions and filter on the same column with the same value (case-insensitive comparison). The only differences are table aliases, column order in SELECT, and whitespace formatting."
  },
  {
    "id": 544,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Queries are semantically identical after normalizing aliases, case, and column order. Both join the same tables with equivalent conditions and filter on the same column with the same value."
  },
  {
    "id": 545,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries use different values in the WHERE condition: Gen checks for Vietnamese degree names ('Tiến sĩ', 'Thạc sĩ') while Gold checks for English abbreviations ('ph.d.', 'ma'). These are not equivalent values according to the provided equivalence rules."
  },
  {
    "id": 546,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "The queries use different values in the WHERE condition ('Tiến sĩ', 'Thạc sĩ' vs 'ph.d.', 'ma'), which are not equivalent according to the provided language mapping rules. This creates different semantic filtering criteria."
  },
  {
    "id": 547,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences (aliases, formatting) and English/Vietnamese value equivalence in WHERE conditions ('Kế toán' = 'accounting', 'Sinh học' = 'biology')."
  },
  {
    "id": 548,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "The queries are semantically equivalent with only cosmetic differences (aliases, formatting) and English/Vietnamese value equivalences ('Kế toán' = 'accounting', 'Sinh học' = 'biology'). Both count professors in the same departments."
  },
  {
    "id": 549,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "Gen uses WHERE...IN to find employees teaching either CIS-220 OR QM-261, while Gold uses INTERSECT to find employees teaching BOTH CIS-220 AND QM-261. These are semantically different set operations (OR vs AND logic)."
  },
  {
    "id": 550,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "Gen uses WHERE...IN to find courses in either 'CIS-220' or 'QM-261', while Gold uses INTERSECT to find courses that are BOTH 'cis-220' AND 'qm-261'. These are semantically different operations (OR vs AND logic)."
  },
  {
    "id": 551,
    "db_id": "college_1",
    "strict_match": false,
    "score": 50,
    "reason": "The queries have different SELECT columns (Gen selects both ho_cua_sinh_vien and ten_cua_sinh_vien, Gold selects only ten_cua_sinh_vien) and different WHERE conditions (Vietnamese vs English department names that are not listed as equivalent pairs in the rules)."
  },
  {
    "id": 552,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "Both queries return students enrolled in both specified departments, with only minor differences: Gen uses GROUP BY/HAVING with Vietnamese department names, Gold uses INTERSECT with English department names, but the English/Vietnamese values are semantically equivalent."
  },
  {
    "id": 553,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries calculate the average GPA of students enrolled in course 'ACCT-211' using the same tables, join conditions, and filtering logic, with only cosmetic differences in aliases and formatting."
  },
  {
    "id": 554,
    "db_id": "college_1",
    "strict_match": false,
    "score": 65,
    "reason": "Different JOIN conditions: Gen uses 'lop_hoc.ma_khoa_hoc = khoa_hoc.ma_khoa_hoc' while Gold uses 't1.ma_lop = t3.ma_lop_hoc' and filters with 't3.ma_khoa_hoc = \"acct-211\"'. Also different table structures: Gen includes khoa_hoc table explicitly, Gold doesn't."
  },
  {
    "id": 555,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same table with identical ORDER BY and LIMIT clauses. The only differences are column order in SELECT (cosmetic) and keyword case/whitespace formatting."
  },
  {
    "id": 556,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries select the same columns from the same table with identical ORDER BY and LIMIT clauses. The only differences are column order in SELECT and keyword case, which are cosmetic."
  },
  {
    "id": 557,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, select the same column, use the same ORDER BY logic, and return the same single row. The differences are purely cosmetic (aliases, keyword case, and column prefix in ORDER BY)."
  },
  {
    "id": 558,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, select the same column (ten_khoa), and use the same ORDER BY logic with LIMIT 1. The only differences are cosmetic: table aliases and keyword case."
  },
  {
    "id": 559,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries return students with below-average GPA, but Gen includes an extra column (ho_cua_sinh_vien) in SELECT that Gold doesn't request. This is a minor cosmetic difference that doesn't affect the main answer."
  },
  {
    "id": 560,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "The queries are semantically identical - both select students with GPA below average from the same table using the same subquery. The only differences are cosmetic (whitespace, keyword case, and parentheses formatting)."
  },
  {
    "id": 561,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with identical join conditions, group by the same column (ma_khoa), and select functionally dependent columns (ten_khoa, dia_chi_khoa) from the khoa table. The only differences are table aliases and formatting, which are cosmetic."
  },
  {
    "id": 562,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same functionally dependent column, and return the same results with identical ordering and limiting."
  },
  {
    "id": 563,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries join the same tables with equivalent conditions, group by the same key column (ma_khoa), select the same columns, and order/limit identically. The only differences are cosmetic: table aliases, column alias naming, and whitespace formatting."
  },
  {
    "id": 564,
    "db_id": "college_1",
    "strict_match": true,
    "score": 100,
    "reason": "Both queries are semantically identical - they join the same tables with the same condition, group by the same key column, select the same columns, and order/limit identically. The only differences are cosmetic (aliases, formatting, column order in SELECT)."
  },
  {
    "id": 565,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Gen query filters directly on giao_su.ma_khoa = 'Lịch sử' while Gold query joins with khoa table and filters on t3.ten_khoa = 'history'. These are different filtering conditions that may not be equivalent."
  },
  {
    "id": 566,
    "db_id": "college_1",
    "strict_match": true,
    "score": 97,
    "reason": "Queries are semantically equivalent with only cosmetic differences: table aliases, column order, and English/Vietnamese value equivalents ('Lịch sử' = 'history', 'Tiến sĩ' = 'ph.d.'). Both join the same tables with identical conditions."
  },
  {
    "id": 567,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Both queries join the same tables with identical conditions, but Gen includes an extra column (ho_cua_nhan_vien) in SELECT that Gold doesn't request. The main answer (ten_cua_nhan_vien and ma_khoa_hoc) would be the same."
  },
  {
    "id": 568,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Different columns selected: Gen selects ho_cua_nhan_vien, ten_cua_nhan_vien, ma_lop_hoc while Gold selects ten_cua_nhan_vien, ma_khoa_hoc. Also different table references: ma_lop_hoc vs ma_khoa_hoc suggests different column names."
  },
  {
    "id": 569,
    "db_id": "college_1",
    "strict_match": false,
    "score": 40,
    "reason": "Generated query includes an extra table (giao_su) and an extra column (ho_cua_nhan_vien) that are not present in the gold query, resulting in different JOIN logic and different result sets."
  },
  {
    "id": 570,
    "db_id": "college_1",
    "strict_match": false,
    "score": 75,
    "reason": "Generated query includes extra column 'ho_cua_nhan_vien' in SELECT clause that Gold query does not have. Both queries join the same tables with identical conditions and would return the same core information about courses and instructors."
  },
  {
    "id": 571,
    "db_id": "college_1",
    "strict_match": false,
    "score": 70,
    "reason": "Both queries join the same tables with equivalent join conditions, but Gen includes an extra column (ho_cua_nhan_vien) in SELECT that Gold does not have. This is a minor difference as the core logic is identical."
  },
  {
    "id": 572,
    "db_id": "college_1",
    "strict_match": false,
    "score": 70,
    "reason": "Both queries join the same tables with equivalent join conditions, but Gen includes an extra column (ho_cua_nhan_vien) in SELECT that Gold doesn't have. This is a minor difference that doesn't affect the core result set structure."
  }
]